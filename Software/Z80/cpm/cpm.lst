# File bios/bios.asm
0000			;**************************************************************************** 
0000			;	 
0000			;	TeachZ80 BIOS  
0000			; 
0000			;	Minor changes versus original code from John, to run to TeachZ80 boards 
0000			;	https://github.com/Z80-Retro/2063-Z80-cpm/blob/main/retro/retro.asm 
0000			; 
0000			;	Adjusted by Christian Luethi 
0000			;	January 2024 
0000			; 
0000			;**************************************************************************** 
0000			; 
0000			;    Z80 Retro! BIOS  
0000			; 
0000			;    Copyright (C) 2021,2022 John Winans 
0000			; 
0000			;    This library is free software; you can redistribute it and/or 
0000			;    modify it under the terms of the GNU Lesser General Public 
0000			;    License as published by the Free Software Foundation; either 
0000			;    version 2.1 of the License, or (at your option) any later version. 
0000			; 
0000			;    This library is distributed in the hope that it will be useful, 
0000			;    but WITHOUT ANY WARRANTY; without even the implied warranty of 
0000			;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
0000			;    Lesser General Public License for more details. 
0000			; 
0000			;    You should have received a copy of the GNU Lesser General Public 
0000			;    License along with this library; if not, write to the Free Software 
0000			;    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 
0000			;    USA 
0000			; 
0000			; 
0000			;**************************************************************************** 
0000			 
0000			;**************************************************************************** 
0000			; 
0000			; Memory banks: 
0000			; 
0000			; BANK     Usage 
0000			;   0    SD cache bank 0 
0000			;   1    SD cache bank 1 
0000			;   2    SD cache bank 2 
0000			;   3    SD cache bank 3 
0000			;   4 
0000			;   5 
0000			;   6 
0000			;   7 
0000			;   8 
0000			;   9 
0000			;   A 
0000			;   B 
0000			;   C 
0000			;   D 
0000			;   E    CP/M zero page and low half of the TPA 
0000			;   F    CP/M high half of the TPA, CCP, BDOS, and BIOS 
0000			; 
0000			;**************************************************************************** 
0000			.low_bank:	equ		14	; The RAM BANK to use for the bottom 32K 
0000			 
0000			 
0000			;########################################################################## 
0000			; set .debug to: 
0000			;    0 = no debug output 
0000			;    1 = print messages from new code under development 
0000			;    2 = print all the above plus the primairy 'normal' debug messages 
0000			;    3 = print all the above plus verbose 'noisy' debug messages 
0000			;########################################################################## 
0000			.debug:		equ	0 
0000			 
0000			include	'io.asm' 
0000			 
0000			;**************************************************************************** 
0000			;   TeachZ80 I/O definitions.  
0000			; 
0000			;   Original code from John Winans, Z80 Retro! 
0000			;**************************************************************************** 
0000			 
0000			;**************************************************************************** 
0000			;  TeachZ80 Version 1 IO port definitions 
0000			;**************************************************************************** 
0000			gpio_in_0:          equ     0x00        ; GP input port 0 
0000			gpio_in_1:          equ     0x50        ; GP input port 1 
0000			gpio_out_0:         equ     0x10        ; GP output port 0 
0000			gpio_out_1:         equ     0x20        ; GP output port 1, only lower 4 bits available 
0000			stm32_port:         equ     0x60        ; for communicaation with stm32 
0000			 
0000			sio_ad:             equ     0x30        ; SIO port A, data 
0000			sio_bd:             equ     0x31        ; SIO port B, data 
0000			sio_ac:             equ     0x32        ; SIO port A, control 
0000			sio_bc:             equ     0x33        ; SIO port B, control 
0000			 
0000			ctc_0:              equ     0x40        ; CTC port 0 
0000			ctc_1:              equ     0x41        ; CTC port 1 
0000			ctc_2:              equ     0x42        ; CTC port 2 
0000			ctc_3:              equ     0x43        ; CTC port 3 
0000			 
0000			flash_disable:      equ     0x70        ; dummy-read from this port to disable the FLASH and switch to RAM 
0000			 
0000			;**************************************************************************** 
0000			;  TeachZ80 Bit Assignments 
0000			;**************************************************************************** 
0000			; GP-Output-0 --------------------------------------------------------------- 
0000			gpio_out_0_sd_mosi: equ     0x01 
0000			gpio_out_0_sd_clk:  equ     0x02 
0000			gpio_out_0_sd_ssel: equ     0x04 
0000			gpio_out_0_user_8:  equ     0x08 
0000			gpio_out_0_a15:     equ     0x10 
0000			gpio_out_0_a16:     equ     0x20 
0000			gpio_out_0_a17:     equ     0x40 
0000			gpio_out_0_a18:     equ     0x80 
0000			 
0000			; GP-Output-1 --------------------------------------------------------------- 
0000			gpio_out_1_user_0:  equ     0x01 
0000			gpio_out_1_user_1:  equ     0x02 
0000			gpio_out_1_user_2:  equ     0x04 
0000			gpio_out_1_user_3:  equ     0x08 
0000			gpio_out_1_user_4:  equ     0x10 
0000			gpio_out_1_user_5:  equ     0x20 
0000			gpio_out_1_user_6:  equ     0x40 
0000			gpio_out_1_user_7:  equ     0x80 
0000			 
0000			; GP-Input-0 ---------------------------------------------------------------- 
0000			gpio_in_0_user_0:   equ     0x01 
0000			gpio_in_0_user_1:   equ     0x02 
0000			gpio_in_0_user_2:   equ     0x04 
0000			gpio_in_0_user_3:   equ     0x08 
0000			gpio_in_0_user_4:   equ     0x10 
0000			gpio_in_0_user_5:   equ     0x20 
0000			gpio_in_0_sd_det:   equ     0x40 
0000			gpio_in_0_sd_miso:  equ     0x80 
0000			 
0000			; GP-Input-1 ---------------------------------------------------------------- 
0000			gpio_in_1_user_6:   equ     0x01 
0000			gpio_in_1_user_7:   equ     0x02 
0000			gpio_in_1_user_8:   equ     0x04 
0000			gpio_in_1_user_9:   equ     0x08 
0000			 
0000			 
0000			;**************************************************************************** 
0000			;  Z80 Retro! definitions kept to maintain compatibility with Johns Software 
0000			;**************************************************************************** 
0000			; Z80 Retro Rev 3 IO port definitions 
0000			gpio_in:            equ     0x00        ; GP input port 
0000			gpio_out:           equ     0x10        ; GP output port 
0000			prn_dat:            equ     0x20        ; printer data out 
0000			 
0000			; bit-assignments for General Purpose output port  
0000			gpio_out_sd_mosi:   equ     0x01 
0000			gpio_out_sd_clk:    equ     0x02 
0000			gpio_out_sd_ssel:   equ     0x04 
0000			gpio_out_prn_stb:   equ     0x08 
0000			gpio_out_a15:       equ     0x10 
0000			gpio_out_a16:       equ     0x20 
0000			gpio_out_a17:       equ     0x40 
0000			gpio_out_a18:       equ     0x80 
0000			 
0000			; bit-assignments for General Purpose input port  
0000			gpio_in_prn_err:    equ     0x01 
0000			gpio_in_prn_stat:   equ     0x02 
0000			gpio_in_prn_papr:   equ     0x04 
0000			gpio_in_prn_bsy:    equ     0x08 
0000			gpio_in_prn_ack:    equ     0x10 
0000			gpio_in_user1:      equ     0x20  
0000			gpio_in_sd_det:     equ     0x40 
0000			gpio_in_sd_miso:    equ     0x80 
0000			 
0000			; a bitmask representing all of the lobank address bits  
0000			gpio_out_lobank:	equ	0|(gpio_out_a15|gpio_out_a16|gpio_out_a17|gpio_out_a18)
# End of file io.asm
0000			include	'memory.asm' 
0000			;**************************************************************************** 
0000			; 
0000			;    Copyright (C) 2021 John Winans 
0000			; 
0000			;    This library is free software; you can redistribute it and/or 
0000			;    modify it under the terms of the GNU Lesser General Public 
0000			;    License as published by the Free Software Foundation; either 
0000			;    version 2.1 of the License, or (at your option) any later version. 
0000			; 
0000			;    This library is distributed in the hope that it will be useful, 
0000			;    but WITHOUT ANY WARRANTY; without even the implied warranty of 
0000			;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
0000			;    Lesser General Public License for more details. 
0000			; 
0000			;    You should have received a copy of the GNU Lesser General Public 
0000			;    License along with this library; if not, write to the Free Software 
0000			;    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 
0000			;    USA 
0000			; 
0000			; https://github.com/johnwinans/2063-Z80-cpm 
0000			; 
0000			;**************************************************************************** 
0000			 
0000			; Define the memory size to be used for the CP/M configuration 
0000			MEM:    equ 60 
0000			; The CPM origin will be at: (MEM-7)*1024 
0000			; This screwy convention is due to the way that that the CP/M origin is defined. 
0000			CPM_BASE:	equ	(MEM-7)*1024 
0000			LOAD_BASE:	equ	0xC000		; where the boot loader reads the image from the SD card
# End of file memory.asm
0000			 
0000				org		LOAD_BASE		; Where the boot loader places this code. 
c000			 
c000				; When we arrive here from the boot loader: 
c000				; If A=0 then the SD was booted from a partition that starts at 0x800. 
c000				; 
c000				; If A=1 then: 
c000				; C = partition number (1, 2, 3 or 4) 
c000				; DE = the high 16 bits of the starting SD block number 
c000				; HL = the low 16 bits of the starting SD block number 
c000 b7				or		a 
c001 ca 33 ea			jp		z,.bios_boot 
c004			 
c004				; A != 0, patch the BIOS to use the given offset when accessing the SD card 
c004 22 79 ed			ld		(disk_offset_low),hl 
c007 ed 53 7b ed		ld		(disk_offset_hi),de 
c00b c3 33 ea			jp		.bios_boot 
c00e			 
c00e				; The 'org' in cpm22.asm does not generate any fill so we must 
c00e				; padd memory out to the base location of CP/M 
c00e 0xff...			ds		CPM_BASE-$,0xff 
d400			 
d400			;########################################################################## 
d400			; 
d400			; In a traditional system, the CP/M CCP and BDOS is manually copied into 
d400			; place when linking it with the BIOS.   
d400			; 
d400			; In this build we cheat by simply compiling the CP/M source in with the  
d400			; BIOS. 
d400			; 
d400			;########################################################################## 
d400			include '../cpm-2.2/src/cpm22.asm' 
d400			;************************************************************** 
d400			;* 
d400			;*             C P / M   version   2 . 2 
d400			;* 
d400			;*   Reconstructed from memory image on February 27, 1981 
d400			;* 
d400			;*                by Clark A. Calkins 
d400			;* 
d400			;************************************************************** 
d400			; 
d400			;   Set memory limit here. This is the amount of contigeous 
d400			; ram starting from 0000. CP/M will reside at the end of this space. 
d400			; 
d400			;MEM     EQU     62              ;for a 62k system (TS802 TEST - WORKS OK). 
d400			; 
d400			IOBYTE:  EQU     3               ;i/o definition byte. 
d400			TDRIVE:  EQU     4               ;current drive name and user number. 
d400			ENTRY:   EQU     5               ;entry point for the cp/m bdos. 
d400			TFCB:    EQU     5CH             ;default file control block. 
d400			TBUFF:   EQU     80H             ;i/o buffer and command line storage. 
d400			TBASE:   EQU     100H            ;transiant program storage area. 
d400			; 
d400			;   Set control character equates. 
d400			; 
d400			CNTRLC:  EQU     3               ;control-c 
d400			CNTRLE:  EQU     05H             ;control-e 
d400			BS:      EQU     08H             ;backspace 
d400			TAB:     EQU     09H             ;tab 
d400			LF:      EQU     0AH             ;line feed 
d400			FF:      EQU     0CH             ;form feed 
d400			CR:      EQU     0DH             ;carriage return 
d400			CNTRLP:  EQU     10H             ;control-p 
d400			CNTRLR:  EQU     12H             ;control-r 
d400			CNTRLS:  EQU     13H             ;control-s 
d400			CNTRLU:  EQU     15H             ;control-u 
d400			CNTRLX:  EQU     18H             ;control-x 
d400			CNTRLZ:  EQU     1AH             ;control-z (end-of-file mark) 
d400			DEL:     EQU     7FH             ;rubout 
d400			; 
d400			;   Set origin for CP/M 
d400			; 
d400			        ORG     (MEM-7)*1024 
d400			; 
d400 c3 5c d7		CBASE:  JP      COMMAND         ;execute command processor (ccp). 
d403 c3 58 d7		        JP      CLEARBUF        ;entry to empty input buffer before starting ccp. 
d406			 
d406			; 
d406			;   Standard cp/m ccp input buffer. Format is (max length), 
d406			; (actual length), (char #1), (char #2), (char #3), etc. 
d406			; 
d406 7f			INBUFF: DEFB    127             ;length of input buffer. 
d407 00			        DEFB    0               ;current length of contents. 
d408 ..			        DEFB    'Copyright' 
d411 ..			        DEFB    ' 1979 (c) by Digital Research      ' 
d434 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00	        DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
d44b 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00	        DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
d462 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00	        DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
d479 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00	        DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
d488 08 d4		INPOINT:DEFW    INBUFF+2        ;input line pointer 
d48a 00 00		NAMEPNT:DEFW    0               ;input line pointer used for error message. Points to 
d48c			;                       ;start of name in error. 
d48c			; 
d48c			;   Routine to print (A) on the console. All registers used. 
d48c			; 
d48c 5f			PRINT:  LD      E,A             ;setup bdos call. 
d48d 0e 02		        LD      C,2 
d48f c3 05 00		        JP      ENTRY 
d492			; 
d492			;   Routine to print (A) on the console and to save (BC). 
d492			; 
d492 c5			PRINTB: PUSH    BC 
d493 cd 8c d4		        CALL    PRINT 
d496 c1			        POP     BC 
d497 c9			        RET      
d498			; 
d498			;   Routine to send a carriage return, line feed combination 
d498			; to the console. 
d498			; 
d498 3e 0d		CRLF:   LD      A,CR 
d49a cd 92 d4		        CALL    PRINTB 
d49d 3e 0a		        LD      A,LF 
d49f c3 92 d4		        JP      PRINTB 
d4a2			; 
d4a2			;   Routine to send one space to the console and save (BC). 
d4a2			; 
d4a2 3e 20		SPACE:  LD      A,' ' 
d4a4 c3 92 d4		        JP      PRINTB 
d4a7			; 
d4a7			;   Routine to print character string pointed to be (BC) on the 
d4a7			; console. It must terminate with a null byte. 
d4a7			; 
d4a7 c5			PLINE:  PUSH    BC 
d4a8 cd 98 d4		        CALL    CRLF 
d4ab e1			        POP     HL 
d4ac 7e			PLINE2: LD      A,(HL) 
d4ad b7			        OR      A 
d4ae c8			        RET     Z 
d4af 23			        INC     HL 
d4b0 e5			        PUSH    HL 
d4b1 cd 8c d4		        CALL    PRINT 
d4b4 e1			        POP     HL 
d4b5 c3 ac d4		        JP      PLINE2 
d4b8			; 
d4b8			;   Routine to reset the disk system. 
d4b8			; 
d4b8 0e 0d		RESDSK: LD      C,13 
d4ba c3 05 00		        JP      ENTRY 
d4bd			; 
d4bd			;   Routine to select disk (A). 
d4bd			; 
d4bd 5f			DSKSEL: LD      E,A 
d4be 0e 0e		        LD      C,14 
d4c0 c3 05 00		        JP      ENTRY 
d4c3			; 
d4c3			;   Routine to call bdos and save the return code. The zero 
d4c3			; flag is set on a return of 0ffh. 
d4c3			; 
d4c3 cd 05 00		ENTRY1: CALL    ENTRY 
d4c6 32 ee db		        LD      (RTNCODE),A     ;save return code. 
d4c9 3c			        INC     A               ;set zero if 0ffh returned. 
d4ca c9			        RET      
d4cb			; 
d4cb			;   Routine to open a file. (DE) must point to the FCB. 
d4cb			; 
d4cb 0e 0f		OPEN:   LD      C,15 
d4cd c3 c3 d4		        JP      ENTRY1 
d4d0			; 
d4d0			;   Routine to open file at (FCB). 
d4d0			; 
d4d0 af			OPENFCB:XOR     A               ;clear the record number byte at fcb+32 
d4d1 32 ed db		        LD      (FCB+32),A 
d4d4 11 cd db		        LD      DE,FCB 
d4d7 c3 cb d4		        JP      OPEN 
d4da			; 
d4da			;   Routine to close a file. (DE) points to FCB. 
d4da			; 
d4da 0e 10		CLOSE:  LD      C,16 
d4dc c3 c3 d4		        JP      ENTRY1 
d4df			; 
d4df			;   Routine to search for the first file with ambigueous name 
d4df			; (DE). 
d4df			; 
d4df 0e 11		SRCHFST:LD      C,17 
d4e1 c3 c3 d4		        JP      ENTRY1 
d4e4			; 
d4e4			;   Search for the next ambigeous file name. 
d4e4			; 
d4e4 0e 12		SRCHNXT:LD      C,18 
d4e6 c3 c3 d4		        JP      ENTRY1 
d4e9			; 
d4e9			;   Search for file at (FCB). 
d4e9			; 
d4e9 11 cd db		SRCHFCB:LD      DE,FCB 
d4ec c3 df d4		        JP      SRCHFST 
d4ef			; 
d4ef			;   Routine to delete a file pointed to by (DE). 
d4ef			; 
d4ef 0e 13		DELETE: LD      C,19 
d4f1 c3 05 00		        JP      ENTRY 
d4f4			; 
d4f4			;   Routine to call the bdos and set the zero flag if a zero 
d4f4			; status is returned. 
d4f4			; 
d4f4 cd 05 00		ENTRY2: CALL    ENTRY 
d4f7 b7			        OR      A               ;set zero flag if appropriate. 
d4f8 c9			        RET      
d4f9			; 
d4f9			;   Routine to read the next record from a sequential file. 
d4f9			; (DE) points to the FCB. 
d4f9			; 
d4f9 0e 14		RDREC:  LD      C,20 
d4fb c3 f4 d4		        JP      ENTRY2 
d4fe			; 
d4fe			;   Routine to read file at (FCB). 
d4fe			; 
d4fe 11 cd db		READFCB:LD      DE,FCB 
d501 c3 f9 d4		        JP      RDREC 
d504			; 
d504			;   Routine to write the next record of a sequential file. 
d504			; (DE) points to the FCB. 
d504			; 
d504 0e 15		WRTREC: LD      C,21 
d506 c3 f4 d4		        JP      ENTRY2 
d509			; 
d509			;   Routine to create the file pointed to by (DE). 
d509			; 
d509 0e 16		CREATE: LD      C,22 
d50b c3 c3 d4		        JP      ENTRY1 
d50e			; 
d50e			;   Routine to rename the file pointed to by (DE). Note that 
d50e			; the new name starts at (DE+16). 
d50e			; 
d50e 0e 17		RENAM:  LD      C,23 
d510 c3 05 00		        JP      ENTRY 
d513			; 
d513			;   Get the current user code. 
d513			; 
d513 1e ff		GETUSR: LD      E,0FFH 
d515			; 
d515			;   Routne to get or set the current user code. 
d515			; If (E) is FF then this is a GET, else it is a SET. 
d515			; 
d515 0e 20		GETSETUC: LD    C,32 
d517 c3 05 00		        JP      ENTRY 
d51a			; 
d51a			;   Routine to set the current drive byte at (TDRIVE). 
d51a			; 
d51a cd 13 d5		SETCDRV:CALL    GETUSR          ;get user number 
d51d 87			        ADD     A,A             ;and shift into the upper 4 bits. 
d51e 87			        ADD     A,A 
d51f 87			        ADD     A,A 
d520 87			        ADD     A,A 
d521 21 ef db		        LD      HL,CDRIVE       ;now add in the current drive number. 
d524 b6			        OR      (HL) 
d525 32 04 00		        LD      (TDRIVE),A      ;and save. 
d528 c9			        RET      
d529			; 
d529			;   Move currently active drive down to (TDRIVE). 
d529			; 
d529 3a ef db		MOVECD: LD      A,(CDRIVE) 
d52c 32 04 00		        LD      (TDRIVE),A 
d52f c9			        RET      
d530			; 
d530			;   Routine to convert (A) into upper case ascii. Only letters 
d530			; are affected. 
d530			; 
d530 fe 61		UPPER:  CP      'a'             ;check for letters in the range of 'a' to 'z'. 
d532 d8			        RET     C 
d533 fe 7b		        CP      '{' 
d535 d0			        RET     NC 
d536 e6 5f		        AND     5FH             ;convert it if found. 
d538 c9			        RET      
d539			; 
d539			;   Routine to get a line of input. We must check to see if the 
d539			; user is in (BATCH) mode. If so, then read the input from file 
d539			; ($$$.SUB). At the end, reset to console input. 
d539			; 
d539 3a ab db		GETINP: LD      A,(BATCH)       ;if =0, then use console input. 
d53c b7			        OR      A 
d53d ca 96 d5		        JP      Z,GETINP1 
d540			; 
d540			;   Use the submit file ($$$.sub) which is prepared by a 
d540			; SUBMIT run. It must be on drive (A) and it will be deleted 
d540			; if and error occures (like eof). 
d540			; 
d540 3a ef db		        LD      A,(CDRIVE)      ;select drive 0 if need be. 
d543 b7			        OR      A 
d544 3e 00		        LD      A,0             ;always use drive A for submit. 
d546 c4 bd d4		        CALL    NZ,DSKSEL       ;select it if required. 
d549 11 ac db		        LD      DE,BATCHFCB 
d54c cd cb d4		        CALL    OPEN            ;look for it. 
d54f ca 96 d5		        JP      Z,GETINP1       ;if not there, use normal input. 
d552 3a bb db		        LD      A,(BATCHFCB+15) ;get last record number+1. 
d555 3d			        DEC     A 
d556 32 cc db		        LD      (BATCHFCB+32),A 
d559 11 ac db		        LD      DE,BATCHFCB 
d55c cd f9 d4		        CALL    RDREC           ;read last record. 
d55f c2 96 d5		        JP      NZ,GETINP1      ;quit on end of file. 
d562			; 
d562			;   Move this record into input buffer. 
d562			; 
d562 11 07 d4		        LD      DE,INBUFF+1 
d565 21 80 00		        LD      HL,TBUFF        ;data was read into buffer here. 
d568 06 80		        LD      B,128           ;all 128 characters may be used. 
d56a cd 42 d8		        CALL    HL2DE           ;(HL) to (DE), (B) bytes. 
d56d 21 ba db		        LD      HL,BATCHFCB+14 
d570 36 00		        LD      (HL),0          ;zero out the 's2' byte. 
d572 23			        INC     HL              ;and decrement the record count. 
d573 35			        DEC     (HL) 
d574 11 ac db		        LD      DE,BATCHFCB     ;close the batch file now. 
d577 cd da d4		        CALL    CLOSE 
d57a ca 96 d5		        JP      Z,GETINP1       ;quit on an error. 
d57d 3a ef db		        LD      A,(CDRIVE)      ;re-select previous drive if need be. 
d580 b7			        OR      A 
d581 c4 bd d4		        CALL    NZ,DSKSEL       ;don't do needless selects. 
d584			; 
d584			;   Print line just read on console. 
d584			; 
d584 21 08 d4		        LD      HL,INBUFF+2 
d587 cd ac d4		        CALL    PLINE2 
d58a cd c2 d5		        CALL    CHKCON          ;check console, quit on a key. 
d58d ca a7 d5		        JP      Z,GETINP2       ;jump if no key is pressed. 
d590			; 
d590			;   Terminate the submit job on any keyboard input. Delete this 
d590			; file such that it is not re-started and jump to normal keyboard 
d590			; input section. 
d590			; 
d590 cd dd d5		        CALL    DELBATCH        ;delete the batch file. 
d593 c3 82 d7		        JP      CMMND1          ;and restart command input. 
d596			; 
d596			;   Get here for normal keyboard input. Delete the submit file 
d596			; incase there was one. 
d596			; 
d596 cd dd d5		GETINP1:CALL    DELBATCH        ;delete file ($$$.sub). 
d599 cd 1a d5		        CALL    SETCDRV         ;reset active disk. 
d59c 0e 0a		        LD      C,10            ;get line from console device. 
d59e 11 06 d4		        LD      DE,INBUFF 
d5a1 cd 05 00		        CALL    ENTRY 
d5a4 cd 29 d5		        CALL    MOVECD          ;reset current drive (again). 
d5a7			; 
d5a7			;   Convert input line to upper case. 
d5a7			; 
d5a7 21 07 d4		GETINP2:LD      HL,INBUFF+1 
d5aa 46			        LD      B,(HL)          ;(B)=character counter. 
d5ab 23			GETINP3:INC     HL 
d5ac 78			        LD      A,B             ;end of the line? 
d5ad b7			        OR      A 
d5ae ca ba d5		        JP      Z,GETINP4 
d5b1 7e			        LD      A,(HL)          ;convert to upper case. 
d5b2 cd 30 d5		        CALL    UPPER 
d5b5 77			        LD      (HL),A 
d5b6 05			        DEC     B               ;adjust character count. 
d5b7 c3 ab d5		        JP      GETINP3 
d5ba 77			GETINP4:LD      (HL),A          ;add trailing null. 
d5bb 21 08 d4		        LD      HL,INBUFF+2 
d5be 22 88 d4		        LD      (INPOINT),HL    ;reset input line pointer. 
d5c1 c9			        RET      
d5c2			; 
d5c2			;   Routine to check the console for a key pressed. The zero 
d5c2			; flag is set is none, else the character is returned in (A). 
d5c2			; 
d5c2 0e 0b		CHKCON: LD      C,11            ;check console. 
d5c4 cd 05 00		        CALL    ENTRY 
d5c7 b7			        OR      A 
d5c8 c8			        RET     Z               ;return if nothing. 
d5c9 0e 01		        LD      C,1             ;else get character. 
d5cb cd 05 00		        CALL    ENTRY 
d5ce b7			        OR      A               ;clear zero flag and return. 
d5cf c9			        RET      
d5d0			; 
d5d0			;   Routine to get the currently active drive number. 
d5d0			; 
d5d0 0e 19		GETDSK: LD      C,25 
d5d2 c3 05 00		        JP      ENTRY 
d5d5			; 
d5d5			;   Set the stabdard dma address. 
d5d5			; 
d5d5 11 80 00		STDDMA: LD      DE,TBUFF 
d5d8			; 
d5d8			;   Routine to set the dma address to (DE). 
d5d8			; 
d5d8 0e 1a		DMASET: LD      C,26 
d5da c3 05 00		        JP      ENTRY 
d5dd			; 
d5dd			;  Delete the batch file created by SUBMIT. 
d5dd			; 
d5dd 21 ab db		DELBATCH: LD    HL,BATCH        ;is batch active? 
d5e0 7e			        LD      A,(HL) 
d5e1 b7			        OR      A 
d5e2 c8			        RET     Z 
d5e3 36 00		        LD      (HL),0          ;yes, de-activate it. 
d5e5 af			        XOR     A 
d5e6 cd bd d4		        CALL    DSKSEL          ;select drive 0 for sure. 
d5e9 11 ac db		        LD      DE,BATCHFCB     ;and delete this file. 
d5ec cd ef d4		        CALL    DELETE 
d5ef 3a ef db		        LD      A,(CDRIVE)      ;reset current drive. 
d5f2 c3 bd d4		        JP      DSKSEL 
d5f5			; 
d5f5			;   Check to two strings at (PATTRN1) and (PATTRN2). They must be 
d5f5			; the same or we halt.... 
d5f5			; 
d5f5 11 28 d7		VERIFY: LD      DE,PATTRN1      ;these are the serial number bytes. 
d5f8 21 00 dc		        LD      HL,PATTRN2      ;ditto, but how could they be different? 
d5fb 06 06		        LD      B,6             ;6 bytes each. 
d5fd 1a			VERIFY1:LD      A,(DE) 
d5fe be			        CP      (HL) 
d5ff c2 cf d7		        JP      NZ,HALT         ;jump to halt routine. 
d602 13			        INC     DE 
d603 23			        INC     HL 
d604 05			        DEC     B 
d605 c2 fd d5		        JP      NZ,VERIFY1 
d608 c9			        RET      
d609			; 
d609			;   Print back file name with a '?' to indicate a syntax error. 
d609			; 
d609 cd 98 d4		SYNERR: CALL    CRLF            ;end current line. 
d60c 2a 8a d4		        LD      HL,(NAMEPNT)    ;this points to name in error. 
d60f 7e			SYNERR1:LD      A,(HL)          ;print it until a space or null is found. 
d610 fe 20		        CP      ' ' 
d612 ca 22 d6		        JP      Z,SYNERR2 
d615 b7			        OR      A 
d616 ca 22 d6		        JP      Z,SYNERR2 
d619 e5			        PUSH    HL 
d61a cd 8c d4		        CALL    PRINT 
d61d e1			        POP     HL 
d61e 23			        INC     HL 
d61f c3 0f d6		        JP      SYNERR1 
d622 3e 3f		SYNERR2:LD      A,'?'           ;add trailing '?'. 
d624 cd 8c d4		        CALL    PRINT 
d627 cd 98 d4		        CALL    CRLF 
d62a cd dd d5		        CALL    DELBATCH        ;delete any batch file. 
d62d c3 82 d7		        JP      CMMND1          ;and restart from console input. 
d630			; 
d630			;   Check character at (DE) for legal command input. Note that the 
d630			; zero flag is set if the character is a delimiter. 
d630			; 
d630 1a			CHECK:  LD      A,(DE) 
d631 b7			        OR      A 
d632 c8			        RET     Z 
d633 fe 20		        CP      ' '             ;control characters are not legal here. 
d635 da 09 d6		        JP      C,SYNERR 
d638 c8			        RET     Z               ;check for valid delimiter. 
d639 fe 3d		        CP      '=' 
d63b c8			        RET     Z 
d63c fe 5f		        CP      '_' 
d63e c8			        RET     Z 
d63f fe 2e		        CP      '.' 
d641 c8			        RET     Z 
d642 fe 3a		        CP      ':' 
d644 c8			        RET     Z 
d645 fe 3b		        CP      ';' 
d647 c8			        RET     Z 
d648 fe 3c		        CP      '<' 
d64a c8			        RET     Z 
d64b fe 3e		        CP      '>' 
d64d c8			        RET     Z 
d64e c9			        RET      
d64f			; 
d64f			;   Get the next non-blank character from (DE). 
d64f			; 
d64f 1a			NONBLANK: LD    A,(DE) 
d650 b7			        OR      A               ;string ends with a null. 
d651 c8			        RET     Z 
d652 fe 20		        CP      ' ' 
d654 c0			        RET     NZ 
d655 13			        INC     DE 
d656 c3 4f d6		        JP      NONBLANK 
d659			; 
d659			;   Add (HL)=(HL)+(A) 
d659			; 
d659 85			ADDHL:  ADD     A,L 
d65a 6f			        LD      L,A 
d65b d0			        RET     NC              ;take care of any carry. 
d65c 24			        INC     H 
d65d c9			        RET      
d65e			; 
d65e			;   Convert the first name in (FCB). 
d65e			; 
d65e 3e 00		CONVFST:LD      A,0 
d660			; 
d660			;   Format a file name (convert * to '?', etc.). On return, 
d660			; (A)=0 is an unambigeous name was specified. Enter with (A) equal to 
d660			; the position within the fcb for the name (either 0 or 16). 
d660			; 
d660 21 cd db		CONVERT:LD      HL,FCB 
d663 cd 59 d6		        CALL    ADDHL 
d666 e5			        PUSH    HL 
d667 e5			        PUSH    HL 
d668 af			        XOR     A 
d669 32 f0 db		        LD      (CHGDRV),A      ;initialize drive change flag. 
d66c 2a 88 d4		        LD      HL,(INPOINT)    ;set (HL) as pointer into input line. 
d66f eb			        EX      DE,HL 
d670 cd 4f d6		        CALL    NONBLANK        ;get next non-blank character. 
d673 eb			        EX      DE,HL 
d674 22 8a d4		        LD      (NAMEPNT),HL    ;save pointer here for any error message. 
d677 eb			        EX      DE,HL 
d678 e1			        POP     HL 
d679 1a			        LD      A,(DE)          ;get first character. 
d67a b7			        OR      A 
d67b ca 89 d6		        JP      Z,CONVRT1 
d67e de 40		        SBC     A,'A'-1         ;might be a drive name, convert to binary. 
d680 47			        LD      B,A             ;and save. 
d681 13			        INC     DE              ;check next character for a ':'. 
d682 1a			        LD      A,(DE) 
d683 fe 3a		        CP      ':' 
d685 ca 90 d6		        JP      Z,CONVRT2 
d688 1b			        DEC     DE              ;nope, move pointer back to the start of the line. 
d689 3a ef db		CONVRT1:LD      A,(CDRIVE) 
d68c 77			        LD      (HL),A 
d68d c3 96 d6		        JP      CONVRT3 
d690 78			CONVRT2:LD      A,B 
d691 32 f0 db		        LD      (CHGDRV),A      ;set change in drives flag. 
d694 70			        LD      (HL),B 
d695 13			        INC     DE 
d696			; 
d696			;   Convert the basic file name. 
d696			; 
d696 06 08		CONVRT3:LD      B,08H 
d698 cd 30 d6		CONVRT4:CALL    CHECK 
d69b ca b9 d6		        JP      Z,CONVRT8 
d69e 23			        INC     HL 
d69f fe 2a		        CP      '*'             ;note that an '*' will fill the remaining 
d6a1 c2 a9 d6		        JP      NZ,CONVRT5      ;field with '?'. 
d6a4 36 3f		        LD      (HL),'?' 
d6a6 c3 ab d6		        JP      CONVRT6 
d6a9 77			CONVRT5:LD      (HL),A 
d6aa 13			        INC     DE 
d6ab 05			CONVRT6:DEC     B 
d6ac c2 98 d6		        JP      NZ,CONVRT4 
d6af cd 30 d6		CONVRT7:CALL    CHECK           ;get next delimiter. 
d6b2 ca c0 d6		        JP      Z,GETEXT 
d6b5 13			        INC     DE 
d6b6 c3 af d6		        JP      CONVRT7 
d6b9 23			CONVRT8:INC     HL              ;blank fill the file name. 
d6ba 36 20		        LD      (HL),' ' 
d6bc 05			        DEC     B 
d6bd c2 b9 d6		        JP      NZ,CONVRT8 
d6c0			; 
d6c0			;   Get the extension and convert it. 
d6c0			; 
d6c0 06 03		GETEXT: LD      B,03H 
d6c2 fe 2e		        CP      '.' 
d6c4 c2 e9 d6		        JP      NZ,GETEXT5 
d6c7 13			        INC     DE 
d6c8 cd 30 d6		GETEXT1:CALL    CHECK 
d6cb ca e9 d6		        JP      Z,GETEXT5 
d6ce 23			        INC     HL 
d6cf fe 2a		        CP      '*' 
d6d1 c2 d9 d6		        JP      NZ,GETEXT2 
d6d4 36 3f		        LD      (HL),'?' 
d6d6 c3 db d6		        JP      GETEXT3 
d6d9 77			GETEXT2:LD      (HL),A 
d6da 13			        INC     DE 
d6db 05			GETEXT3:DEC     B 
d6dc c2 c8 d6		        JP      NZ,GETEXT1 
d6df cd 30 d6		GETEXT4:CALL    CHECK 
d6e2 ca f0 d6		        JP      Z,GETEXT6 
d6e5 13			        INC     DE 
d6e6 c3 df d6		        JP      GETEXT4 
d6e9 23			GETEXT5:INC     HL 
d6ea 36 20		        LD      (HL),' ' 
d6ec 05			        DEC     B 
d6ed c2 e9 d6		        JP      NZ,GETEXT5 
d6f0 06 03		GETEXT6:LD      B,3 
d6f2 23			GETEXT7:INC     HL 
d6f3 36 00		        LD      (HL),0 
d6f5 05			        DEC     B 
d6f6 c2 f2 d6		        JP      NZ,GETEXT7 
d6f9 eb			        EX      DE,HL 
d6fa 22 88 d4		        LD      (INPOINT),HL    ;save input line pointer. 
d6fd e1			        POP     HL 
d6fe			; 
d6fe			;   Check to see if this is an ambigeous file name specification. 
d6fe			; Set the (A) register to non zero if it is. 
d6fe			; 
d6fe 01 0b 00		        LD      BC,11           ;set name length. 
d701 23			GETEXT8:INC     HL 
d702 7e			        LD      A,(HL) 
d703 fe 3f		        CP      '?'             ;any question marks? 
d705 c2 09 d7		        JP      NZ,GETEXT9 
d708 04			        INC     B               ;count them. 
d709 0d			GETEXT9:DEC     C 
d70a c2 01 d7		        JP      NZ,GETEXT8 
d70d 78			        LD      A,B 
d70e b7			        OR      A 
d70f c9			        RET      
d710			; 
d710			;   CP/M command table. Note commands can be either 3 or 4 characters long. 
d710			; 
d710			NUMCMDS: EQU     6               ;number of commands 
d710 ..			CMDTBL: DEFB    'DIR ' 
d714 ..			        DEFB    'ERA ' 
d718 ..			        DEFB    'TYPE' 
d71c ..			        DEFB    'SAVE' 
d720 ..			        DEFB    'REN ' 
d724 ..			        DEFB    'USER' 
d728			; 
d728			;   The following six bytes must agree with those at (PATTRN2) 
d728			; or cp/m will HALT. Why? 
d728			; 
d728 00 16 00 00 00 00	PATTRN1:DEFB    0,22,0,0,0,0    ;(* serial number bytes *). 
d72e			; 
d72e			;   Search the command table for a match with what has just 
d72e			; been entered. If a match is found, then we jump to the 
d72e			; proper section. Else jump to (UNKNOWN). 
d72e			; On return, the (C) register is set to the command number 
d72e			; that matched (or NUMCMDS+1 if no match). 
d72e			; 
d72e 21 10 d7		SEARCH: LD      HL,CMDTBL 
d731 0e 00		        LD      C,0 
d733 79			SEARCH1:LD      A,C 
d734 fe 06		        CP      NUMCMDS         ;this commands exists. 
d736 d0			        RET     NC 
d737 11 ce db		        LD      DE,FCB+1        ;check this one. 
d73a 06 04		        LD      B,4             ;max command length. 
d73c 1a			SEARCH2:LD      A,(DE) 
d73d be			        CP      (HL) 
d73e c2 4f d7		        JP      NZ,SEARCH3      ;not a match. 
d741 13			        INC     DE 
d742 23			        INC     HL 
d743 05			        DEC     B 
d744 c2 3c d7		        JP      NZ,SEARCH2 
d747 1a			        LD      A,(DE)          ;allow a 3 character command to match. 
d748 fe 20		        CP      ' ' 
d74a c2 54 d7		        JP      NZ,SEARCH4 
d74d 79			        LD      A,C             ;set return register for this command. 
d74e c9			        RET      
d74f 23			SEARCH3:INC     HL 
d750 05			        DEC     B 
d751 c2 4f d7		        JP      NZ,SEARCH3 
d754 0c			SEARCH4:INC     C 
d755 c3 33 d7		        JP      SEARCH1 
d758			; 
d758			;   Set the input buffer to empty and then start the command 
d758			; processor (ccp). 
d758			; 
d758 af			CLEARBUF: XOR   A 
d759 32 07 d4		        LD      (INBUFF+1),A    ;second byte is actual length. 
d75c			; 
d75c			;************************************************************** 
d75c			;* 
d75c			;* 
d75c			;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r 
d75c			;* 
d75c			;************************************************************** 
d75c			;* 
d75c 31 ab db		COMMAND:LD      SP,CCPSTACK     ;setup stack area. 
d75f c5			        PUSH    BC              ;note that (C) should be equal to: 
d760 79			        LD      A,C             ;(uuuudddd) where 'uuuu' is the user number 
d761 1f			        RRA                     ;and 'dddd' is the drive number. 
d762 1f			        RRA      
d763 1f			        RRA      
d764 1f			        RRA      
d765 e6 0f		        AND     0FH             ;isolate the user number. 
d767 5f			        LD      E,A 
d768 cd 15 d5		        CALL    GETSETUC        ;and set it. 
d76b cd b8 d4		        CALL    RESDSK          ;reset the disk system. 
d76e 32 ab db		        LD      (BATCH),A       ;clear batch mode flag. 
d771 c1			        POP     BC 
d772 79			        LD      A,C 
d773 e6 0f		        AND     0FH             ;isolate the drive number. 
d775 32 ef db		        LD      (CDRIVE),A      ;and save. 
d778 cd bd d4		        CALL    DSKSEL          ;...and select. 
d77b 3a 07 d4		        LD      A,(INBUFF+1) 
d77e b7			        OR      A               ;anything in input buffer already? 
d77f c2 98 d7		        JP      NZ,CMMND2       ;yes, we just process it. 
d782			; 
d782			;   Entry point to get a command line from the console. 
d782			; 
d782 31 ab db		CMMND1: LD      SP,CCPSTACK     ;set stack straight. 
d785 cd 98 d4		        CALL    CRLF            ;start a new line on the screen. 
d788 cd d0 d5		        CALL    GETDSK          ;get current drive. 
d78b c6 61		        ADD     A,'a' 
d78d cd 8c d4		        CALL    PRINT           ;print current drive. 
d790 3e 3e		        LD      A,'>' 
d792 cd 8c d4		        CALL    PRINT           ;and add prompt. 
d795 cd 39 d5		        CALL    GETINP          ;get line from user. 
d798			; 
d798			;   Process command line here. 
d798			; 
d798 11 80 00		CMMND2: LD      DE,TBUFF 
d79b cd d8 d5		        CALL    DMASET          ;set standard dma address. 
d79e cd d0 d5		        CALL    GETDSK 
d7a1 32 ef db		        LD      (CDRIVE),A      ;set current drive. 
d7a4 cd 5e d6		        CALL    CONVFST         ;convert name typed in. 
d7a7 c4 09 d6		        CALL    NZ,SYNERR       ;wild cards are not allowed. 
d7aa 3a f0 db		        LD      A,(CHGDRV)      ;if a change in drives was indicated, 
d7ad b7			        OR      A               ;then treat this as an unknown command 
d7ae c2 a5 da		        JP      NZ,UNKNOWN      ;which gets executed. 
d7b1 cd 2e d7		        CALL    SEARCH          ;else search command table for a match. 
d7b4			; 
d7b4			;   Note that an unknown command returns 
d7b4			; with (A) pointing to the last address 
d7b4			; in our table which is (UNKNOWN). 
d7b4			; 
d7b4 21 c1 d7		        LD      HL,CMDADR       ;now, look thru our address table for command (A). 
d7b7 5f			        LD      E,A             ;set (DE) to command number. 
d7b8 16 00		        LD      D,0 
d7ba 19			        ADD     HL,DE 
d7bb 19			        ADD     HL,DE           ;(HL)=(CMDADR)+2*(command number). 
d7bc 7e			        LD      A,(HL)          ;now pick out this address. 
d7bd 23			        INC     HL 
d7be 66			        LD      H,(HL) 
d7bf 6f			        LD      L,A 
d7c0 e9			        JP      (HL)            ;now execute it. 
d7c1			; 
d7c1			;   CP/M command address table. 
d7c1			; 
d7c1 77 d8 1f d9 5d d9 ad d9	CMDADR: DEFW    DIRECT,ERASE,TYPE,SAVE 
d7c9 10 da 8e da a5 da	        DEFW    RENAME,USER,UNKNOWN 
d7cf			; 
d7cf			;   Halt the system. Reason for this is unknown at present. 
d7cf			; 
d7cf 21 f3 76		HALT:   LD      HL,76F3H        ;'DI HLT' instructions. 
d7d2 22 00 d4		        LD      (CBASE),HL 
d7d5 21 00 d4		        LD      HL,CBASE 
d7d8 e9			        JP      (HL) 
d7d9			; 
d7d9			;   Read error while TYPEing a file. 
d7d9			; 
d7d9 01 df d7		RDERROR:LD      BC,RDERR 
d7dc c3 a7 d4		        JP      PLINE 
d7df .. 00		RDERR:  DEFB    'Read error',0 
d7ea			; 
d7ea			;   Required file was not located. 
d7ea			; 
d7ea 01 f0 d7		NONE:   LD      BC,NOFILE 
d7ed c3 a7 d4		        JP      PLINE 
d7f0 .. 00		NOFILE: DEFB    'No file',0 
d7f8			; 
d7f8			;   Decode a command of the form 'A>filename number{ filename}. 
d7f8			; Note that a drive specifier is not allowed on the first file 
d7f8			; name. On return, the number is in register (A). Any error 
d7f8			; causes 'filename?' to be printed and the command is aborted. 
d7f8			; 
d7f8 cd 5e d6		DECODE: CALL    CONVFST         ;convert filename. 
d7fb 3a f0 db		        LD      A,(CHGDRV)      ;do not allow a drive to be specified. 
d7fe b7			        OR      A 
d7ff c2 09 d6		        JP      NZ,SYNERR 
d802 21 ce db		        LD      HL,FCB+1        ;convert number now. 
d805 01 0b 00		        LD      BC,11           ;(B)=sum register, (C)=max digit count. 
d808 7e			DECODE1:LD      A,(HL) 
d809 fe 20		        CP      ' '             ;a space terminates the numeral. 
d80b ca 33 d8		        JP      Z,DECODE3 
d80e 23			        INC     HL 
d80f d6 30		        SUB     '0'             ;make binary from ascii. 
d811 fe 0a		        CP      10              ;legal digit? 
d813 d2 09 d6		        JP      NC,SYNERR 
d816 57			        LD      D,A             ;yes, save it in (D). 
d817 78			        LD      A,B             ;compute (B)=(B)*10 and check for overflow. 
d818 e6 e0		        AND     0E0H 
d81a c2 09 d6		        JP      NZ,SYNERR 
d81d 78			        LD      A,B 
d81e 07			        RLCA     
d81f 07			        RLCA     
d820 07			        RLCA                    ;(A)=(B)*8 
d821 80			        ADD     A,B             ;.......*9 
d822 da 09 d6		        JP      C,SYNERR 
d825 80			        ADD     A,B             ;.......*10 
d826 da 09 d6		        JP      C,SYNERR 
d829 82			        ADD     A,D             ;add in new digit now. 
d82a da 09 d6		DECODE2:JP      C,SYNERR 
d82d 47			        LD      B,A             ;and save result. 
d82e 0d			        DEC     C               ;only look at 11 digits. 
d82f c2 08 d8		        JP      NZ,DECODE1 
d832 c9			        RET      
d833 7e			DECODE3:LD      A,(HL)          ;spaces must follow (why?). 
d834 fe 20		        CP      ' ' 
d836 c2 09 d6		        JP      NZ,SYNERR 
d839 23			        INC     HL 
d83a 0d			DECODE4:DEC     C 
d83b c2 33 d8		        JP      NZ,DECODE3 
d83e 78			        LD      A,B             ;set (A)=the numeric value entered. 
d83f c9			        RET      
d840			; 
d840			;   Move 3 bytes from (HL) to (DE). Note that there is only 
d840			; one reference to this at (A2D5h). 
d840			; 
d840 06 03		MOVE3:  LD      B,3 
d842			; 
d842			;   Move (B) bytes from (HL) to (DE). 
d842			; 
d842 7e			HL2DE:  LD      A,(HL) 
d843 12			        LD      (DE),A 
d844 23			        INC     HL 
d845 13			        INC     DE 
d846 05			        DEC     B 
d847 c2 42 d8		        JP      NZ,HL2DE 
d84a c9			        RET      
d84b			; 
d84b			;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here. 
d84b			; 
d84b 21 80 00		EXTRACT:LD      HL,TBUFF 
d84e 81			        ADD     A,C 
d84f cd 59 d6		        CALL    ADDHL 
d852 7e			        LD      A,(HL) 
d853 c9			        RET      
d854			; 
d854			;  Check drive specified. If it means a change, then the new 
d854			; drive will be selected. In any case, the drive byte of the 
d854			; fcb will be set to null (means use current drive). 
d854			; 
d854 af			DSELECT:XOR     A               ;null out first byte of fcb. 
d855 32 cd db		        LD      (FCB),A 
d858 3a f0 db		        LD      A,(CHGDRV)      ;a drive change indicated? 
d85b b7			        OR      A 
d85c c8			        RET     Z 
d85d 3d			        DEC     A               ;yes, is it the same as the current drive? 
d85e 21 ef db		        LD      HL,CDRIVE 
d861 be			        CP      (HL) 
d862 c8			        RET     Z 
d863 c3 bd d4		        JP      DSKSEL          ;no. Select it then. 
d866			; 
d866			;   Check the drive selection and reset it to the previous 
d866			; drive if it was changed for the preceeding command. 
d866			; 
d866 3a f0 db		RESETDR:LD      A,(CHGDRV)      ;drive change indicated? 
d869 b7			        OR      A 
d86a c8			        RET     Z 
d86b 3d			        DEC     A               ;yes, was it a different drive? 
d86c 21 ef db		        LD      HL,CDRIVE 
d86f be			        CP      (HL) 
d870 c8			        RET     Z 
d871 3a ef db		        LD      A,(CDRIVE)      ;yes, re-select our old drive. 
d874 c3 bd d4		        JP      DSKSEL 
d877			; 
d877			;************************************************************** 
d877			;* 
d877			;*           D I R E C T O R Y   C O M M A N D 
d877			;* 
d877			;************************************************************** 
d877			; 
d877 cd 5e d6		DIRECT: CALL    CONVFST         ;convert file name. 
d87a cd 54 d8		        CALL    DSELECT         ;select indicated drive. 
d87d 21 ce db		        LD      HL,FCB+1        ;was any file indicated? 
d880 7e			        LD      A,(HL) 
d881 fe 20		        CP      ' ' 
d883 c2 8f d8		        JP      NZ,DIRECT2 
d886 06 0b		        LD      B,11            ;no. Fill field with '?' - same as *.*. 
d888 36 3f		DIRECT1:LD      (HL),'?' 
d88a 23			        INC     HL 
d88b 05			        DEC     B 
d88c c2 88 d8		        JP      NZ,DIRECT1 
d88f 1e 00		DIRECT2:LD      E,0             ;set initial cursor position. 
d891 d5			        PUSH    DE 
d892 cd e9 d4		        CALL    SRCHFCB         ;get first file name. 
d895 cc ea d7		        CALL    Z,NONE          ;none found at all? 
d898 ca 1b d9		DIRECT3:JP      Z,DIRECT9       ;terminate if no more names. 
d89b 3a ee db		        LD      A,(RTNCODE)     ;get file's position in segment (0-3). 
d89e 0f			        RRCA     
d89f 0f			        RRCA     
d8a0 0f			        RRCA     
d8a1 e6 60		        AND     60H             ;(A)=position*32 
d8a3 4f			        LD      C,A 
d8a4 3e 0a		        LD      A,10 
d8a6 cd 4b d8		        CALL    EXTRACT         ;extract the tenth entry in fcb. 
d8a9 17			        RLA                     ;check system file status bit. 
d8aa da 0f d9		        JP      C,DIRECT8       ;we don't list them. 
d8ad d1			        POP     DE 
d8ae 7b			        LD      A,E             ;bump name count. 
d8af 1c			        INC     E 
d8b0 d5			        PUSH    DE 
d8b1 e6 03		        AND     03H             ;at end of line? 
d8b3 f5			        PUSH    AF 
d8b4 c2 cc d8		        JP      NZ,DIRECT4 
d8b7 cd 98 d4		        CALL    CRLF            ;yes, end this line and start another. 
d8ba c5			        PUSH    BC 
d8bb cd d0 d5		        CALL    GETDSK          ;start line with ('A:'). 
d8be c1			        POP     BC 
d8bf c6 41		        ADD     A,'A' 
d8c1 cd 92 d4		        CALL    PRINTB 
d8c4 3e 3a		        LD      A,':' 
d8c6 cd 92 d4		        CALL    PRINTB 
d8c9 c3 d4 d8		        JP      DIRECT5 
d8cc cd a2 d4		DIRECT4:CALL    SPACE           ;add seperator between file names. 
d8cf 3e 3a		        LD      A,':' 
d8d1 cd 92 d4		        CALL    PRINTB 
d8d4 cd a2 d4		DIRECT5:CALL    SPACE 
d8d7 06 01		        LD      B,1             ;'extract' each file name character at a time. 
d8d9 78			DIRECT6:LD      A,B 
d8da cd 4b d8		        CALL    EXTRACT 
d8dd e6 7f		        AND     7FH             ;strip bit 7 (status bit). 
d8df fe 20		        CP      ' '             ;are we at the end of the name? 
d8e1 c2 f9 d8		        JP      NZ,DRECT65 
d8e4 f1			        POP     AF              ;yes, don't print spaces at the end of a line. 
d8e5 f5			        PUSH    AF 
d8e6 fe 03		        CP      3 
d8e8 c2 f7 d8		        JP      NZ,DRECT63 
d8eb 3e 09		        LD      A,9             ;first check for no extension. 
d8ed cd 4b d8		        CALL    EXTRACT 
d8f0 e6 7f		        AND     7FH 
d8f2 fe 20		        CP      ' ' 
d8f4 ca 0e d9		        JP      Z,DIRECT7       ;don't print spaces. 
d8f7 3e 20		DRECT63:LD      A,' '           ;else print them. 
d8f9 cd 92 d4		DRECT65:CALL    PRINTB 
d8fc 04			        INC     B               ;bump to next character psoition. 
d8fd 78			        LD      A,B 
d8fe fe 0c		        CP      12              ;end of the name? 
d900 d2 0e d9		        JP      NC,DIRECT7 
d903 fe 09		        CP      9               ;nope, starting extension? 
d905 c2 d9 d8		        JP      NZ,DIRECT6 
d908 cd a2 d4		        CALL    SPACE           ;yes, add seperating space. 
d90b c3 d9 d8		        JP      DIRECT6 
d90e f1			DIRECT7:POP     AF              ;get the next file name. 
d90f cd c2 d5		DIRECT8:CALL    CHKCON          ;first check console, quit on anything. 
d912 c2 1b d9		        JP      NZ,DIRECT9 
d915 cd e4 d4		        CALL    SRCHNXT         ;get next name. 
d918 c3 98 d8		        JP      DIRECT3         ;and continue with our list. 
d91b d1			DIRECT9:POP     DE              ;restore the stack and return to command level. 
d91c c3 86 db		        JP      GETBACK 
d91f			; 
d91f			;************************************************************** 
d91f			;* 
d91f			;*                E R A S E   C O M M A N D 
d91f			;* 
d91f			;************************************************************** 
d91f			; 
d91f cd 5e d6		ERASE:  CALL    CONVFST         ;convert file name. 
d922 fe 0b		        CP      11              ;was '*.*' entered? 
d924 c2 42 d9		        JP      NZ,ERASE1 
d927 01 52 d9		        LD      BC,YESNO        ;yes, ask for confirmation. 
d92a cd a7 d4		        CALL    PLINE 
d92d cd 39 d5		        CALL    GETINP 
d930 21 07 d4		        LD      HL,INBUFF+1 
d933 35			        DEC     (HL)            ;must be exactly 'y'. 
d934 c2 82 d7		        JP      NZ,CMMND1 
d937 23			        INC     HL 
d938 7e			        LD      A,(HL) 
d939 fe 59		        CP      'Y' 
d93b c2 82 d7		        JP      NZ,CMMND1 
d93e 23			        INC     HL 
d93f 22 88 d4		        LD      (INPOINT),HL    ;save input line pointer. 
d942 cd 54 d8		ERASE1: CALL    DSELECT         ;select desired disk. 
d945 11 cd db		        LD      DE,FCB 
d948 cd ef d4		        CALL    DELETE          ;delete the file. 
d94b 3c			        INC     A 
d94c cc ea d7		        CALL    Z,NONE          ;not there? 
d94f c3 86 db		        JP      GETBACK         ;return to command level now. 
d952 .. 00		YESNO:  DEFB    'All (y/n)?',0 
d95d			; 
d95d			;************************************************************** 
d95d			;* 
d95d			;*            T Y P E   C O M M A N D 
d95d			;* 
d95d			;************************************************************** 
d95d			; 
d95d cd 5e d6		TYPE:   CALL    CONVFST         ;convert file name. 
d960 c2 09 d6		        JP      NZ,SYNERR       ;wild cards not allowed. 
d963 cd 54 d8		        CALL    DSELECT         ;select indicated drive. 
d966 cd d0 d4		        CALL    OPENFCB         ;open the file. 
d969 ca a7 d9		        JP      Z,TYPE5         ;not there? 
d96c cd 98 d4		        CALL    CRLF            ;ok, start a new line on the screen. 
d96f 21 f1 db		        LD      HL,NBYTES       ;initialize byte counter. 
d972 36 ff		        LD      (HL),0FFH       ;set to read first sector. 
d974 21 f1 db		TYPE1:  LD      HL,NBYTES 
d977 7e			TYPE2:  LD      A,(HL)          ;have we written the entire sector? 
d978 fe 80		        CP      128 
d97a da 87 d9		        JP      C,TYPE3 
d97d e5			        PUSH    HL              ;yes, read in the next one. 
d97e cd fe d4		        CALL    READFCB 
d981 e1			        POP     HL 
d982 c2 a0 d9		        JP      NZ,TYPE4        ;end or error? 
d985 af			        XOR     A               ;ok, clear byte counter. 
d986 77			        LD      (HL),A 
d987 34			TYPE3:  INC     (HL)            ;count this byte. 
d988 21 80 00		        LD      HL,TBUFF        ;and get the (A)th one from the buffer (TBUFF). 
d98b cd 59 d6		        CALL    ADDHL 
d98e 7e			        LD      A,(HL) 
d98f fe 1a		        CP      CNTRLZ          ;end of file mark? 
d991 ca 86 db		        JP      Z,GETBACK 
d994 cd 8c d4		        CALL    PRINT           ;no, print it. 
d997 cd c2 d5		        CALL    CHKCON          ;check console, quit if anything ready. 
d99a c2 86 db		        JP      NZ,GETBACK 
d99d c3 74 d9		        JP      TYPE1 
d9a0			; 
d9a0			;   Get here on an end of file or read error. 
d9a0			; 
d9a0 3d			TYPE4:  DEC     A               ;read error? 
d9a1 ca 86 db		        JP      Z,GETBACK 
d9a4 cd d9 d7		        CALL    RDERROR         ;yes, print message. 
d9a7 cd 66 d8		TYPE5:  CALL    RESETDR         ;and reset proper drive 
d9aa c3 09 d6		        JP      SYNERR          ;now print file name with problem. 
d9ad			; 
d9ad			;************************************************************** 
d9ad			;* 
d9ad			;*            S A V E   C O M M A N D 
d9ad			;* 
d9ad			;************************************************************** 
d9ad			; 
d9ad cd f8 d7		SAVE:   CALL    DECODE          ;get numeric number that follows SAVE. 
d9b0 f5			        PUSH    AF              ;save number of pages to write. 
d9b1 cd 5e d6		        CALL    CONVFST         ;convert file name. 
d9b4 c2 09 d6		        JP      NZ,SYNERR       ;wild cards not allowed. 
d9b7 cd 54 d8		        CALL    DSELECT         ;select specified drive. 
d9ba 11 cd db		        LD      DE,FCB          ;now delete this file. 
d9bd d5			        PUSH    DE 
d9be cd ef d4		        CALL    DELETE 
d9c1 d1			        POP     DE 
d9c2 cd 09 d5		        CALL    CREATE          ;and create it again. 
d9c5 ca fb d9		        JP      Z,SAVE3         ;can't create? 
d9c8 af			        XOR     A               ;clear record number byte. 
d9c9 32 ed db		        LD      (FCB+32),A 
d9cc f1			        POP     AF              ;convert pages to sectors. 
d9cd 6f			        LD      L,A 
d9ce 26 00		        LD      H,0 
d9d0 29			        ADD     HL,HL           ;(HL)=number of sectors to write. 
d9d1 11 00 01		        LD      DE,TBASE        ;and we start from here. 
d9d4 7c			SAVE1:  LD      A,H             ;done yet? 
d9d5 b5			        OR      L 
d9d6 ca f1 d9		        JP      Z,SAVE2 
d9d9 2b			        DEC     HL              ;nope, count this and compute the start 
d9da e5			        PUSH    HL              ;of the next 128 byte sector. 
d9db 21 80 00		        LD      HL,128 
d9de 19			        ADD     HL,DE 
d9df e5			        PUSH    HL              ;save it and set the transfer address. 
d9e0 cd d8 d5		        CALL    DMASET 
d9e3 11 cd db		        LD      DE,FCB          ;write out this sector now. 
d9e6 cd 04 d5		        CALL    WRTREC 
d9e9 d1			        POP     DE              ;reset (DE) to the start of the last sector. 
d9ea e1			        POP     HL              ;restore sector count. 
d9eb c2 fb d9		        JP      NZ,SAVE3        ;write error? 
d9ee c3 d4 d9		        JP      SAVE1 
d9f1			; 
d9f1			;   Get here after writing all of the file. 
d9f1			; 
d9f1 11 cd db		SAVE2:  LD      DE,FCB          ;now close the file. 
d9f4 cd da d4		        CALL    CLOSE 
d9f7 3c			        INC     A               ;did it close ok? 
d9f8 c2 01 da		        JP      NZ,SAVE4 
d9fb			; 
d9fb			;   Print out error message (no space). 
d9fb			; 
d9fb 01 07 da		SAVE3:  LD      BC,NOSPACE 
d9fe cd a7 d4		        CALL    PLINE 
da01 cd d5 d5		SAVE4:  CALL    STDDMA          ;reset the standard dma address. 
da04 c3 86 db		        JP      GETBACK 
da07 .. 00		NOSPACE:DEFB    'No space',0 
da10			; 
da10			;************************************************************** 
da10			;* 
da10			;*           R E N A M E   C O M M A N D 
da10			;* 
da10			;************************************************************** 
da10			; 
da10 cd 5e d6		RENAME: CALL    CONVFST         ;convert first file name. 
da13 c2 09 d6		        JP      NZ,SYNERR       ;wild cards not allowed. 
da16 3a f0 db		        LD      A,(CHGDRV)      ;remember any change in drives specified. 
da19 f5			        PUSH    AF 
da1a cd 54 d8		        CALL    DSELECT         ;and select this drive. 
da1d cd e9 d4		        CALL    SRCHFCB         ;is this file present? 
da20 c2 79 da		        JP      NZ,RENAME6      ;yes, print error message. 
da23 21 cd db		        LD      HL,FCB          ;yes, move this name into second slot. 
da26 11 dd db		        LD      DE,FCB+16 
da29 06 10		        LD      B,16 
da2b cd 42 d8		        CALL    HL2DE 
da2e 2a 88 d4		        LD      HL,(INPOINT)    ;get input pointer. 
da31 eb			        EX      DE,HL 
da32 cd 4f d6		        CALL    NONBLANK        ;get next non blank character. 
da35 fe 3d		        CP      '='             ;only allow an '=' or '_' seperator. 
da37 ca 3f da		        JP      Z,RENAME1 
da3a fe 5f		        CP      '_' 
da3c c2 73 da		        JP      NZ,RENAME5 
da3f eb			RENAME1:EX      DE,HL 
da40 23			        INC     HL              ;ok, skip seperator. 
da41 22 88 d4		        LD      (INPOINT),HL    ;save input line pointer. 
da44 cd 5e d6		        CALL    CONVFST         ;convert this second file name now. 
da47 c2 73 da		        JP      NZ,RENAME5      ;again, no wild cards. 
da4a f1			        POP     AF              ;if a drive was specified, then it 
da4b 47			        LD      B,A             ;must be the same as before. 
da4c 21 f0 db		        LD      HL,CHGDRV 
da4f 7e			        LD      A,(HL) 
da50 b7			        OR      A 
da51 ca 59 da		        JP      Z,RENAME2 
da54 b8			        CP      B 
da55 70			        LD      (HL),B 
da56 c2 73 da		        JP      NZ,RENAME5      ;they were different, error. 
da59 70			RENAME2:LD      (HL),B          ;       reset as per the first file specification. 
da5a af			        XOR     A 
da5b 32 cd db		        LD      (FCB),A         ;clear the drive byte of the fcb. 
da5e cd e9 d4		RENAME3:CALL    SRCHFCB         ;and go look for second file. 
da61 ca 6d da		        JP      Z,RENAME4       ;doesn't exist? 
da64 11 cd db		        LD      DE,FCB 
da67 cd 0e d5		        CALL    RENAM           ;ok, rename the file. 
da6a c3 86 db		        JP      GETBACK 
da6d			; 
da6d			;   Process rename errors here. 
da6d			; 
da6d cd ea d7		RENAME4:CALL    NONE            ;file not there. 
da70 c3 86 db		        JP      GETBACK 
da73 cd 66 d8		RENAME5:CALL    RESETDR         ;bad command format. 
da76 c3 09 d6		        JP      SYNERR 
da79 01 82 da		RENAME6:LD      BC,EXISTS       ;destination file already exists. 
da7c cd a7 d4		        CALL    PLINE 
da7f c3 86 db		        JP      GETBACK 
da82 .. 00		EXISTS: DEFB    'File exists',0 
da8e			; 
da8e			;************************************************************** 
da8e			;* 
da8e			;*             U S E R   C O M M A N D 
da8e			;* 
da8e			;************************************************************** 
da8e			; 
da8e cd f8 d7		USER:   CALL    DECODE          ;get numeric value following command. 
da91 fe 10		        CP      16              ;legal user number? 
da93 d2 09 d6		        JP      NC,SYNERR 
da96 5f			        LD      E,A             ;yes but is there anything else? 
da97 3a ce db		        LD      A,(FCB+1) 
da9a fe 20		        CP      ' ' 
da9c ca 09 d6		        JP      Z,SYNERR        ;yes, that is not allowed. 
da9f cd 15 d5		        CALL    GETSETUC        ;ok, set user code. 
daa2 c3 89 db		        JP      GETBACK1 
daa5			; 
daa5			;************************************************************** 
daa5			;* 
daa5			;*        T R A N S I A N T   P R O G R A M   C O M M A N D 
daa5			;* 
daa5			;************************************************************** 
daa5			; 
daa5 cd f5 d5		UNKNOWN:CALL    VERIFY          ;check for valid system (why?). 
daa8 3a ce db		        LD      A,(FCB+1)       ;anything to execute? 
daab fe 20		        CP      ' ' 
daad c2 c4 da		        JP      NZ,UNKWN1 
dab0 3a f0 db		        LD      A,(CHGDRV)      ;nope, only a drive change? 
dab3 b7			        OR      A 
dab4 ca 89 db		        JP      Z,GETBACK1      ;neither??? 
dab7 3d			        DEC     A 
dab8 32 ef db		        LD      (CDRIVE),A      ;ok, store new drive. 
dabb cd 29 d5		        CALL    MOVECD          ;set (TDRIVE) also. 
dabe cd bd d4		        CALL    DSKSEL          ;and select this drive. 
dac1 c3 89 db		        JP      GETBACK1        ;then return. 
dac4			; 
dac4			;   Here a file name was typed. Prepare to execute it. 
dac4			; 
dac4 11 d6 db		UNKWN1: LD      DE,FCB+9        ;an extension specified? 
dac7 1a			        LD      A,(DE) 
dac8 fe 20		        CP      ' ' 
daca c2 09 d6		        JP      NZ,SYNERR       ;yes, not allowed. 
dacd d5			UNKWN2: PUSH    DE 
dace cd 54 d8		        CALL    DSELECT         ;select specified drive. 
dad1 d1			        POP     DE 
dad2 21 83 db		        LD      HL,COMFILE      ;set the extension to 'COM'. 
dad5 cd 40 d8		        CALL    MOVE3 
dad8 cd d0 d4		        CALL    OPENFCB         ;and open this file. 
dadb ca 6b db		        JP      Z,UNKWN9        ;not present? 
dade			; 
dade			;   Load in the program. 
dade			; 
dade 21 00 01		        LD      HL,TBASE        ;store the program starting here. 
dae1 e5			UNKWN3: PUSH    HL 
dae2 eb			        EX      DE,HL 
dae3 cd d8 d5		        CALL    DMASET          ;set transfer address. 
dae6 11 cd db		        LD      DE,FCB          ;and read the next record. 
dae9 cd f9 d4		        CALL    RDREC 
daec c2 01 db		        JP      NZ,UNKWN4       ;end of file or read error? 
daef e1			        POP     HL              ;nope, bump pointer for next sector. 
daf0 11 80 00		        LD      DE,128 
daf3 19			        ADD     HL,DE 
daf4 11 00 d4		        LD      DE,CBASE        ;enough room for the whole file? 
daf7 7d			        LD      A,L 
daf8 93			        SUB     E 
daf9 7c			        LD      A,H 
dafa 9a			        SBC     A,D 
dafb d2 71 db		        JP      NC,UNKWN0       ;no, it can't fit. 
dafe c3 e1 da		        JP      UNKWN3 
db01			; 
db01			;   Get here after finished reading. 
db01			; 
db01 e1			UNKWN4: POP     HL 
db02 3d			        DEC     A               ;normal end of file? 
db03 c2 71 db		        JP      NZ,UNKWN0 
db06 cd 66 d8		        CALL    RESETDR         ;yes, reset previous drive. 
db09 cd 5e d6		        CALL    CONVFST         ;convert the first file name that follows 
db0c 21 f0 db		        LD      HL,CHGDRV       ;command name. 
db0f e5			        PUSH    HL 
db10 7e			        LD      A,(HL)          ;set drive code in default fcb. 
db11 32 cd db		        LD      (FCB),A 
db14 3e 10		        LD      A,16            ;put second name 16 bytes later. 
db16 cd 60 d6		        CALL    CONVERT         ;convert second file name. 
db19 e1			        POP     HL 
db1a 7e			        LD      A,(HL)          ;and set the drive for this second file. 
db1b 32 dd db		        LD      (FCB+16),A 
db1e af			        XOR     A               ;clear record byte in fcb. 
db1f 32 ed db		        LD      (FCB+32),A 
db22 11 5c 00		        LD      DE,TFCB         ;move it into place at(005Ch). 
db25 21 cd db		        LD      HL,FCB 
db28 06 21		        LD      B,33 
db2a cd 42 d8		        CALL    HL2DE 
db2d 21 08 d4		        LD      HL,INBUFF+2     ;now move the remainder of the input 
db30 7e			UNKWN5: LD      A,(HL)          ;line down to (0080h). Look for a non blank. 
db31 b7			        OR      A               ;or a null. 
db32 ca 3e db		        JP      Z,UNKWN6 
db35 fe 20		        CP      ' ' 
db37 ca 3e db		        JP      Z,UNKWN6 
db3a 23			        INC     HL 
db3b c3 30 db		        JP      UNKWN5 
db3e			; 
db3e			;   Do the line move now. It ends in a null byte. 
db3e			; 
db3e 06 00		UNKWN6: LD      B,0             ;keep a character count. 
db40 11 81 00		        LD      DE,TBUFF+1      ;data gets put here. 
db43 7e			UNKWN7: LD      A,(HL)          ;move it now. 
db44 12			        LD      (DE),A 
db45 b7			        OR      A 
db46 ca 4f db		        JP      Z,UNKWN8 
db49 04			        INC     B 
db4a 23			        INC     HL 
db4b 13			        INC     DE 
db4c c3 43 db		        JP      UNKWN7 
db4f 78			UNKWN8: LD      A,B             ;now store the character count. 
db50 32 80 00		        LD      (TBUFF),A 
db53 cd 98 d4		        CALL    CRLF            ;clean up the screen. 
db56 cd d5 d5		        CALL    STDDMA          ;set standard transfer address. 
db59 cd 1a d5		        CALL    SETCDRV         ;reset current drive. 
db5c cd 00 01		        CALL    TBASE           ;and execute the program. 
db5f			; 
db5f			;   Transiant programs return here (or reboot). 
db5f			; 
db5f 31 ab db		        LD      SP,BATCH        ;set stack first off. 
db62 cd 29 d5		        CALL    MOVECD          ;move current drive into place (TDRIVE). 
db65 cd bd d4		        CALL    DSKSEL          ;and reselect it. 
db68 c3 82 d7		        JP      CMMND1          ;back to comand mode. 
db6b			; 
db6b			;   Get here if some error occured. 
db6b			; 
db6b cd 66 d8		UNKWN9: CALL    RESETDR         ;inproper format. 
db6e c3 09 d6		        JP      SYNERR 
db71 01 7a db		UNKWN0: LD      BC,BADLOAD      ;read error or won't fit. 
db74 cd a7 d4		        CALL    PLINE 
db77 c3 86 db		        JP      GETBACK 
db7a .. 00		BADLOAD:DEFB    'Bad load',0 
db83 ..			COMFILE:DEFB    'COM'           ;command file extension. 
db86			; 
db86			;   Get here to return to command level. We will reset the 
db86			; previous active drive and then either return to command 
db86			; level directly or print error message and then return. 
db86			; 
db86 cd 66 d8		GETBACK:CALL    RESETDR         ;reset previous drive. 
db89 cd 5e d6		GETBACK1: CALL  CONVFST         ;convert first name in (FCB). 
db8c 3a ce db		        LD      A,(FCB+1)       ;if this was just a drive change request, 
db8f d6 20		        SUB     ' '             ;make sure it was valid. 
db91 21 f0 db		        LD      HL,CHGDRV 
db94 b6			        OR      (HL) 
db95 c2 09 d6		        JP      NZ,SYNERR 
db98 c3 82 d7		        JP      CMMND1          ;ok, return to command level. 
db9b			; 
db9b			;   ccp stack area. 
db9b			; 
db9b 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00	        DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
dbab			CCPSTACK: EQU    $       ;end of ccp stack area. 
dbab			; 
dbab			;   Batch (or SUBMIT) processing information storage. 
dbab			; 
dbab 00			BATCH:  DEFB    0               ;batch mode flag (0=not active). 
dbac 00 .. 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00	BATCHFCB: DEFB  0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
dbcd			; 
dbcd			;   File control block setup by the CCP. 
dbcd			; 
dbcd 00 .. 00 00 00 00 00 .. 00 00 00 00 00	FCB:    DEFB    0,'           ',0,0,0,0,0,'           ',0,0,0,0,0 
dbee 00			RTNCODE:DEFB    0               ;status returned from bdos call. 
dbef 00			CDRIVE: DEFB    0               ;currently active drive. 
dbf0 00			CHGDRV: DEFB    0               ;change in drives flag (0=no change). 
dbf1 00 00		NBYTES: DEFW    0               ;byte counter used by TYPE. 
dbf3			; 
dbf3			;   Room for expansion? 
dbf3			; 
dbf3 00 00 00 00 00 00 00 00 00 00 00 00 00	        DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0 
dc00			; 
dc00			;   Note that the following six bytes must match those at 
dc00			; (PATTRN1) or cp/m will HALT. Why? 
dc00			; 
dc00 00 16 00 00 00 00	PATTRN2:DEFB    0,22,0,0,0,0    ;(* serial number bytes *). 
dc06			; 
dc06			;************************************************************** 
dc06			;* 
dc06			;*                    B D O S   E N T R Y 
dc06			;* 
dc06			;************************************************************** 
dc06			; 
dc06 c3 11 dc		FBASE:  JP      FBASE1 
dc09			; 
dc09			;   Bdos error table. 
dc09			; 
dc09 99 dc		BADSCTR:DEFW    ERROR1          ;bad sector on read or write. 
dc0b a5 dc		BADSLCT:DEFW    ERROR2          ;bad disk select. 
dc0d ab dc		RODISK: DEFW    ERROR3          ;disk is read only. 
dc0f b1 dc		ROFILE: DEFW    ERROR4          ;file is read only. 
dc11			; 
dc11			;   Entry into bdos. (DE) or (E) are the parameters passed. The 
dc11			; function number desired is in register (C). 
dc11			; 
dc11 eb			FBASE1: EX      DE,HL           ;save the (DE) parameters. 
dc12 22 43 df		        LD      (PARAMS),HL 
dc15 eb			        EX      DE,HL 
dc16 7b			        LD      A,E             ;and save register (E) in particular. 
dc17 32 d6 e9		        LD      (EPARAM),A 
dc1a 21 00 00		        LD      HL,0 
dc1d 22 45 df		        LD      (STATUS),HL     ;clear return status. 
dc20 39			        ADD     HL,SP 
dc21 22 0f df		        LD      (USRSTACK),HL   ;save users stack pointer. 
dc24 31 41 df		        LD      SP,STKAREA      ;and set our own. 
dc27 af			        XOR     A               ;clear auto select storage space. 
dc28 32 e0 e9		        LD      (AUTOFLAG),A 
dc2b 32 de e9		        LD      (AUTO),A 
dc2e 21 74 e9		        LD      HL,GOBACK       ;set return address. 
dc31 e5			        PUSH    HL 
dc32 79			        LD      A,C             ;get function number. 
dc33 fe 29		        CP      NFUNCTS         ;valid function number? 
dc35 d0			        RET     NC 
dc36 4b			        LD      C,E             ;keep single register function here. 
dc37 21 47 dc		        LD      HL,FUNCTNS      ;now look thru the function table. 
dc3a 5f			        LD      E,A 
dc3b 16 00		        LD      D,0             ;(DE)=function number. 
dc3d 19			        ADD     HL,DE 
dc3e 19			        ADD     HL,DE           ;(HL)=(start of table)+2*(function number). 
dc3f 5e			        LD      E,(HL) 
dc40 23			        INC     HL 
dc41 56			        LD      D,(HL)          ;now (DE)=address for this function. 
dc42 2a 43 df		        LD      HL,(PARAMS)     ;retrieve parameters. 
dc45 eb			        EX      DE,HL           ;now (DE) has the original parameters. 
dc46 e9			        JP      (HL)            ;execute desired function. 
dc47			; 
dc47			;   BDOS function jump table. 
dc47			; 
dc47			NFUNCTS: EQU     41              ;number of functions in followin table. 
dc47			; 
dc47 03 ea c8 de 90 dd ce de 12 ea 0f ea d4 de ed de	FUNCTNS:DEFW    WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB 
dc57 f3 de f8 de e1 dd fe de 7e e8 83 e8 45 e8 9c e8	        DEFW    SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL 
dc67 a5 e8 ab e8 c8 e8 d7 e8 e0 e8 e6 e8 ec e8	        DEFW    CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE 
dc75 f5 e8 fe e8 04 e9 0a e9 11 e9 2c e1 17 e9 1d e9	        DEFW    RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR 
dc85 26 e9 2d e9 41 e9 47 e9 4d e9 0e e8 53 e9 04 df	        DEFW    GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN 
dc95 04 df 9b e9	        DEFW    RTN,WTSPECL 
dc99			; 
dc99			;   Bdos error message section. 
dc99			; 
dc99 21 ca dc		ERROR1: LD      HL,BADSEC       ;bad sector message. 
dc9c cd e5 dc		        CALL    PRTERR          ;print it and get a 1 char responce. 
dc9f fe 03		        CP      CNTRLC          ;re-boot request (control-c)? 
dca1 ca 00 00		        JP      Z,0             ;yes. 
dca4 c9			        RET                     ;no, return to retry i/o function. 
dca5			; 
dca5 21 d5 dc		ERROR2: LD      HL,BADSEL       ;bad drive selected. 
dca8 c3 b4 dc		        JP      ERROR5 
dcab			; 
dcab 21 e1 dc		ERROR3: LD      HL,DISKRO       ;disk is read only. 
dcae c3 b4 dc		        JP      ERROR5 
dcb1			; 
dcb1 21 dc dc		ERROR4: LD      HL,FILERO       ;file is read only. 
dcb4			; 
dcb4 cd e5 dc		ERROR5: CALL    PRTERR 
dcb7 c3 00 00		        JP      0               ;always reboot on these errors. 
dcba			; 
dcba ..			BDOSERR:DEFB    'Bdos Err On ' 
dcc6 ..			BDOSDRV:DEFB    ' : $' 
dcca ..			BADSEC: DEFB    'Bad Sector$' 
dcd5 ..			BADSEL: DEFB    'Select$' 
dcdc ..			FILERO: DEFB    'File ' 
dce1 ..			DISKRO: DEFB    'R/O$' 
dce5			; 
dce5			;   Print bdos error message. 
dce5			; 
dce5 e5			PRTERR: PUSH    HL              ;save second message pointer. 
dce6 cd c9 dd		        CALL    OUTCRLF         ;send (cr)(lf). 
dce9 3a 42 df		        LD      A,(ACTIVE)      ;get active drive. 
dcec c6 41		        ADD     A,'A'           ;make ascii. 
dcee 32 c6 dc		        LD      (BDOSDRV),A     ;and put in message. 
dcf1 01 ba dc		        LD      BC,BDOSERR      ;and print it. 
dcf4 cd d3 dd		        CALL    PRTMESG 
dcf7 c1			        POP     BC              ;print second message line now. 
dcf8 cd d3 dd		        CALL    PRTMESG 
dcfb			; 
dcfb			;   Get an input character. We will check our 1 character 
dcfb			; buffer first. This may be set by the console status routine. 
dcfb			; 
dcfb 21 0e df		GETCHAR:LD      HL,CHARBUF      ;check character buffer. 
dcfe 7e			        LD      A,(HL)          ;anything present already? 
dcff 36 00		        LD      (HL),0          ;...either case clear it. 
dd01 b7			        OR      A 
dd02 c0			        RET     NZ              ;yes, use it. 
dd03 c3 09 ea		        JP      CONIN           ;nope, go get a character responce. 
dd06			; 
dd06			;   Input and echo a character. 
dd06			; 
dd06 cd fb dc		GETECHO:CALL    GETCHAR         ;input a character. 
dd09 cd 14 dd		        CALL    CHKCHAR         ;carriage control? 
dd0c d8			        RET     C               ;no, a regular control char so don't echo. 
dd0d f5			        PUSH    AF              ;ok, save character now. 
dd0e 4f			        LD      C,A 
dd0f cd 90 dd		        CALL    OUTCON          ;and echo it. 
dd12 f1			        POP     AF              ;get character and return. 
dd13 c9			        RET      
dd14			; 
dd14			;   Check character in (A). Set the zero flag on a carriage 
dd14			; control character and the carry flag on any other control 
dd14			; character. 
dd14			; 
dd14 fe 0d		CHKCHAR:CP      CR              ;check for carriage return, line feed, backspace, 
dd16 c8			        RET     Z               ;or a tab. 
dd17 fe 0a		        CP      LF 
dd19 c8			        RET     Z 
dd1a fe 09		        CP      TAB 
dd1c c8			        RET     Z 
dd1d fe 08		        CP      BS 
dd1f c8			        RET     Z 
dd20 fe 20		        CP      ' '             ;other control char? Set carry flag. 
dd22 c9			        RET      
dd23			; 
dd23			;   Check the console during output. Halt on a control-s, then 
dd23			; reboot on a control-c. If anything else is ready, clear the 
dd23			; zero flag and return (the calling routine may want to do 
dd23			; something). 
dd23			; 
dd23 3a 0e df		CKCONSOL: LD    A,(CHARBUF)     ;check buffer. 
dd26 b7			        OR      A               ;if anything, just return without checking. 
dd27 c2 45 dd		        JP      NZ,CKCON2 
dd2a cd 06 ea		        CALL    CONST           ;nothing in buffer. Check console. 
dd2d e6 01		        AND     01H             ;look at bit 0. 
dd2f c8			        RET     Z               ;return if nothing. 
dd30 cd 09 ea		        CALL    CONIN           ;ok, get it. 
dd33 fe 13		        CP      CNTRLS          ;if not control-s, return with zero cleared. 
dd35 c2 42 dd		        JP      NZ,CKCON1 
dd38 cd 09 ea		        CALL    CONIN           ;halt processing until another char 
dd3b fe 03		        CP      CNTRLC          ;is typed. Control-c? 
dd3d ca 00 00		        JP      Z,0             ;yes, reboot now. 
dd40 af			        XOR     A               ;no, just pretend nothing was ever ready. 
dd41 c9			        RET      
dd42 32 0e df		CKCON1: LD      (CHARBUF),A     ;save character in buffer for later processing. 
dd45 3e 01		CKCON2: LD      A,1             ;set (A) to non zero to mean something is ready. 
dd47 c9			        RET      
dd48			; 
dd48			;   Output (C) to the screen. If the printer flip-flop flag 
dd48			; is set, we will send character to printer also. The console 
dd48			; will be checked in the process. 
dd48			; 
dd48 3a 0a df		OUTCHAR:LD      A,(OUTFLAG)     ;check output flag. 
dd4b b7			        OR      A               ;anything and we won't generate output. 
dd4c c2 62 dd		        JP      NZ,OUTCHR1 
dd4f c5			        PUSH    BC 
dd50 cd 23 dd		        CALL    CKCONSOL        ;check console (we don't care whats there). 
dd53 c1			        POP     BC 
dd54 c5			        PUSH    BC 
dd55 cd 0c ea		        CALL    CONOUT          ;output (C) to the screen. 
dd58 c1			        POP     BC 
dd59 c5			        PUSH    BC 
dd5a 3a 0d df		        LD      A,(PRTFLAG)     ;check printer flip-flop flag. 
dd5d b7			        OR      A 
dd5e c4 0f ea		        CALL    NZ,LIST         ;print it also if non-zero. 
dd61 c1			        POP     BC 
dd62 79			OUTCHR1:LD      A,C             ;update cursors position. 
dd63 21 0c df		        LD      HL,CURPOS 
dd66 fe 7f		        CP      DEL             ;rubouts don't do anything here. 
dd68 c8			        RET     Z 
dd69 34			        INC     (HL)            ;bump line pointer. 
dd6a fe 20		        CP      ' '             ;and return if a normal character. 
dd6c d0			        RET     NC 
dd6d 35			        DEC     (HL)            ;restore and check for the start of the line. 
dd6e 7e			        LD      A,(HL) 
dd6f b7			        OR      A 
dd70 c8			        RET     Z               ;ingnore control characters at the start of the line. 
dd71 79			        LD      A,C 
dd72 fe 08		        CP      BS              ;is it a backspace? 
dd74 c2 79 dd		        JP      NZ,OUTCHR2 
dd77 35			        DEC     (HL)            ;yes, backup pointer. 
dd78 c9			        RET      
dd79 fe 0a		OUTCHR2:CP      LF              ;is it a line feed? 
dd7b c0			        RET     NZ              ;ignore anything else. 
dd7c 36 00		        LD      (HL),0          ;reset pointer to start of line. 
dd7e c9			        RET      
dd7f			; 
dd7f			;   Output (A) to the screen. If it is a control character 
dd7f			; (other than carriage control), use ^x format. 
dd7f			; 
dd7f 79			SHOWIT: LD      A,C 
dd80 cd 14 dd		        CALL    CHKCHAR         ;check character. 
dd83 d2 90 dd		        JP      NC,OUTCON       ;not a control, use normal output. 
dd86 f5			        PUSH    AF 
dd87 0e 5e		        LD      C,'^'           ;for a control character, preceed it with '^'. 
dd89 cd 48 dd		        CALL    OUTCHAR 
dd8c f1			        POP     AF 
dd8d f6 40		        OR      '@'             ;and then use the letter equivelant. 
dd8f 4f			        LD      C,A 
dd90			; 
dd90			;   Function to output (C) to the console device and expand tabs 
dd90			; if necessary. 
dd90			; 
dd90 79			OUTCON: LD      A,C 
dd91 fe 09		        CP      TAB             ;is it a tab? 
dd93 c2 48 dd		        JP      NZ,OUTCHAR      ;use regular output. 
dd96 0e 20		OUTCON1:LD      C,' '           ;yes it is, use spaces instead. 
dd98 cd 48 dd		        CALL    OUTCHAR 
dd9b 3a 0c df		        LD      A,(CURPOS)      ;go until the cursor is at a multiple of 8 
dd9e			 
dd9e e6 07		        AND     07H             ;position. 
dda0 c2 96 dd		        JP      NZ,OUTCON1 
dda3 c9			        RET      
dda4			; 
dda4			;   Echo a backspace character. Erase the prevoius character 
dda4			; on the screen. 
dda4			; 
dda4 cd ac dd		BACKUP: CALL    BACKUP1         ;backup the screen 1 place. 
dda7 0e 20		        LD      C,' '           ;then blank that character. 
dda9 cd 0c ea		        CALL    CONOUT 
ddac 0e 08		BACKUP1:LD      C,BS            ;then back space once more. 
ddae c3 0c ea		        JP      CONOUT 
ddb1			; 
ddb1			;   Signal a deleted line. Print a '#' at the end and start 
ddb1			; over. 
ddb1			; 
ddb1 0e 23		NEWLINE:LD      C,'#' 
ddb3 cd 48 dd		        CALL    OUTCHAR         ;print this. 
ddb6 cd c9 dd		        CALL    OUTCRLF         ;start new line. 
ddb9 3a 0c df		NEWLN1: LD      A,(CURPOS)      ;move the cursor to the starting position. 
ddbc 21 0b df		        LD      HL,STARTING 
ddbf be			        CP      (HL) 
ddc0 d0			        RET     NC              ;there yet? 
ddc1 0e 20		        LD      C,' ' 
ddc3 cd 48 dd		        CALL    OUTCHAR         ;nope, keep going. 
ddc6 c3 b9 dd		        JP      NEWLN1 
ddc9			; 
ddc9			;   Output a (cr) (lf) to the console device (screen). 
ddc9			; 
ddc9 0e 0d		OUTCRLF:LD      C,CR 
ddcb cd 48 dd		        CALL    OUTCHAR 
ddce 0e 0a		        LD      C,LF 
ddd0 c3 48 dd		        JP      OUTCHAR 
ddd3			; 
ddd3			;   Print message pointed to by (BC). It will end with a '$'. 
ddd3			; 
ddd3 0a			PRTMESG:LD      A,(BC)          ;check for terminating character. 
ddd4 fe 24		        CP      '$' 
ddd6 c8			        RET     Z 
ddd7 03			        INC     BC 
ddd8 c5			        PUSH    BC              ;otherwise, bump pointer and print it. 
ddd9 4f			        LD      C,A 
ddda cd 90 dd		        CALL    OUTCON 
dddd c1			        POP     BC 
ddde c3 d3 dd		        JP      PRTMESG 
dde1			; 
dde1			;   Function to execute a buffered read. 
dde1			; 
dde1 3a 0c df		RDBUFF: LD      A,(CURPOS)      ;use present location as starting one. 
dde4 32 0b df		        LD      (STARTING),A 
dde7 2a 43 df		        LD      HL,(PARAMS)     ;get the maximum buffer space. 
ddea 4e			        LD      C,(HL) 
ddeb 23			        INC     HL              ;point to first available space. 
ddec e5			        PUSH    HL              ;and save. 
dded 06 00		        LD      B,0             ;keep a character count. 
ddef c5			RDBUF1: PUSH    BC 
ddf0 e5			        PUSH    HL 
ddf1 cd fb dc		RDBUF2: CALL    GETCHAR         ;get the next input character. 
ddf4 e6 7f		        AND     7FH             ;strip bit 7. 
ddf6 e1			        POP     HL              ;reset registers. 
ddf7 c1			        POP     BC 
ddf8 fe 0d		        CP      CR              ;en of the line? 
ddfa ca c1 de		        JP      Z,RDBUF17 
ddfd fe 0a		        CP      LF 
ddff ca c1 de		        JP      Z,RDBUF17 
de02 fe 08		        CP      BS              ;how about a backspace? 
de04 c2 16 de		        JP      NZ,RDBUF3 
de07 78			        LD      A,B             ;yes, but ignore at the beginning of the line. 
de08 b7			        OR      A 
de09 ca ef dd		        JP      Z,RDBUF1 
de0c 05			        DEC     B               ;ok, update counter. 
de0d 3a 0c df		        LD      A,(CURPOS)      ;if we backspace to the start of the line, 
de10 32 0a df		        LD      (OUTFLAG),A     ;treat as a cancel (control-x). 
de13 c3 70 de		        JP      RDBUF10 
de16 fe 7f		RDBUF3: CP      DEL             ;user typed a rubout? 
de18 c2 26 de		        JP      NZ,RDBUF4 
de1b 78			        LD      A,B             ;ignore at the start of the line. 
de1c b7			        OR      A 
de1d ca ef dd		        JP      Z,RDBUF1 
de20 7e			        LD      A,(HL)          ;ok, echo the prevoius character. 
de21 05			        DEC     B               ;and reset pointers (counters). 
de22 2b			        DEC     HL 
de23 c3 a9 de		        JP      RDBUF15 
de26 fe 05		RDBUF4: CP      CNTRLE          ;physical end of line? 
de28 c2 37 de		        JP      NZ,RDBUF5 
de2b c5			        PUSH    BC              ;yes, do it. 
de2c e5			        PUSH    HL 
de2d cd c9 dd		        CALL    OUTCRLF 
de30 af			        XOR     A               ;and update starting position. 
de31 32 0b df		        LD      (STARTING),A 
de34 c3 f1 dd		        JP      RDBUF2 
de37 fe 10		RDBUF5: CP      CNTRLP          ;control-p? 
de39 c2 48 de		        JP      NZ,RDBUF6 
de3c e5			        PUSH    HL              ;yes, flip the print flag filp-flop byte. 
de3d 21 0d df		        LD      HL,PRTFLAG 
de40 3e 01		        LD      A,1             ;PRTFLAG=1-PRTFLAG 
de42 96			        SUB     (HL) 
de43 77			        LD      (HL),A 
de44 e1			        POP     HL 
de45 c3 ef dd		        JP      RDBUF1 
de48 fe 18		RDBUF6: CP      CNTRLX          ;control-x (cancel)? 
de4a c2 5f de		        JP      NZ,RDBUF8 
de4d e1			        POP     HL 
de4e 3a 0b df		RDBUF7: LD      A,(STARTING)    ;yes, backup the cursor to here. 
de51 21 0c df		        LD      HL,CURPOS 
de54 be			        CP      (HL) 
de55 d2 e1 dd		        JP      NC,RDBUFF       ;done yet? 
de58 35			        DEC     (HL)            ;no, decrement pointer and output back up one space. 
de59 cd a4 dd		        CALL    BACKUP 
de5c c3 4e de		        JP      RDBUF7 
de5f fe 15		RDBUF8: CP      CNTRLU          ;cntrol-u (cancel line)? 
de61 c2 6b de		        JP      NZ,RDBUF9 
de64 cd b1 dd		        CALL    NEWLINE         ;start a new line. 
de67 e1			        POP     HL 
de68 c3 e1 dd		        JP      RDBUFF 
de6b fe 12		RDBUF9: CP      CNTRLR          ;control-r? 
de6d c2 a6 de		        JP      NZ,RDBUF14 
de70 c5			RDBUF10:PUSH    BC              ;yes, start a new line and retype the old one. 
de71 cd b1 dd		        CALL    NEWLINE 
de74 c1			        POP     BC 
de75 e1			        POP     HL 
de76 e5			        PUSH    HL 
de77 c5			        PUSH    BC 
de78 78			RDBUF11:LD      A,B             ;done whole line yet? 
de79 b7			        OR      A 
de7a ca 8a de		        JP      Z,RDBUF12 
de7d 23			        INC     HL              ;nope, get next character. 
de7e 4e			        LD      C,(HL) 
de7f 05			        DEC     B               ;count it. 
de80 c5			        PUSH    BC 
de81 e5			        PUSH    HL 
de82 cd 7f dd		        CALL    SHOWIT          ;and display it. 
de85 e1			        POP     HL 
de86 c1			        POP     BC 
de87 c3 78 de		        JP      RDBUF11 
de8a e5			RDBUF12:PUSH    HL              ;done with line. If we were displaying 
de8b 3a 0a df		        LD      A,(OUTFLAG)     ;then update cursor position. 
de8e b7			        OR      A 
de8f ca f1 dd		        JP      Z,RDBUF2 
de92 21 0c df		        LD      HL,CURPOS       ;because this line is shorter, we must 
de95 96			        SUB     (HL)            ;back up the cursor (not the screen however) 
de96 32 0a df		        LD      (OUTFLAG),A     ;some number of positions. 
de99 cd a4 dd		RDBUF13:CALL    BACKUP          ;note that as long as (OUTFLAG) is non 
de9c 21 0a df		        LD      HL,OUTFLAG      ;zero, the screen will not be changed. 
de9f 35			        DEC     (HL) 
dea0 c2 99 de		        JP      NZ,RDBUF13 
dea3 c3 f1 dd		        JP      RDBUF2          ;now just get the next character. 
dea6			; 
dea6			;   Just a normal character, put this in our buffer and echo. 
dea6			; 
dea6 23			RDBUF14:INC     HL 
dea7 77			        LD      (HL),A          ;store character. 
dea8 04			        INC     B               ;and count it. 
dea9 c5			RDBUF15:PUSH    BC 
deaa e5			        PUSH    HL 
deab 4f			        LD      C,A             ;echo it now. 
deac cd 7f dd		        CALL    SHOWIT 
deaf e1			        POP     HL 
deb0 c1			        POP     BC 
deb1 7e			        LD      A,(HL)          ;was it an abort request? 
deb2 fe 03		        CP      CNTRLC          ;control-c abort? 
deb4 78			        LD      A,B 
deb5 c2 bd de		        JP      NZ,RDBUF16 
deb8 fe 01		        CP      1               ;only if at start of line. 
deba ca 00 00		        JP      Z,0 
debd b9			RDBUF16:CP      C               ;nope, have we filled the buffer? 
debe da ef dd		        JP      C,RDBUF1 
dec1 e1			RDBUF17:POP     HL              ;yes end the line and return. 
dec2 70			        LD      (HL),B 
dec3 0e 0d		        LD      C,CR 
dec5 c3 48 dd		        JP      OUTCHAR         ;output (cr) and return. 
dec8			; 
dec8			;   Function to get a character from the console device. 
dec8			; 
dec8 cd 06 dd		GETCON: CALL    GETECHO         ;get and echo. 
decb c3 01 df		        JP      SETSTAT         ;save status and return. 
dece			; 
dece			;   Function to get a character from the tape reader device. 
dece			; 
dece cd 15 ea		GETRDR: CALL    READER          ;get a character from reader, set status and return. 
ded1 c3 01 df		        JP      SETSTAT 
ded4			; 
ded4			;  Function to perform direct console i/o. If (C) contains (FF) 
ded4			; then this is an input request. If (C) contains (FE) then 
ded4			; this is a status request. Otherwise we are to output (C). 
ded4			; 
ded4 79			DIRCIO: LD      A,C             ;test for (FF). 
ded5 3c			        INC     A 
ded6 ca e0 de		        JP      Z,DIRC1 
ded9 3c			        INC     A               ;test for (FE). 
deda ca 06 ea		        JP      Z,CONST 
dedd c3 0c ea		        JP      CONOUT          ;just output (C). 
dee0 cd 06 ea		DIRC1:  CALL    CONST           ;this is an input request. 
dee3 b7			        OR      A 
dee4 ca 91 e9		        JP      Z,GOBACK1       ;not ready? Just return (directly). 
dee7 cd 09 ea		        CALL    CONIN           ;yes, get character. 
deea c3 01 df		        JP      SETSTAT         ;set status and return. 
deed			; 
deed			;   Function to return the i/o byte. 
deed			; 
deed 3a 03 00		GETIOB: LD      A,(IOBYTE) 
def0 c3 01 df		        JP      SETSTAT 
def3			; 
def3			;   Function to set the i/o byte. 
def3			; 
def3 21 03 00		SETIOB: LD      HL,IOBYTE 
def6 71			        LD      (HL),C 
def7 c9			        RET      
def8			; 
def8			;   Function to print the character string pointed to by (DE) 
def8			; on the console device. The string ends with a '$'. 
def8			; 
def8 eb			PRTSTR: EX      DE,HL 
def9 4d			        LD      C,L 
defa 44			        LD      B,H             ;now (BC) points to it. 
defb c3 d3 dd		        JP      PRTMESG 
defe			; 
defe			;   Function to interigate the console device. 
defe			; 
defe cd 23 dd		GETCSTS:CALL    CKCONSOL 
df01			; 
df01			;   Get here to set the status and return to the cleanup 
df01			; section. Then back to the user. 
df01			; 
df01 32 45 df		SETSTAT:LD      (STATUS),A 
df04 c9			RTN:    RET      
df05			; 
df05			;   Set the status to 1 (read or write error code). 
df05			; 
df05 3e 01		IOERR1: LD      A,1 
df07 c3 01 df		        JP      SETSTAT 
df0a			; 
df0a 00			OUTFLAG:DEFB    0               ;output flag (non zero means no output). 
df0b 02			STARTING: DEFB  2               ;starting position for cursor. 
df0c 00			CURPOS: DEFB    0               ;cursor position (0=start of line). 
df0d 00			PRTFLAG:DEFB    0               ;printer flag (control-p toggle). List if non zero. 
df0e 00			CHARBUF:DEFB    0               ;single input character buffer. 
df0f			; 
df0f			;   Stack area for BDOS calls. 
df0f			; 
df0f 00 00		USRSTACK: DEFW  0               ;save users stack pointer here. 
df11			; 
df11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00	        DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
df29 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00	        DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
df41			STKAREA: EQU     $               ;end of stack area. 
df41			; 
df41 00			USERNO: DEFB    0               ;current user number. 
df42 00			ACTIVE: DEFB    0               ;currently active drive. 
df43 00 00		PARAMS: DEFW    0               ;save (DE) parameters here on entry. 
df45 00 00		STATUS: DEFW    0               ;status returned from bdos function. 
df47			; 
df47			;   Select error occured, jump to error routine. 
df47			; 
df47 21 0b dc		SLCTERR:LD      HL,BADSLCT 
df4a			; 
df4a			;   Jump to (HL) indirectly. 
df4a			; 
df4a 5e			JUMPHL: LD      E,(HL) 
df4b 23			        INC     HL 
df4c 56			        LD      D,(HL)          ;now (DE) contain the desired address. 
df4d eb			        EX      DE,HL 
df4e e9			        JP      (HL) 
df4f			; 
df4f			;   Block move. (DE) to (HL), (C) bytes total. 
df4f			; 
df4f 0c			DE2HL:  INC     C               ;is count down to zero? 
df50 0d			DE2HL1: DEC     C 
df51 c8			        RET     Z               ;yes, we are done. 
df52 1a			        LD      A,(DE)          ;no, move one more byte. 
df53 77			        LD      (HL),A 
df54 13			        INC     DE 
df55 23			        INC     HL 
df56 c3 50 df		        JP      DE2HL1          ;and repeat. 
df59			; 
df59			;   Select the desired drive. 
df59			; 
df59 3a 42 df		SELECT: LD      A,(ACTIVE)      ;get active disk. 
df5c 4f			        LD      C,A 
df5d cd 1b ea		        CALL    SELDSK          ;select it. 
df60 7c			        LD      A,H             ;valid drive? 
df61 b5			        OR      L               ;valid drive? 
df62 c8			        RET     Z               ;return if not. 
df63			; 
df63			;   Here, the BIOS returned the address of the parameter block 
df63			; in (HL). We will extract the necessary pointers and save them. 
df63			; 
df63 5e			        LD      E,(HL)          ;yes, get address of translation table into (DE). 
df64 23			        INC     HL 
df65 56			        LD      D,(HL) 
df66 23			        INC     HL 
df67 22 b3 e9		        LD      (SCRATCH1),HL   ;save pointers to scratch areas. 
df6a 23			        INC     HL 
df6b 23			        INC     HL 
df6c 22 b5 e9		        LD      (SCRATCH2),HL   ;ditto. 
df6f 23			        INC     HL 
df70 23			        INC     HL 
df71 22 b7 e9		        LD      (SCRATCH3),HL   ;ditto. 
df74 23			        INC     HL 
df75 23			        INC     HL 
df76 eb			        EX      DE,HL           ;now save the translation table address. 
df77 22 d0 e9		        LD      (XLATE),HL 
df7a 21 b9 e9		        LD      HL,DIRBUF       ;put the next 8 bytes here. 
df7d 0e 08		        LD      C,8             ;they consist of the directory buffer 
df7f cd 4f df		        CALL    DE2HL           ;pointer, parameter block pointer, 
df82 2a bb e9		        LD      HL,(DISKPB)     ;check and allocation vectors. 
df85 eb			        EX      DE,HL 
df86 21 c1 e9		        LD      HL,SECTORS      ;move parameter block into our ram. 
df89 0e 0f		        LD      C,15            ;it is 15 bytes long. 
df8b cd 4f df		        CALL    DE2HL 
df8e 2a c6 e9		        LD      HL,(DSKSIZE)    ;check disk size. 
df91 7c			        LD      A,H             ;more than 256 blocks on this? 
df92 21 dd e9		        LD      HL,BIGDISK 
df95 36 ff		        LD      (HL),0FFH       ;set to samll. 
df97 b7			        OR      A 
df98 ca 9d df		        JP      Z,SELECT1 
df9b 36 00		        LD      (HL),0          ;wrong, set to large. 
df9d 3e ff		SELECT1:LD      A,0FFH          ;clear the zero flag. 
df9f b7			        OR      A 
dfa0 c9			        RET      
dfa1			; 
dfa1			;   Routine to home the disk track head and clear pointers. 
dfa1			; 
dfa1 cd 18 ea		HOMEDRV:CALL    HOME            ;home the head. 
dfa4 af			        XOR     A 
dfa5 2a b5 e9		        LD      HL,(SCRATCH2)   ;set our track pointer also. 
dfa8 77			        LD      (HL),A 
dfa9 23			        INC     HL 
dfaa 77			        LD      (HL),A 
dfab 2a b7 e9		        LD      HL,(SCRATCH3)   ;and our sector pointer. 
dfae 77			        LD      (HL),A 
dfaf 23			        INC     HL 
dfb0 77			        LD      (HL),A 
dfb1 c9			        RET      
dfb2			; 
dfb2			;   Do the actual disk read and check the error return status. 
dfb2			; 
dfb2 cd 27 ea		DOREAD: CALL    READ 
dfb5 c3 bb df		        JP      IORET 
dfb8			; 
dfb8			;   Do the actual disk write and handle any bios error. 
dfb8			; 
dfb8 cd 2a ea		DOWRITE:CALL    WRITE 
dfbb b7			IORET:  OR      A 
dfbc c8			        RET     Z               ;return unless an error occured. 
dfbd 21 09 dc		        LD      HL,BADSCTR      ;bad read/write on this sector. 
dfc0 c3 4a df		        JP      JUMPHL 
dfc3			; 
dfc3			;   Routine to select the track and sector that the desired 
dfc3			; block number falls in. 
dfc3			; 
dfc3 2a ea e9		TRKSEC: LD      HL,(FILEPOS)    ;get position of last accessed file 
dfc6 0e 02		        LD      C,2             ;in directory and compute sector #. 
dfc8 cd ea e0		        CALL    SHIFTR          ;sector #=file-position/4. 
dfcb 22 e5 e9		        LD      (BLKNMBR),HL    ;save this as the block number of interest. 
dfce 22 ec e9		        LD      (CKSUMTBL),HL   ;what's it doing here too? 
dfd1			; 
dfd1			;   if the sector number has already been set (BLKNMBR), enter 
dfd1			; at this point. 
dfd1			; 
dfd1 21 e5 e9		TRKSEC1:LD      HL,BLKNMBR 
dfd4 4e			        LD      C,(HL)          ;move sector number into (BC). 
dfd5 23			        INC     HL 
dfd6 46			        LD      B,(HL) 
dfd7 2a b7 e9		        LD      HL,(SCRATCH3)   ;get current sector number and 
dfda 5e			        LD      E,(HL)          ;move this into (DE). 
dfdb 23			        INC     HL 
dfdc 56			        LD      D,(HL) 
dfdd 2a b5 e9		        LD      HL,(SCRATCH2)   ;get current track number. 
dfe0 7e			        LD      A,(HL)          ;and this into (HL). 
dfe1 23			        INC     HL 
dfe2 66			        LD      H,(HL) 
dfe3 6f			        LD      L,A 
dfe4 79			TRKSEC2:LD      A,C             ;is desired sector before current one? 
dfe5 93			        SUB     E 
dfe6 78			        LD      A,B 
dfe7 9a			        SBC     A,D 
dfe8 d2 fa df		        JP      NC,TRKSEC3 
dfeb e5			        PUSH    HL              ;yes, decrement sectors by one track. 
dfec 2a c1 e9		        LD      HL,(SECTORS)    ;get sectors per track. 
dfef 7b			        LD      A,E 
dff0 95			        SUB     L 
dff1 5f			        LD      E,A 
dff2 7a			        LD      A,D 
dff3 9c			        SBC     A,H 
dff4 57			        LD      D,A             ;now we have backed up one full track. 
dff5 e1			        POP     HL 
dff6 2b			        DEC     HL              ;adjust track counter. 
dff7 c3 e4 df		        JP      TRKSEC2 
dffa e5			TRKSEC3:PUSH    HL              ;desired sector is after current one. 
dffb 2a c1 e9		        LD      HL,(SECTORS)    ;get sectors per track. 
dffe 19			        ADD     HL,DE           ;bump sector pointer to next track. 
dfff da 0f e0		        JP      C,TRKSEC4 
e002 79			        LD      A,C             ;is desired sector now before current one? 
e003 95			        SUB     L 
e004 78			        LD      A,B 
e005 9c			        SBC     A,H 
e006 da 0f e0		        JP      C,TRKSEC4 
e009 eb			        EX      DE,HL           ;not yes, increment track counter 
e00a e1			        POP     HL              ;and continue until it is. 
e00b 23			        INC     HL 
e00c c3 fa df		        JP      TRKSEC3 
e00f			; 
e00f			;   here we have determined the track number that contains the 
e00f			; desired sector. 
e00f			; 
e00f e1			TRKSEC4:POP     HL              ;get track number (HL). 
e010 c5			        PUSH    BC 
e011 d5			        PUSH    DE 
e012 e5			        PUSH    HL 
e013 eb			        EX      DE,HL 
e014 2a ce e9		        LD      HL,(OFFSET)     ;adjust for first track offset. 
e017 19			        ADD     HL,DE 
e018 44			        LD      B,H 
e019 4d			        LD      C,L 
e01a cd 1e ea		        CALL    SETTRK          ;select this track. 
e01d d1			        POP     DE              ;reset current track pointer. 
e01e 2a b5 e9		        LD      HL,(SCRATCH2) 
e021 73			        LD      (HL),E 
e022 23			        INC     HL 
e023 72			        LD      (HL),D 
e024 d1			        POP     DE 
e025 2a b7 e9		        LD      HL,(SCRATCH3)   ;reset the first sector on this track. 
e028 73			        LD      (HL),E 
e029 23			        INC     HL 
e02a 72			        LD      (HL),D 
e02b c1			        POP     BC 
e02c 79			        LD      A,C             ;now subtract the desired one. 
e02d 93			        SUB     E               ;to make it relative (1-# sectors/track). 
e02e 4f			        LD      C,A 
e02f 78			        LD      A,B 
e030 9a			        SBC     A,D 
e031 47			        LD      B,A 
e032 2a d0 e9		        LD      HL,(XLATE)      ;translate this sector according to this table. 
e035 eb			        EX      DE,HL 
e036 cd 30 ea		        CALL    SECTRN          ;let the bios translate it. 
e039 4d			        LD      C,L 
e03a 44			        LD      B,H 
e03b c3 21 ea		        JP      SETSEC          ;and select it. 
e03e			; 
e03e			;   Compute block number from record number (SAVNREC) and 
e03e			; extent number (SAVEXT). 
e03e			; 
e03e 21 c3 e9		GETBLOCK: LD    HL,BLKSHFT      ;get logical to physical conversion. 
e041 4e			        LD      C,(HL)          ;note that this is base 2 log of ratio. 
e042 3a e3 e9		        LD      A,(SAVNREC)     ;get record number. 
e045 b7			GETBLK1:OR      A               ;compute (A)=(A)/2^BLKSHFT. 
e046 1f			        RRA      
e047 0d			        DEC     C 
e048 c2 45 e0		        JP      NZ,GETBLK1 
e04b 47			        LD      B,A             ;save result in (B). 
e04c 3e 08		        LD      A,8 
e04e 96			        SUB     (HL) 
e04f 4f			        LD      C,A             ;compute (C)=8-BLKSHFT. 
e050 3a e2 e9		        LD      A,(SAVEXT) 
e053 0d			GETBLK2:DEC     C               ;compute (A)=SAVEXT*2^(8-BLKSHFT). 
e054 ca 5c e0		        JP      Z,GETBLK3 
e057 b7			        OR      A 
e058 17			        RLA      
e059 c3 53 e0		        JP      GETBLK2 
e05c 80			GETBLK3:ADD     A,B 
e05d c9			        RET      
e05e			; 
e05e			;   Routine to extract the (BC) block byte from the fcb pointed 
e05e			; to by (PARAMS). If this is a big-disk, then these are 16 bit 
e05e			; block numbers, else they are 8 bit numbers. 
e05e			; Number is returned in (HL). 
e05e			; 
e05e 2a 43 df		EXTBLK: LD      HL,(PARAMS)     ;get fcb address. 
e061 11 10 00		        LD      DE,16           ;block numbers start 16 bytes into fcb. 
e064 19			        ADD     HL,DE 
e065 09			        ADD     HL,BC 
e066 3a dd e9		        LD      A,(BIGDISK)     ;are we using a big-disk? 
e069 b7			        OR      A 
e06a ca 71 e0		        JP      Z,EXTBLK1 
e06d 6e			        LD      L,(HL)          ;no, extract an 8 bit number from the fcb. 
e06e 26 00		        LD      H,0 
e070 c9			        RET      
e071 09			EXTBLK1:ADD     HL,BC           ;yes, extract a 16 bit number. 
e072 5e			        LD      E,(HL) 
e073 23			        INC     HL 
e074 56			        LD      D,(HL) 
e075 eb			        EX      DE,HL           ;return in (HL). 
e076 c9			        RET      
e077			; 
e077			;   Compute block number. 
e077			; 
e077 cd 3e e0		COMBLK: CALL    GETBLOCK 
e07a 4f			        LD      C,A 
e07b 06 00		        LD      B,0 
e07d cd 5e e0		        CALL    EXTBLK 
e080 22 e5 e9		        LD      (BLKNMBR),HL 
e083 c9			        RET      
e084			; 
e084			;   Check for a zero block number (unused). 
e084			; 
e084 2a e5 e9		CHKBLK: LD      HL,(BLKNMBR) 
e087 7d			        LD      A,L             ;is it zero? 
e088 b4			        OR      H 
e089 c9			        RET      
e08a			; 
e08a			;   Adjust physical block (BLKNMBR) and convert to logical 
e08a			; sector (LOGSECT). This is the starting sector of this block. 
e08a			; The actual sector of interest is then added to this and the 
e08a			; resulting sector number is stored back in (BLKNMBR). This 
e08a			; will still have to be adjusted for the track number. 
e08a			; 
e08a 3a c3 e9		LOGICAL:LD      A,(BLKSHFT)     ;get log2(physical/logical sectors). 
e08d 2a e5 e9		        LD      HL,(BLKNMBR)    ;get physical sector desired. 
e090 29			LOGICL1:ADD     HL,HL           ;compute logical sector number. 
e091 3d			        DEC     A               ;note logical sectors are 128 bytes long. 
e092 c2 90 e0		        JP      NZ,LOGICL1 
e095 22 e7 e9		        LD      (LOGSECT),HL    ;save logical sector. 
e098 3a c4 e9		        LD      A,(BLKMASK)     ;get block mask. 
e09b 4f			        LD      C,A 
e09c 3a e3 e9		        LD      A,(SAVNREC)     ;get next sector to access. 
e09f a1			        AND     C               ;extract the relative position within physical block. 
e0a0 b5			        OR      L               ;and add it too logical sector. 
e0a1 6f			        LD      L,A 
e0a2 22 e5 e9		        LD      (BLKNMBR),HL    ;and store. 
e0a5 c9			        RET      
e0a6			; 
e0a6			;   Set (HL) to point to extent byte in fcb. 
e0a6			; 
e0a6 2a 43 df		SETEXT: LD      HL,(PARAMS) 
e0a9 11 0c 00		        LD      DE,12           ;it is the twelth byte. 
e0ac 19			        ADD     HL,DE 
e0ad c9			        RET      
e0ae			; 
e0ae			;   Set (HL) to point to record count byte in fcb and (DE) to 
e0ae			; next record number byte. 
e0ae			; 
e0ae 2a 43 df		SETHLDE:LD      HL,(PARAMS) 
e0b1 11 0f 00		        LD      DE,15           ;record count byte (#15). 
e0b4 19			        ADD     HL,DE 
e0b5 eb			        EX      DE,HL 
e0b6 21 11 00		        LD      HL,17           ;next record number (#32). 
e0b9 19			        ADD     HL,DE 
e0ba c9			        RET      
e0bb			; 
e0bb			;   Save current file data from fcb. 
e0bb			; 
e0bb cd ae e0		STRDATA:CALL    SETHLDE 
e0be 7e			        LD      A,(HL)          ;get and store record count byte. 
e0bf 32 e3 e9		        LD      (SAVNREC),A 
e0c2 eb			        EX      DE,HL 
e0c3 7e			        LD      A,(HL)          ;get and store next record number byte. 
e0c4 32 e1 e9		        LD      (SAVNXT),A 
e0c7 cd a6 e0		        CALL    SETEXT          ;point to extent byte. 
e0ca 3a c5 e9		        LD      A,(EXTMASK)     ;get extent mask. 
e0cd a6			        AND     (HL) 
e0ce 32 e2 e9		        LD      (SAVEXT),A      ;and save extent here. 
e0d1 c9			        RET      
e0d2			; 
e0d2			;   Set the next record to access. If (MODE) is set to 2, then 
e0d2			; the last record byte (SAVNREC) has the correct number to access. 
e0d2			; For sequential access, (MODE) will be equal to 1. 
e0d2			; 
e0d2 cd ae e0		SETNREC:CALL    SETHLDE 
e0d5 3a d5 e9		        LD      A,(MODE)        ;get sequential flag (=1). 
e0d8 fe 02		        CP      2               ;a 2 indicates that no adder is needed. 
e0da c2 de e0		        JP      NZ,STNREC1 
e0dd af			        XOR     A               ;clear adder (random access?). 
e0de 4f			STNREC1:LD      C,A 
e0df 3a e3 e9		        LD      A,(SAVNREC)     ;get last record number. 
e0e2 81			        ADD     A,C             ;increment record count. 
e0e3 77			        LD      (HL),A          ;and set fcb's next record byte. 
e0e4 eb			        EX      DE,HL 
e0e5 3a e1 e9		        LD      A,(SAVNXT)      ;get next record byte from storage. 
e0e8 77			        LD      (HL),A          ;and put this into fcb as number of records used. 
e0e9 c9			        RET      
e0ea			; 
e0ea			;   Shift (HL) right (C) bits. 
e0ea			; 
e0ea 0c			SHIFTR: INC     C 
e0eb 0d			SHIFTR1:DEC     C 
e0ec c8			        RET     Z 
e0ed 7c			        LD      A,H 
e0ee b7			        OR      A 
e0ef 1f			        RRA      
e0f0 67			        LD      H,A 
e0f1 7d			        LD      A,L 
e0f2 1f			        RRA      
e0f3 6f			        LD      L,A 
e0f4 c3 eb e0		        JP      SHIFTR1 
e0f7			; 
e0f7			;   Compute the check-sum for the directory buffer. Return 
e0f7			; integer sum in (A). 
e0f7			; 
e0f7 0e 80		CHECKSUM: LD    C,128           ;length of buffer. 
e0f9 2a b9 e9		        LD      HL,(DIRBUF)     ;get its location. 
e0fc af			        XOR     A               ;clear summation byte. 
e0fd 86			CHKSUM1:ADD     A,(HL)             ;and compute sum ignoring carries. 
e0fe 23			        INC     HL 
e0ff 0d			        DEC     C 
e100 c2 fd e0		        JP      NZ,CHKSUM1 
e103 c9			        RET      
e104			; 
e104			;   Shift (HL) left (C) bits. 
e104			; 
e104 0c			SHIFTL: INC     C 
e105 0d			SHIFTL1:DEC     C 
e106 c8			        RET     Z 
e107 29			        ADD     HL,HL           ;shift left 1 bit. 
e108 c3 05 e1		        JP      SHIFTL1 
e10b			; 
e10b			;   Routine to set a bit in a 16 bit value contained in (BC). 
e10b			; The bit set depends on the current drive selection. 
e10b			; 
e10b c5			SETBIT: PUSH    BC              ;save 16 bit word. 
e10c 3a 42 df		        LD      A,(ACTIVE)      ;get active drive. 
e10f 4f			        LD      C,A 
e110 21 01 00		        LD      HL,1 
e113 cd 04 e1		        CALL    SHIFTL          ;shift bit 0 into place. 
e116 c1			        POP     BC              ;now 'or' this with the original word. 
e117 79			        LD      A,C 
e118 b5			        OR      L 
e119 6f			        LD      L,A             ;low byte done, do high byte. 
e11a 78			        LD      A,B 
e11b b4			        OR      H 
e11c 67			        LD      H,A 
e11d c9			        RET      
e11e			; 
e11e			;   Extract the write protect status bit for the current drive. 
e11e			; The result is returned in (A), bit 0. 
e11e			; 
e11e 2a ad e9		GETWPRT:LD      HL,(WRTPRT)     ;get status bytes. 
e121 3a 42 df		        LD      A,(ACTIVE)      ;which drive is current? 
e124 4f			        LD      C,A 
e125 cd ea e0		        CALL    SHIFTR          ;shift status such that bit 0 is the 
e128 7d			        LD      A,L             ;one of interest for this drive. 
e129 e6 01		        AND     01H             ;and isolate it. 
e12b c9			        RET      
e12c			; 
e12c			;   Function to write protect the current disk. 
e12c			; 
e12c 21 ad e9		WRTPRTD:LD      HL,WRTPRT       ;point to status word. 
e12f 4e			        LD      C,(HL)          ;set (BC) equal to the status. 
e130 23			        INC     HL 
e131 46			        LD      B,(HL) 
e132 cd 0b e1		        CALL    SETBIT          ;and set this bit according to current drive. 
e135 22 ad e9		        LD      (WRTPRT),HL     ;then save. 
e138 2a c8 e9		        LD      HL,(DIRSIZE)    ;now save directory size limit. 
e13b 23			        INC     HL              ;remember the last one. 
e13c eb			        EX      DE,HL 
e13d 2a b3 e9		        LD      HL,(SCRATCH1)   ;and store it here. 
e140 73			        LD      (HL),E          ;put low byte. 
e141 23			        INC     HL 
e142 72			        LD      (HL),D          ;then high byte. 
e143 c9			        RET      
e144			; 
e144			;   Check for a read only file. 
e144			; 
e144 cd 5e e1		CHKROFL:CALL    FCB2HL          ;set (HL) to file entry in directory buffer. 
e147 11 09 00		CKROF1: LD      DE,9            ;look at bit 7 of the ninth byte. 
e14a 19			        ADD     HL,DE 
e14b 7e			        LD      A,(HL) 
e14c 17			        RLA      
e14d d0			        RET     NC              ;return if ok. 
e14e 21 0f dc		        LD      HL,ROFILE       ;else, print error message and terminate. 
e151 c3 4a df		        JP      JUMPHL 
e154			; 
e154			;   Check the write protect status of the active disk. 
e154			; 
e154 cd 1e e1		CHKWPRT:CALL    GETWPRT 
e157 c8			        RET     Z               ;return if ok. 
e158 21 0d dc		        LD      HL,RODISK       ;else print message and terminate. 
e15b c3 4a df		        JP      JUMPHL 
e15e			; 
e15e			;   Routine to set (HL) pointing to the proper entry in the 
e15e			; directory buffer. 
e15e			; 
e15e 2a b9 e9		FCB2HL: LD      HL,(DIRBUF)     ;get address of buffer. 
e161 3a e9 e9		        LD      A,(FCBPOS)      ;relative position of file. 
e164			; 
e164			;   Routine to add (A) to (HL). 
e164			; 
e164 85			ADDA2HL:ADD     A,L 
e165 6f			        LD      L,A 
e166 d0			        RET     NC 
e167 24			        INC     H               ;take care of any carry. 
e168 c9			        RET      
e169			; 
e169			;   Routine to get the 's2' byte from the fcb supplied in 
e169			; the initial parameter specification. 
e169			; 
e169 2a 43 df		GETS2:  LD      HL,(PARAMS)     ;get address of fcb. 
e16c 11 0e 00		        LD      DE,14           ;relative position of 's2'. 
e16f 19			        ADD     HL,DE 
e170 7e			        LD      A,(HL)          ;extract this byte. 
e171 c9			        RET      
e172			; 
e172			;   Clear the 's2' byte in the fcb. 
e172			; 
e172 cd 69 e1		CLEARS2:CALL    GETS2           ;this sets (HL) pointing to it. 
e175 36 00		        LD      (HL),0          ;now clear it. 
e177 c9			        RET      
e178			; 
e178			;   Set bit 7 in the 's2' byte of the fcb. 
e178			; 
e178 cd 69 e1		SETS2B7:CALL    GETS2           ;get the byte. 
e17b f6 80		        OR      80H             ;and set bit 7. 
e17d 77			        LD      (HL),A          ;then store. 
e17e c9			        RET      
e17f			; 
e17f			;   Compare (FILEPOS) with (SCRATCH1) and set flags based on 
e17f			; the difference. This checks to see if there are more file 
e17f			; names in the directory. We are at (FILEPOS) and there are 
e17f			; (SCRATCH1) of them to check. 
e17f			; 
e17f 2a ea e9		MOREFLS:LD      HL,(FILEPOS)    ;we are here. 
e182 eb			        EX      DE,HL 
e183 2a b3 e9		        LD      HL,(SCRATCH1)   ;and don't go past here. 
e186 7b			        LD      A,E             ;compute difference but don't keep. 
e187 96			        SUB     (HL) 
e188 23			        INC     HL 
e189 7a			        LD      A,D 
e18a 9e			        SBC     A,(HL)             ;set carry if no more names. 
e18b c9			        RET      
e18c			; 
e18c			;   Call this routine to prevent (SCRATCH1) from being greater 
e18c			; than (FILEPOS). 
e18c			; 
e18c cd 7f e1		CHKNMBR:CALL    MOREFLS         ;SCRATCH1 too big? 
e18f d8			        RET     C 
e190 13			        INC     DE              ;yes, reset it to (FILEPOS). 
e191 72			        LD      (HL),D 
e192 2b			        DEC     HL 
e193 73			        LD      (HL),E 
e194 c9			        RET      
e195			; 
e195			;   Compute (HL)=(DE)-(HL) 
e195			; 
e195 7b			SUBHL:  LD      A,E             ;compute difference. 
e196 95			        SUB     L 
e197 6f			        LD      L,A             ;store low byte. 
e198 7a			        LD      A,D 
e199 9c			        SBC     A,H 
e19a 67			        LD      H,A             ;and then high byte. 
e19b c9			        RET      
e19c			; 
e19c			;   Set the directory checksum byte. 
e19c			; 
e19c 0e ff		SETDIR: LD      C,0FFH 
e19e			; 
e19e			;   Routine to set or compare the directory checksum byte. If 
e19e			; (C)=0ffh, then this will set the checksum byte. Else the byte 
e19e			; will be checked. If the check fails (the disk has been changed), 
e19e			; then this disk will be write protected. 
e19e			; 
e19e 2a ec e9		CHECKDIR: LD    HL,(CKSUMTBL) 
e1a1 eb			        EX      DE,HL 
e1a2 2a cc e9		        LD      HL,(ALLOC1) 
e1a5 cd 95 e1		        CALL    SUBHL 
e1a8 d0			        RET     NC              ;ok if (CKSUMTBL) > (ALLOC1), so return. 
e1a9 c5			        PUSH    BC 
e1aa cd f7 e0		        CALL    CHECKSUM        ;else compute checksum. 
e1ad 2a bd e9		        LD      HL,(CHKVECT)    ;get address of checksum table. 
e1b0 eb			        EX      DE,HL 
e1b1 2a ec e9		        LD      HL,(CKSUMTBL) 
e1b4 19			        ADD     HL,DE           ;set (HL) to point to byte for this drive. 
e1b5 c1			        POP     BC 
e1b6 0c			        INC     C               ;set or check ? 
e1b7 ca c4 e1		        JP      Z,CHKDIR1 
e1ba be			        CP      (HL)            ;check them. 
e1bb c8			        RET     Z               ;return if they are the same. 
e1bc cd 7f e1		        CALL    MOREFLS         ;not the same, do we care? 
e1bf d0			        RET     NC 
e1c0 cd 2c e1		        CALL    WRTPRTD         ;yes, mark this as write protected. 
e1c3 c9			        RET      
e1c4 77			CHKDIR1:LD      (HL),A          ;just set the byte. 
e1c5 c9			        RET      
e1c6			; 
e1c6			;   Do a write to the directory of the current disk. 
e1c6			; 
e1c6 cd 9c e1		DIRWRITE: CALL  SETDIR          ;set checksum byte. 
e1c9 cd e0 e1		        CALL    DIRDMA          ;set directory dma address. 
e1cc 0e 01		        LD      C,1             ;tell the bios to actually write. 
e1ce cd b8 df		        CALL    DOWRITE         ;then do the write. 
e1d1 c3 da e1		        JP      DEFDMA 
e1d4			; 
e1d4			;   Read from the directory. 
e1d4			; 
e1d4 cd e0 e1		DIRREAD:CALL    DIRDMA          ;set the directory dma address. 
e1d7 cd b2 df		        CALL    DOREAD          ;and read it. 
e1da			; 
e1da			;   Routine to set the dma address to the users choice. 
e1da			; 
e1da 21 b1 e9		DEFDMA: LD      HL,USERDMA      ;reset the default dma address and return. 
e1dd c3 e3 e1		        JP      DIRDMA1 
e1e0			; 
e1e0			;   Routine to set the dma address for directory work. 
e1e0			; 
e1e0 21 b9 e9		DIRDMA: LD      HL,DIRBUF 
e1e3			; 
e1e3			;   Set the dma address. On entry, (HL) points to 
e1e3			; word containing the desired dma address. 
e1e3			; 
e1e3 4e			DIRDMA1:LD      C,(HL) 
e1e4 23			        INC     HL 
e1e5 46			        LD      B,(HL)          ;setup (BC) and go to the bios to set it. 
e1e6 c3 24 ea		        JP      SETDMA 
e1e9			; 
e1e9			;   Move the directory buffer into user's dma space. 
e1e9			; 
e1e9 2a b9 e9		MOVEDIR:LD      HL,(DIRBUF)     ;buffer is located here, and 
e1ec eb			        EX      DE,HL 
e1ed 2a b1 e9		        LD      HL,(USERDMA)    ; put it here. 
e1f0 0e 80		        LD      C,128           ;this is its length. 
e1f2 c3 4f df		        JP      DE2HL           ;move it now and return. 
e1f5			; 
e1f5			;   Check (FILEPOS) and set the zero flag if it equals 0ffffh. 
e1f5			; 
e1f5 21 ea e9		CKFILPOS: LD    HL,FILEPOS 
e1f8 7e			        LD      A,(HL) 
e1f9 23			        INC     HL 
e1fa be			        CP      (HL)            ;are both bytes the same? 
e1fb c0			        RET     NZ 
e1fc 3c			        INC     A               ;yes, but are they each 0ffh? 
e1fd c9			        RET      
e1fe			; 
e1fe			;   Set location (FILEPOS) to 0ffffh. 
e1fe			; 
e1fe 21 ff ff		STFILPOS: LD    HL,0FFFFH 
e201 22 ea e9		        LD      (FILEPOS),HL 
e204 c9			        RET      
e205			; 
e205			;   Move on to the next file position within the current 
e205			; directory buffer. If no more exist, set pointer to 0ffffh 
e205			; and the calling routine will check for this. Enter with (C) 
e205			; equal to 0ffh to cause the checksum byte to be set, else we 
e205			; will check this disk and set write protect if checksums are 
e205			; not the same (applies only if another directory sector must 
e205			; be read). 
e205			; 
e205 2a c8 e9		NXENTRY:LD      HL,(DIRSIZE)    ;get directory entry size limit. 
e208 eb			        EX      DE,HL 
e209 2a ea e9		        LD      HL,(FILEPOS)    ;get current count. 
e20c 23			        INC     HL              ;go on to the next one. 
e20d 22 ea e9		        LD      (FILEPOS),HL 
e210 cd 95 e1		        CALL    SUBHL           ;(HL)=(DIRSIZE)-(FILEPOS) 
e213 d2 19 e2		        JP      NC,NXENT1       ;is there more room left? 
e216 c3 fe e1		        JP      STFILPOS        ;no. Set this flag and return. 
e219 3a ea e9		NXENT1: LD      A,(FILEPOS)     ;get file position within directory. 
e21c e6 03		        AND     03H             ;only look within this sector (only 4 entries fit). 
e21e 06 05		        LD      B,5             ;convert to relative position (32 bytes each). 
e220 87			NXENT2: ADD     A,A             ;note that this is not efficient code. 
e221 05			        DEC     B               ;5 'ADD A's would be better. 
e222 c2 20 e2		        JP      NZ,NXENT2 
e225 32 e9 e9		        LD      (FCBPOS),A      ;save it as position of fcb. 
e228 b7			        OR      A 
e229 c0			        RET     NZ              ;return if we are within buffer. 
e22a c5			        PUSH    BC 
e22b cd c3 df		        CALL    TRKSEC          ;we need the next directory sector. 
e22e cd d4 e1		        CALL    DIRREAD 
e231 c1			        POP     BC 
e232 c3 9e e1		        JP      CHECKDIR 
e235			; 
e235			;   Routine to to get a bit from the disk space allocation 
e235			; map. It is returned in (A), bit position 0. On entry to here, 
e235			; set (BC) to the block number on the disk to check. 
e235			; On return, (D) will contain the original bit position for 
e235			; this block number and (HL) will point to the address for it. 
e235			; 
e235 79			CKBITMAP: LD    A,C             ;determine bit number of interest. 
e236 e6 07		        AND     07H             ;compute (D)=(E)=(C and 7)+1. 
e238 3c			        INC     A 
e239 5f			        LD      E,A             ;save particular bit number. 
e23a 57			        LD      D,A 
e23b			; 
e23b			;   compute (BC)=(BC)/8. 
e23b			; 
e23b 79			        LD      A,C 
e23c 0f			        RRCA                    ;now shift right 3 bits. 
e23d 0f			        RRCA     
e23e 0f			        RRCA     
e23f e6 1f		        AND     1FH             ;and clear bits 7,6,5. 
e241 4f			        LD      C,A 
e242 78			        LD      A,B 
e243 87			        ADD     A,A             ;now shift (B) into bits 7,6,5. 
e244 87			        ADD     A,A 
e245 87			        ADD     A,A 
e246 87			        ADD     A,A 
e247 87			        ADD     A,A 
e248 b1			        OR      C               ;and add in (C). 
e249 4f			        LD      C,A             ;ok, (C) ha been completed. 
e24a 78			        LD      A,B             ;is there a better way of doing this? 
e24b 0f			        RRCA     
e24c 0f			        RRCA     
e24d 0f			        RRCA     
e24e e6 1f		        AND     1FH 
e250 47			        LD      B,A             ;and now (B) is completed. 
e251			; 
e251			;   use this as an offset into the disk space allocation 
e251			; table. 
e251			; 
e251 2a bf e9		        LD      HL,(ALOCVECT) 
e254 09			        ADD     HL,BC 
e255 7e			        LD      A,(HL)          ;now get correct byte. 
e256 07			CKBMAP1:RLCA                    ;get correct bit into position 0. 
e257 1d			        DEC     E 
e258 c2 56 e2		        JP      NZ,CKBMAP1 
e25b c9			        RET      
e25c			; 
e25c			;   Set or clear the bit map such that block number (BC) will be marked 
e25c			; as used. On entry, if (E)=0 then this bit will be cleared, if it equals 
e25c			; 1 then it will be set (don't use anyother values). 
e25c			; 
e25c d5			STBITMAP: PUSH  DE 
e25d cd 35 e2		        CALL    CKBITMAP        ;get the byte of interest. 
e260 e6 fe		        AND     0FEH            ;clear the affected bit. 
e262 c1			        POP     BC 
e263 b1			        OR      C               ;and now set it acording to (C). 
e264			; 
e264			;  entry to restore the original bit position and then store 
e264			; in table. (A) contains the value, (D) contains the bit 
e264			; position (1-8), and (HL) points to the address within the 
e264			; space allocation table for this byte. 
e264			; 
e264 0f			STBMAP1:RRCA                    ;restore original bit position. 
e265 15			        DEC     D 
e266 c2 64 e2		        JP      NZ,STBMAP1 
e269 77			        LD      (HL),A          ;and stor byte in table. 
e26a c9			        RET      
e26b			; 
e26b			;   Set/clear space used bits in allocation map for this file. 
e26b			; On entry, (C)=1 to set the map and (C)=0 to clear it. 
e26b			; 
e26b cd 5e e1		SETFILE:CALL    FCB2HL          ;get address of fcb 
e26e 11 10 00		        LD      DE,16 
e271 19			        ADD     HL,DE           ;get to block number bytes. 
e272 c5			        PUSH    BC 
e273 0e 11		        LD      C,17            ;check all 17 bytes (max) of table. 
e275 d1			SETFL1: POP     DE 
e276 0d			        DEC     C               ;done all bytes yet? 
e277 c8			        RET     Z 
e278 d5			        PUSH    DE 
e279 3a dd e9		        LD      A,(BIGDISK)     ;check disk size for 16 bit block numbers. 
e27c b7			        OR      A 
e27d ca 88 e2		        JP      Z,SETFL2 
e280 c5			        PUSH    BC              ;only 8 bit numbers. set (BC) to this one. 
e281 e5			        PUSH    HL 
e282 4e			        LD      C,(HL)          ;get low byte from table, always 
e283 06 00		        LD      B,0             ;set high byte to zero. 
e285 c3 8e e2		        JP      SETFL3 
e288 0d			SETFL2: DEC     C               ;for 16 bit block numbers, adjust counter. 
e289 c5			        PUSH    BC 
e28a 4e			        LD      C,(HL)          ;now get both the low and high bytes. 
e28b 23			        INC     HL 
e28c 46			        LD      B,(HL) 
e28d e5			        PUSH    HL 
e28e 79			SETFL3: LD      A,C             ;block used? 
e28f b0			        OR      B 
e290 ca 9d e2		        JP      Z,SETFL4 
e293 2a c6 e9		        LD      HL,(DSKSIZE)    ;is this block number within the 
e296 7d			        LD      A,L             ;space on the disk? 
e297 91			        SUB     C 
e298 7c			        LD      A,H 
e299 98			        SBC     A,B 
e29a d4 5c e2		        CALL    NC,STBITMAP     ;yes, set the proper bit. 
e29d e1			SETFL4: POP     HL              ;point to next block number in fcb. 
e29e 23			        INC     HL 
e29f c1			        POP     BC 
e2a0 c3 75 e2		        JP      SETFL1 
e2a3			; 
e2a3			;   Construct the space used allocation bit map for the active 
e2a3			; drive. If a file name starts with '$' and it is under the 
e2a3			; current user number, then (STATUS) is set to minus 1. Otherwise 
e2a3			; it is not set at all. 
e2a3			; 
e2a3 2a c6 e9		BITMAP: LD      HL,(DSKSIZE)    ;compute size of allocation table. 
e2a6 0e 03		        LD      C,3 
e2a8 cd ea e0		        CALL    SHIFTR          ;(HL)=(HL)/8. 
e2ab 23			        INC     HL              ;at lease 1 byte. 
e2ac 44			        LD      B,H 
e2ad 4d			        LD      C,L             ;set (BC) to the allocation table length. 
e2ae			; 
e2ae			;   Initialize the bitmap for this drive. Right now, the first 
e2ae			; two bytes are specified by the disk parameter block. However 
e2ae			; a patch could be entered here if it were necessary to setup 
e2ae			; this table in a special mannor. For example, the bios could 
e2ae			; determine locations of 'bad blocks' and set them as already 
e2ae			; 'used' in the map. 
e2ae			; 
e2ae 2a bf e9		        LD      HL,(ALOCVECT)   ;now zero out the table now. 
e2b1 36 00		BITMAP1:LD      (HL),0 
e2b3 23			        INC     HL 
e2b4 0b			        DEC     BC 
e2b5 78			        LD      A,B 
e2b6 b1			        OR      C 
e2b7 c2 b1 e2		        JP      NZ,BITMAP1 
e2ba 2a ca e9		        LD      HL,(ALLOC0)     ;get initial space used by directory. 
e2bd eb			        EX      DE,HL 
e2be 2a bf e9		        LD      HL,(ALOCVECT)   ;and put this into map. 
e2c1 73			        LD      (HL),E 
e2c2 23			        INC     HL 
e2c3 72			        LD      (HL),D 
e2c4			; 
e2c4			;   End of initialization portion. 
e2c4			; 
e2c4 cd a1 df		        CALL    HOMEDRV         ;now home the drive. 
e2c7 2a b3 e9		        LD      HL,(SCRATCH1) 
e2ca 36 03		        LD      (HL),3          ;force next directory request to read 
e2cc 23			        INC     HL              ;in a sector. 
e2cd 36 00		        LD      (HL),0 
e2cf cd fe e1		        CALL    STFILPOS        ;clear initial file position also. 
e2d2 0e ff		BITMAP2:LD      C,0FFH          ;read next file name in directory 
e2d4 cd 05 e2		        CALL    NXENTRY         ;and set checksum byte. 
e2d7 cd f5 e1		        CALL    CKFILPOS        ;is there another file? 
e2da c8			        RET     Z 
e2db cd 5e e1		        CALL    FCB2HL          ;yes, get its address. 
e2de 3e e5		        LD      A,0E5H 
e2e0 be			        CP      (HL)            ;empty file entry? 
e2e1 ca d2 e2		        JP      Z,BITMAP2 
e2e4 3a 41 df		        LD      A,(USERNO)      ;no, correct user number? 
e2e7 be			        CP      (HL) 
e2e8 c2 f6 e2		        JP      NZ,BITMAP3 
e2eb 23			        INC     HL 
e2ec 7e			        LD      A,(HL)          ;yes, does name start with a '$'? 
e2ed d6 24		        SUB     '$' 
e2ef c2 f6 e2		        JP      NZ,BITMAP3 
e2f2 3d			        DEC     A               ;yes, set atatus to minus one. 
e2f3 32 45 df		        LD      (STATUS),A 
e2f6 0e 01		BITMAP3:LD      C,1             ;now set this file's space as used in bit map. 
e2f8 cd 6b e2		        CALL    SETFILE 
e2fb cd 8c e1		        CALL    CHKNMBR         ;keep (SCRATCH1) in bounds. 
e2fe c3 d2 e2		        JP      BITMAP2 
e301			; 
e301			;   Set the status (STATUS) and return. 
e301			; 
e301 3a d4 e9		STSTATUS: LD    A,(FNDSTAT) 
e304 c3 01 df		        JP      SETSTAT 
e307			; 
e307			;   Check extents in (A) and (C). Set the zero flag if they 
e307			; are the same. The number of 16k chunks of disk space that 
e307			; the directory extent covers is expressad is (EXTMASK+1). 
e307			; No registers are modified. 
e307			; 
e307 c5			SAMEXT: PUSH    BC 
e308 f5			        PUSH    AF 
e309 3a c5 e9		        LD      A,(EXTMASK)     ;get extent mask and use it to 
e30c 2f			        CPL                     ;to compare both extent numbers. 
e30d 47			        LD      B,A             ;save resulting mask here. 
e30e 79			        LD      A,C             ;mask first extent and save in (C). 
e30f a0			        AND     B 
e310 4f			        LD      C,A 
e311 f1			        POP     AF              ;now mask second extent and compare 
e312 a0			        AND     B               ;with the first one. 
e313 91			        SUB     C 
e314 e6 1f		        AND     1FH             ;(* only check buts 0-4 *) 
e316 c1			        POP     BC              ;the zero flag is set if they are the same. 
e317 c9			        RET                     ;restore (BC) and return. 
e318			; 
e318			;   Search for the first occurence of a file name. On entry, 
e318			; register (C) should contain the number of bytes of the fcb 
e318			; that must match. 
e318			; 
e318 3e ff		FINDFST:LD      A,0FFH 
e31a 32 d4 e9		        LD      (FNDSTAT),A 
e31d 21 d8 e9		        LD      HL,COUNTER      ;save character count. 
e320 71			        LD      (HL),C 
e321 2a 43 df		        LD      HL,(PARAMS)     ;get filename to match. 
e324 22 d9 e9		        LD      (SAVEFCB),HL    ;and save. 
e327 cd fe e1		        CALL    STFILPOS        ;clear initial file position (set to 0ffffh). 
e32a cd a1 df		        CALL    HOMEDRV         ;home the drive. 
e32d			; 
e32d			;   Entry to locate the next occurence of a filename within the 
e32d			; directory. The disk is not expected to have been changed. If 
e32d			; it was, then it will be write protected. 
e32d			; 
e32d 0e 00		FINDNXT:LD      C,0             ;write protect the disk if changed. 
e32f cd 05 e2		        CALL    NXENTRY         ;get next filename entry in directory. 
e332 cd f5 e1		        CALL    CKFILPOS        ;is file position = 0ffffh? 
e335 ca 94 e3		        JP      Z,FNDNXT6       ;yes, exit now then. 
e338 2a d9 e9		        LD      HL,(SAVEFCB)    ;set (DE) pointing to filename to match. 
e33b eb			        EX      DE,HL 
e33c 1a			        LD      A,(DE) 
e33d fe e5		        CP      0E5H            ;empty directory entry? 
e33f ca 4a e3		        JP      Z,FNDNXT1       ;(* are we trying to reserect erased entries? *) 
e342 d5			        PUSH    DE 
e343 cd 7f e1		        CALL    MOREFLS         ;more files in directory? 
e346 d1			        POP     DE 
e347 d2 94 e3		        JP      NC,FNDNXT6      ;no more. Exit now. 
e34a cd 5e e1		FNDNXT1:CALL    FCB2HL          ;get address of this fcb in directory. 
e34d 3a d8 e9		        LD      A,(COUNTER)     ;get number of bytes (characters) to check. 
e350 4f			        LD      C,A 
e351 06 00		        LD      B,0             ;initialize byte position counter. 
e353 79			FNDNXT2:LD      A,C             ;are we done with the compare? 
e354 b7			        OR      A 
e355 ca 83 e3		        JP      Z,FNDNXT5 
e358 1a			        LD      A,(DE)          ;no, check next byte. 
e359 fe 3f		        CP      '?'             ;don't care about this character? 
e35b ca 7c e3		        JP      Z,FNDNXT4 
e35e 78			        LD      A,B             ;get bytes position in fcb. 
e35f fe 0d		        CP      13              ;don't care about the thirteenth byte either. 
e361 ca 7c e3		        JP      Z,FNDNXT4 
e364 fe 0c		        CP      12              ;extent byte? 
e366 1a			        LD      A,(DE) 
e367 ca 73 e3		        JP      Z,FNDNXT3 
e36a 96			        SUB     (HL)            ;otherwise compare characters. 
e36b e6 7f		        AND     7FH 
e36d c2 2d e3		        JP      NZ,FINDNXT      ;not the same, check next entry. 
e370 c3 7c e3		        JP      FNDNXT4         ;so far so good, keep checking. 
e373 c5			FNDNXT3:PUSH    BC              ;check the extent byte here. 
e374 4e			        LD      C,(HL) 
e375 cd 07 e3		        CALL    SAMEXT 
e378 c1			        POP     BC 
e379 c2 2d e3		        JP      NZ,FINDNXT      ;not the same, look some more. 
e37c			; 
e37c			;   So far the names compare. Bump pointers to the next byte 
e37c			; and continue until all (C) characters have been checked. 
e37c			; 
e37c 13			FNDNXT4:INC     DE              ;bump pointers. 
e37d 23			        INC     HL 
e37e 04			        INC     B 
e37f 0d			        DEC     C               ;adjust character counter. 
e380 c3 53 e3		        JP      FNDNXT2 
e383 3a ea e9		FNDNXT5:LD      A,(FILEPOS)     ;return the position of this entry. 
e386 e6 03		        AND     03H 
e388 32 45 df		        LD      (STATUS),A 
e38b 21 d4 e9		        LD      HL,FNDSTAT 
e38e 7e			        LD      A,(HL) 
e38f 17			        RLA      
e390 d0			        RET     NC 
e391 af			        XOR     A 
e392 77			        LD      (HL),A 
e393 c9			        RET      
e394			; 
e394			;   Filename was not found. Set appropriate status. 
e394			; 
e394 cd fe e1		FNDNXT6:CALL    STFILPOS        ;set (FILEPOS) to 0ffffh. 
e397 3e ff		        LD      A,0FFH          ;say not located. 
e399 c3 01 df		        JP      SETSTAT 
e39c			; 
e39c			;   Erase files from the directory. Only the first byte of the 
e39c			; fcb will be affected. It is set to (E5). 
e39c			; 
e39c cd 54 e1		ERAFILE:CALL    CHKWPRT         ;is disk write protected? 
e39f 0e 0c		        LD      C,12            ;only compare file names. 
e3a1 cd 18 e3		        CALL    FINDFST         ;get first file name. 
e3a4 cd f5 e1		ERAFIL1:CALL    CKFILPOS        ;any found? 
e3a7 c8			        RET     Z               ;nope, we must be done. 
e3a8 cd 44 e1		        CALL    CHKROFL         ;is file read only? 
e3ab cd 5e e1		        CALL    FCB2HL          ;nope, get address of fcb and 
e3ae 36 e5		        LD      (HL),0E5H       ;set first byte to 'empty'. 
e3b0 0e 00		        LD      C,0             ;clear the space from the bit map. 
e3b2 cd 6b e2		        CALL    SETFILE 
e3b5 cd c6 e1		        CALL    DIRWRITE        ;now write the directory sector back out. 
e3b8 cd 2d e3		        CALL    FINDNXT         ;find the next file name. 
e3bb c3 a4 e3		        JP      ERAFIL1         ;and repeat process. 
e3be			; 
e3be			;   Look through the space allocation map (bit map) for the 
e3be			; next available block. Start searching at block number (BC-1). 
e3be			; The search procedure is to look for an empty block that is 
e3be			; before the starting block. If not empty, look at a later 
e3be			; block number. In this way, we return the closest empty block 
e3be			; on either side of the 'target' block number. This will speed 
e3be			; access on random devices. For serial devices, this should be 
e3be			; changed to look in the forward direction first and then start 
e3be			; at the front and search some more. 
e3be			; 
e3be			;   On return, (DE)= block number that is empty and (HL) =0 
e3be			; if no empry block was found. 
e3be			; 
e3be 50			FNDSPACE: LD    D,B             ;set (DE) as the block that is checked. 
e3bf 59			        LD      E,C 
e3c0			; 
e3c0			;   Look before target block. Registers (BC) are used as the lower 
e3c0			; pointer and (DE) as the upper pointer. 
e3c0			; 
e3c0 79			FNDSPA1:LD      A,C             ;is block 0 specified? 
e3c1 b0			        OR      B 
e3c2 ca d1 e3		        JP      Z,FNDSPA2 
e3c5 0b			        DEC     BC              ;nope, check previous block. 
e3c6 d5			        PUSH    DE 
e3c7 c5			        PUSH    BC 
e3c8 cd 35 e2		        CALL    CKBITMAP 
e3cb 1f			        RRA                     ;is this block empty? 
e3cc d2 ec e3		        JP      NC,FNDSPA3      ;yes. use this. 
e3cf			; 
e3cf			;   Note that the above logic gets the first block that it finds 
e3cf			; that is empty. Thus a file could be written 'backward' making 
e3cf			; it very slow to access. This could be changed to look for the 
e3cf			; first empty block and then continue until the start of this 
e3cf			; empty space is located and then used that starting block. 
e3cf			; This should help speed up access to some files especially on 
e3cf			; a well used disk with lots of fairly small 'holes'. 
e3cf			; 
e3cf c1			        POP     BC              ;nope, check some more. 
e3d0 d1			        POP     DE 
e3d1			; 
e3d1			;   Now look after target block. 
e3d1			; 
e3d1 2a c6 e9		FNDSPA2:LD      HL,(DSKSIZE)    ;is block (DE) within disk limits? 
e3d4 7b			        LD      A,E 
e3d5 95			        SUB     L 
e3d6 7a			        LD      A,D 
e3d7 9c			        SBC     A,H 
e3d8 d2 f4 e3		        JP      NC,FNDSPA4 
e3db 13			        INC     DE              ;yes, move on to next one. 
e3dc c5			        PUSH    BC 
e3dd d5			        PUSH    DE 
e3de 42			        LD      B,D 
e3df 4b			        LD      C,E 
e3e0 cd 35 e2		        CALL    CKBITMAP        ;check it. 
e3e3 1f			        RRA                     ;empty? 
e3e4 d2 ec e3		        JP      NC,FNDSPA3 
e3e7 d1			        POP     DE              ;nope, continue searching. 
e3e8 c1			        POP     BC 
e3e9 c3 c0 e3		        JP      FNDSPA1 
e3ec			; 
e3ec			;   Empty block found. Set it as used and return with (HL) 
e3ec			; pointing to it (true?). 
e3ec			; 
e3ec 17			FNDSPA3:RLA                     ;reset byte. 
e3ed 3c			        INC     A               ;and set bit 0. 
e3ee cd 64 e2		        CALL    STBMAP1         ;update bit map. 
e3f1 e1			        POP     HL              ;set return registers. 
e3f2 d1			        POP     DE 
e3f3 c9			        RET      
e3f4			; 
e3f4			;   Free block was not found. If (BC) is not zero, then we have 
e3f4			; not checked all of the disk space. 
e3f4			; 
e3f4 79			FNDSPA4:LD      A,C 
e3f5 b0			        OR      B 
e3f6 c2 c0 e3		        JP      NZ,FNDSPA1 
e3f9 21 00 00		        LD      HL,0            ;set 'not found' status. 
e3fc c9			        RET      
e3fd			; 
e3fd			;   Move a complete fcb entry into the directory and write it. 
e3fd			; 
e3fd 0e 00		FCBSET: LD      C,0 
e3ff 1e 20		        LD      E,32            ;length of each entry. 
e401			; 
e401			;   Move (E) bytes from the fcb pointed to by (PARAMS) into 
e401			; fcb in directory starting at relative byte (C). This updated 
e401			; directory buffer is then written to the disk. 
e401			; 
e401 d5			UPDATE: PUSH    DE 
e402 06 00		        LD      B,0             ;set (BC) to relative byte position. 
e404 2a 43 df		        LD      HL,(PARAMS)     ;get address of fcb. 
e407 09			        ADD     HL,BC           ;compute starting byte. 
e408 eb			        EX      DE,HL 
e409 cd 5e e1		        CALL    FCB2HL          ;get address of fcb to update in directory. 
e40c c1			        POP     BC              ;set (C) to number of bytes to change. 
e40d cd 4f df		        CALL    DE2HL 
e410 cd c3 df		UPDATE1:CALL    TRKSEC          ;determine the track and sector affected. 
e413 c3 c6 e1		        JP      DIRWRITE        ;then write this sector out. 
e416			; 
e416			;   Routine to change the name of all files on the disk with a 
e416			; specified name. The fcb contains the current name as the 
e416			; first 12 characters and the new name 16 bytes into the fcb. 
e416			; 
e416 cd 54 e1		CHGNAMES: CALL  CHKWPRT         ;check for a write protected disk. 
e419 0e 0c		        LD      C,12            ;match first 12 bytes of fcb only. 
e41b cd 18 e3		        CALL    FINDFST         ;get first name. 
e41e 2a 43 df		        LD      HL,(PARAMS)     ;get address of fcb. 
e421 7e			        LD      A,(HL)          ;get user number. 
e422 11 10 00		        LD      DE,16           ;move over to desired name. 
e425 19			        ADD     HL,DE 
e426 77			        LD      (HL),A          ;keep same user number. 
e427 cd f5 e1		CHGNAM1:CALL    CKFILPOS        ;any matching file found? 
e42a c8			        RET     Z               ;no, we must be done. 
e42b cd 44 e1		        CALL    CHKROFL         ;check for read only file. 
e42e 0e 10		        LD      C,16            ;start 16 bytes into fcb. 
e430 1e 0c		        LD      E,12            ;and update the first 12 bytes of directory. 
e432 cd 01 e4		        CALL    UPDATE 
e435 cd 2d e3		        CALL    FINDNXT         ;get te next file name. 
e438 c3 27 e4		        JP      CHGNAM1         ;and continue. 
e43b			; 
e43b			;   Update a files attributes. The procedure is to search for 
e43b			; every file with the same name as shown in fcb (ignoring bit 7) 
e43b			; and then to update it (which includes bit 7). No other changes 
e43b			; are made. 
e43b			; 
e43b 0e 0c		SAVEATTR: LD    C,12            ;match first 12 bytes. 
e43d cd 18 e3		        CALL    FINDFST         ;look for first filename. 
e440 cd f5 e1		SAVATR1:CALL    CKFILPOS        ;was one found? 
e443 c8			        RET     Z               ;nope, we must be done. 
e444 0e 00		        LD      C,0             ;yes, update the first 12 bytes now. 
e446 1e 0c		        LD      E,12 
e448 cd 01 e4		        CALL    UPDATE          ;update filename and write directory. 
e44b cd 2d e3		        CALL    FINDNXT         ;and get the next file. 
e44e c3 40 e4		        JP      SAVATR1         ;then continue until done. 
e451			; 
e451			;  Open a file (name specified in fcb). 
e451			; 
e451 0e 0f		OPENIT: LD      C,15            ;compare the first 15 bytes. 
e453 cd 18 e3		        CALL    FINDFST         ;get the first one in directory. 
e456 cd f5 e1		        CALL    CKFILPOS        ;any at all? 
e459 c8			        RET     Z 
e45a cd a6 e0		OPENIT1:CALL    SETEXT          ;point to extent byte within users fcb. 
e45d 7e			        LD      A,(HL)          ;and get it. 
e45e f5			        PUSH    AF              ;save it and address. 
e45f e5			        PUSH    HL 
e460 cd 5e e1		        CALL    FCB2HL          ;point to fcb in directory. 
e463 eb			        EX      DE,HL 
e464 2a 43 df		        LD      HL,(PARAMS)     ;this is the users copy. 
e467 0e 20		        LD      C,32            ;move it into users space. 
e469 d5			        PUSH    DE 
e46a cd 4f df		        CALL    DE2HL 
e46d cd 78 e1		        CALL    SETS2B7         ;set bit 7 in 's2' byte (unmodified). 
e470 d1			        POP     DE              ;now get the extent byte from this fcb. 
e471 21 0c 00		        LD      HL,12 
e474 19			        ADD     HL,DE 
e475 4e			        LD      C,(HL)          ;into (C). 
e476 21 0f 00		        LD      HL,15           ;now get the record count byte into (B). 
e479 19			        ADD     HL,DE 
e47a 46			        LD      B,(HL) 
e47b e1			        POP     HL              ;keep the same extent as the user had originally. 
e47c f1			        POP     AF 
e47d 77			        LD      (HL),A 
e47e 79			        LD      A,C             ;is it the same as in the directory fcb? 
e47f be			        CP      (HL) 
e480 78			        LD      A,B             ;if yes, then use the same record count. 
e481 ca 8b e4		        JP      Z,OPENIT2 
e484 3e 00		        LD      A,0             ;if the user specified an extent greater than 
e486 da 8b e4		        JP      C,OPENIT2       ;the one in the directory, then set record count to 0. 
e489 3e 80		        LD      A,128           ;otherwise set to maximum. 
e48b 2a 43 df		OPENIT2:LD      HL,(PARAMS)     ;set record count in users fcb to (A). 
e48e 11 0f 00		        LD      DE,15 
e491 19			        ADD     HL,DE           ;compute relative position. 
e492 77			        LD      (HL),A          ;and set the record count. 
e493 c9			        RET      
e494			; 
e494			;   Move two bytes from (DE) to (HL) if (and only if) (HL) 
e494			; point to a zero value (16 bit). 
e494			;   Return with zero flag set it (DE) was moved. Registers (DE) 
e494			; and (HL) are not changed. However (A) is. 
e494			; 
e494 7e			MOVEWORD: LD    A,(HL)          ;check for a zero word. 
e495 23			        INC     HL 
e496 b6			        OR      (HL)            ;both bytes zero? 
e497 2b			        DEC     HL 
e498 c0			        RET     NZ              ;nope, just return. 
e499 1a			        LD      A,(DE)          ;yes, move two bytes from (DE) into 
e49a 77			        LD      (HL),A          ;this zero space. 
e49b 13			        INC     DE 
e49c 23			        INC     HL 
e49d 1a			        LD      A,(DE) 
e49e 77			        LD      (HL),A 
e49f 1b			        DEC     DE              ;don't disturb these registers. 
e4a0 2b			        DEC     HL 
e4a1 c9			        RET      
e4a2			; 
e4a2			;   Get here to close a file specified by (fcb). 
e4a2			; 
e4a2 af			CLOSEIT:XOR     A               ;clear status and file position bytes. 
e4a3 32 45 df		        LD      (STATUS),A 
e4a6 32 ea e9		        LD      (FILEPOS),A 
e4a9 32 eb e9		        LD      (FILEPOS+1),A 
e4ac cd 1e e1		        CALL    GETWPRT         ;get write protect bit for this drive. 
e4af c0			        RET     NZ              ;just return if it is set. 
e4b0 cd 69 e1		        CALL    GETS2           ;else get the 's2' byte. 
e4b3 e6 80		        AND     80H             ;and look at bit 7 (file unmodified?). 
e4b5 c0			        RET     NZ              ;just return if set. 
e4b6 0e 0f		        LD      C,15            ;else look up this file in directory. 
e4b8 cd 18 e3		        CALL    FINDFST 
e4bb cd f5 e1		        CALL    CKFILPOS        ;was it found? 
e4be c8			        RET     Z               ;just return if not. 
e4bf 01 10 00		        LD      BC,16           ;set (HL) pointing to records used section. 
e4c2 cd 5e e1		        CALL    FCB2HL 
e4c5 09			        ADD     HL,BC 
e4c6 eb			        EX      DE,HL 
e4c7 2a 43 df		        LD      HL,(PARAMS)     ;do the same for users specified fcb. 
e4ca 09			        ADD     HL,BC 
e4cb 0e 10		        LD      C,16            ;this many bytes are present in this extent. 
e4cd 3a dd e9		CLOSEIT1: LD    A,(BIGDISK)     ;8 or 16 bit record numbers? 
e4d0 b7			        OR      A 
e4d1 ca e8 e4		        JP      Z,CLOSEIT4 
e4d4 7e			        LD      A,(HL)          ;just 8 bit. Get one from users fcb. 
e4d5 b7			        OR      A 
e4d6 1a			        LD      A,(DE)          ;now get one from directory fcb. 
e4d7 c2 db e4		        JP      NZ,CLOSEIT2 
e4da 77			        LD      (HL),A          ;users byte was zero. Update from directory. 
e4db b7			CLOSEIT2: OR    A 
e4dc c2 e1 e4		        JP      NZ,CLOSEIT3 
e4df 7e			        LD      A,(HL)          ;directories byte was zero, update from users fcb. 
e4e0 12			        LD      (DE),A 
e4e1 be			CLOSEIT3: CP    (HL)            ;if neither one of these bytes were zero, 
e4e2 c2 1f e5		        JP      NZ,CLOSEIT7     ;then close error if they are not the same. 
e4e5 c3 fd e4		        JP      CLOSEIT5        ;ok so far, get to next byte in fcbs. 
e4e8 cd 94 e4		CLOSEIT4: CALL  MOVEWORD        ;update users fcb if it is zero. 
e4eb eb			        EX      DE,HL 
e4ec cd 94 e4		        CALL    MOVEWORD        ;update directories fcb if it is zero. 
e4ef eb			        EX      DE,HL 
e4f0 1a			        LD      A,(DE)          ;if these two values are no different, 
e4f1 be			        CP      (HL)            ;then a close error occured. 
e4f2 c2 1f e5		        JP      NZ,CLOSEIT7 
e4f5 13			        INC     DE              ;check second byte. 
e4f6 23			        INC     HL 
e4f7 1a			        LD      A,(DE) 
e4f8 be			        CP      (HL) 
e4f9 c2 1f e5		        JP      NZ,CLOSEIT7 
e4fc 0d			        DEC     C               ;remember 16 bit values. 
e4fd 13			CLOSEIT5: INC   DE              ;bump to next item in table. 
e4fe 23			        INC     HL 
e4ff 0d			        DEC     C               ;there are 16 entries only. 
e500 c2 cd e4		        JP      NZ,CLOSEIT1     ;continue if more to do. 
e503 01 ec ff		        LD      BC,0FFECH       ;backup 20 places (extent byte). 
e506 09			        ADD     HL,BC 
e507 eb			        EX      DE,HL 
e508 09			        ADD     HL,BC 
e509 1a			        LD      A,(DE) 
e50a be			        CP      (HL)            ;directory's extent already greater than the 
e50b da 17 e5		        JP      C,CLOSEIT6      ;users extent? 
e50e 77			        LD      (HL),A          ;no, update directory extent. 
e50f 01 03 00		        LD      BC,3            ;and update the record count byte in 
e512 09			        ADD     HL,BC           ;directories fcb. 
e513 eb			        EX      DE,HL 
e514 09			        ADD     HL,BC 
e515 7e			        LD      A,(HL)          ;get from user. 
e516 12			        LD      (DE),A          ;and put in directory. 
e517 3e ff		CLOSEIT6: LD    A,0FFH          ;set 'was open and is now closed' byte. 
e519 32 d2 e9		        LD      (CLOSEFLG),A 
e51c c3 10 e4		        JP      UPDATE1         ;update the directory now. 
e51f 21 45 df		CLOSEIT7: LD    HL,STATUS       ;set return status and then return. 
e522 35			        DEC     (HL) 
e523 c9			        RET      
e524			; 
e524			;   Routine to get the next empty space in the directory. It 
e524			; will then be cleared for use. 
e524			; 
e524 cd 54 e1		GETEMPTY: CALL  CHKWPRT         ;make sure disk is not write protected. 
e527 2a 43 df		        LD      HL,(PARAMS)     ;save current parameters (fcb). 
e52a e5			        PUSH    HL 
e52b 21 ac e9		        LD      HL,EMPTYFCB     ;use special one for empty space. 
e52e 22 43 df		        LD      (PARAMS),HL 
e531 0e 01		        LD      C,1             ;search for first empty spot in directory. 
e533 cd 18 e3		        CALL    FINDFST         ;(* only check first byte *) 
e536 cd f5 e1		        CALL    CKFILPOS        ;none? 
e539 e1			        POP     HL 
e53a 22 43 df		        LD      (PARAMS),HL     ;restore original fcb address. 
e53d c8			        RET     Z               ;return if no more space. 
e53e eb			        EX      DE,HL 
e53f 21 0f 00		        LD      HL,15           ;point to number of records for this file. 
e542 19			        ADD     HL,DE 
e543 0e 11		        LD      C,17            ;and clear all of this space. 
e545 af			        XOR     A 
e546 77			GETMT1: LD      (HL),A 
e547 23			        INC     HL 
e548 0d			        DEC     C 
e549 c2 46 e5		        JP      NZ,GETMT1 
e54c 21 0d 00		        LD      HL,13           ;clear the 's1' byte also. 
e54f 19			        ADD     HL,DE 
e550 77			        LD      (HL),A 
e551 cd 8c e1		        CALL    CHKNMBR         ;keep (SCRATCH1) within bounds. 
e554 cd fd e3		        CALL    FCBSET          ;write out this fcb entry to directory. 
e557 c3 78 e1		        JP      SETS2B7         ;set 's2' byte bit 7 (unmodified at present). 
e55a			; 
e55a			;   Routine to close the current extent and open the next one 
e55a			; for reading. 
e55a			; 
e55a af			GETNEXT:XOR     A 
e55b 32 d2 e9		        LD      (CLOSEFLG),A    ;clear close flag. 
e55e cd a2 e4		        CALL    CLOSEIT         ;close this extent. 
e561 cd f5 e1		        CALL    CKFILPOS 
e564 c8			        RET     Z               ;not there??? 
e565 2a 43 df		        LD      HL,(PARAMS)     ;get extent byte. 
e568 01 0c 00		        LD      BC,12 
e56b 09			        ADD     HL,BC 
e56c 7e			        LD      A,(HL)          ;and increment it. 
e56d 3c			        INC     A 
e56e e6 1f		        AND     1FH             ;keep within range 0-31. 
e570 77			        LD      (HL),A 
e571 ca 83 e5		        JP      Z,GTNEXT1       ;overflow? 
e574 47			        LD      B,A             ;mask extent byte. 
e575 3a c5 e9		        LD      A,(EXTMASK) 
e578 a0			        AND     B 
e579 21 d2 e9		        LD      HL,CLOSEFLG     ;check close flag (0ffh is ok). 
e57c a6			        AND     (HL) 
e57d ca 8e e5		        JP      Z,GTNEXT2       ;if zero, we must read in next extent. 
e580 c3 ac e5		        JP      GTNEXT3         ;else, it is already in memory. 
e583 01 02 00		GTNEXT1:LD      BC,2            ;Point to the 's2' byte. 
e586 09			        ADD     HL,BC 
e587 34			        INC     (HL)            ;and bump it. 
e588 7e			        LD      A,(HL)          ;too many extents? 
e589 e6 0f		        AND     0FH 
e58b ca b6 e5		        JP      Z,GTNEXT5       ;yes, set error code. 
e58e			; 
e58e			;   Get here to open the next extent. 
e58e			; 
e58e 0e 0f		GTNEXT2:LD      C,15            ;set to check first 15 bytes of fcb. 
e590 cd 18 e3		        CALL    FINDFST         ;find the first one. 
e593 cd f5 e1		        CALL    CKFILPOS        ;none available? 
e596 c2 ac e5		        JP      NZ,GTNEXT3 
e599 3a d3 e9		        LD      A,(RDWRTFLG)    ;no extent present. Can we open an empty one? 
e59c 3c			        INC     A               ;0ffh means reading (so not possible). 
e59d ca b6 e5		        JP      Z,GTNEXT5       ;or an error. 
e5a0 cd 24 e5		        CALL    GETEMPTY        ;we are writing, get an empty entry. 
e5a3 cd f5 e1		        CALL    CKFILPOS        ;none? 
e5a6 ca b6 e5		        JP      Z,GTNEXT5       ;error if true. 
e5a9 c3 af e5		        JP      GTNEXT4         ;else we are almost done. 
e5ac cd 5a e4		GTNEXT3:CALL    OPENIT1         ;open this extent. 
e5af cd bb e0		GTNEXT4:CALL    STRDATA         ;move in updated data (rec #, extent #, etc.) 
e5b2 af			        XOR     A               ;clear status and return. 
e5b3 c3 01 df		        JP      SETSTAT 
e5b6			; 
e5b6			;   Error in extending the file. Too many extents were needed 
e5b6			; or not enough space on the disk. 
e5b6			; 
e5b6 cd 05 df		GTNEXT5:CALL    IOERR1          ;set error code, clear bit 7 of 's2' 
e5b9 c3 78 e1		        JP      SETS2B7         ;so this is not written on a close. 
e5bc			; 
e5bc			;   Read a sequential file. 
e5bc			; 
e5bc 3e 01		RDSEQ:  LD      A,1             ;set sequential access mode. 
e5be 32 d5 e9		        LD      (MODE),A 
e5c1 3e ff		RDSEQ1: LD      A,0FFH          ;don't allow reading unwritten space. 
e5c3 32 d3 e9		        LD      (RDWRTFLG),A 
e5c6 cd bb e0		        CALL    STRDATA         ;put rec# and ext# into fcb. 
e5c9 3a e3 e9		        LD      A,(SAVNREC)     ;get next record to read. 
e5cc 21 e1 e9		        LD      HL,SAVNXT       ;get number of records in extent. 
e5cf be			        CP      (HL)            ;within this extent? 
e5d0 da e6 e5		        JP      C,RDSEQ2 
e5d3 fe 80		        CP      128             ;no. Is this extent fully used? 
e5d5 c2 fb e5		        JP      NZ,RDSEQ3       ;no. End-of-file. 
e5d8 cd 5a e5		        CALL    GETNEXT         ;yes, open the next one. 
e5db af			        XOR     A               ;reset next record to read. 
e5dc 32 e3 e9		        LD      (SAVNREC),A 
e5df 3a 45 df		        LD      A,(STATUS)      ;check on open, successful? 
e5e2 b7			        OR      A 
e5e3 c2 fb e5		        JP      NZ,RDSEQ3       ;no, error. 
e5e6 cd 77 e0		RDSEQ2: CALL    COMBLK          ;ok. compute block number to read. 
e5e9 cd 84 e0		        CALL    CHKBLK          ;check it. Within bounds? 
e5ec ca fb e5		        JP      Z,RDSEQ3        ;no, error. 
e5ef cd 8a e0		        CALL    LOGICAL         ;convert (BLKNMBR) to logical sector (128 byte). 
e5f2 cd d1 df		        CALL    TRKSEC1         ;set the track and sector for this block #. 
e5f5 cd b2 df		        CALL    DOREAD          ;and read it. 
e5f8 c3 d2 e0		        JP      SETNREC         ;and set the next record to be accessed. 
e5fb			; 
e5fb			;   Read error occured. Set status and return. 
e5fb			; 
e5fb c3 05 df		RDSEQ3: JP      IOERR1 
e5fe			; 
e5fe			;   Write the next sequential record. 
e5fe			; 
e5fe 3e 01		WTSEQ:  LD      A,1             ;set sequential access mode. 
e600 32 d5 e9		        LD      (MODE),A 
e603 3e 00		WTSEQ1: LD      A,0             ;allow an addition empty extent to be opened. 
e605 32 d3 e9		        LD      (RDWRTFLG),A 
e608 cd 54 e1		        CALL    CHKWPRT         ;check write protect status. 
e60b 2a 43 df		        LD      HL,(PARAMS) 
e60e cd 47 e1		        CALL    CKROF1          ;check for read only file, (HL) already set to fcb. 
e611 cd bb e0		        CALL    STRDATA         ;put updated data into fcb. 
e614 3a e3 e9		        LD      A,(SAVNREC)     ;get record number to write. 
e617 fe 80		        CP      128             ;within range? 
e619 d2 05 df		        JP      NC,IOERR1       ;no, error(?). 
e61c cd 77 e0		        CALL    COMBLK          ;compute block number. 
e61f cd 84 e0		        CALL    CHKBLK          ;check number. 
e622 0e 00		        LD      C,0             ;is there one to write to? 
e624 c2 6e e6		        JP      NZ,WTSEQ6       ;yes, go do it. 
e627 cd 3e e0		        CALL    GETBLOCK        ;get next block number within fcb to use. 
e62a 32 d7 e9		        LD      (RELBLOCK),A    ;and save. 
e62d 01 00 00		        LD      BC,0            ;start looking for space from the start 
e630 b7			        OR      A               ;if none allocated as yet. 
e631 ca 3b e6		        JP      Z,WTSEQ2 
e634 4f			        LD      C,A             ;extract previous block number from fcb 
e635 0b			        DEC     BC              ;so we can be closest to it. 
e636 cd 5e e0		        CALL    EXTBLK 
e639 44			        LD      B,H 
e63a 4d			        LD      C,L 
e63b cd be e3		WTSEQ2: CALL    FNDSPACE        ;find the next empty block nearest number (BC). 
e63e 7d			        LD      A,L             ;check for a zero number. 
e63f b4			        OR      H 
e640 c2 48 e6		        JP      NZ,WTSEQ3 
e643 3e 02		        LD      A,2             ;no more space? 
e645 c3 01 df		        JP      SETSTAT 
e648 22 e5 e9		WTSEQ3: LD      (BLKNMBR),HL    ;save block number to access. 
e64b eb			        EX      DE,HL           ;put block number into (DE). 
e64c 2a 43 df		        LD      HL,(PARAMS)     ;now we must update the fcb for this 
e64f 01 10 00		        LD      BC,16           ;newly allocated block. 
e652 09			        ADD     HL,BC 
e653 3a dd e9		        LD      A,(BIGDISK)     ;8 or 16 bit block numbers? 
e656 b7			        OR      A 
e657 3a d7 e9		        LD      A,(RELBLOCK)    ;(* update this entry *) 
e65a ca 64 e6		        JP      Z,WTSEQ4        ;zero means 16 bit ones. 
e65d cd 64 e1		        CALL    ADDA2HL         ;(HL)=(HL)+(A) 
e660 73			        LD      (HL),E          ;store new block number. 
e661 c3 6c e6		        JP      WTSEQ5 
e664 4f			WTSEQ4: LD      C,A             ;compute spot in this 16 bit table. 
e665 06 00		        LD      B,0 
e667 09			        ADD     HL,BC 
e668 09			        ADD     HL,BC 
e669 73			        LD      (HL),E          ;stuff block number (DE) there. 
e66a 23			        INC     HL 
e66b 72			        LD      (HL),D 
e66c 0e 02		WTSEQ5: LD      C,2             ;set (C) to indicate writing to un-used disk space. 
e66e 3a 45 df		WTSEQ6: LD      A,(STATUS)      ;are we ok so far? 
e671 b7			        OR      A 
e672 c0			        RET     NZ 
e673 c5			        PUSH    BC              ;yes, save write flag for bios (register C). 
e674 cd 8a e0		        CALL    LOGICAL         ;convert (BLKNMBR) over to loical sectors. 
e677 3a d5 e9		        LD      A,(MODE)        ;get access mode flag (1=sequential, 
e67a 3d			        DEC     A               ;0=random, 2=special?). 
e67b 3d			        DEC     A 
e67c c2 bb e6		        JP      NZ,WTSEQ9 
e67f			; 
e67f			;   Special random i/o from function #40. Maybe for M/PM, but the 
e67f			; current block, if it has not been written to, will be zeroed 
e67f			; out and then written (reason?). 
e67f			; 
e67f c1			        POP     BC 
e680 c5			        PUSH    BC 
e681 79			        LD      A,C             ;get write status flag (2=writing unused space). 
e682 3d			        DEC     A 
e683 3d			        DEC     A 
e684 c2 bb e6		        JP      NZ,WTSEQ9 
e687 e5			        PUSH    HL 
e688 2a b9 e9		        LD      HL,(DIRBUF)     ;zero out the directory buffer. 
e68b 57			        LD      D,A             ;note that (A) is zero here. 
e68c 77			WTSEQ7: LD      (HL),A 
e68d 23			        INC     HL 
e68e 14			        INC     D               ;do 128 bytes. 
e68f f2 8c e6		        JP      P,WTSEQ7 
e692 cd e0 e1		        CALL    DIRDMA          ;tell the bios the dma address for directory access. 
e695 2a e7 e9		        LD      HL,(LOGSECT)    ;get sector that starts current block. 
e698 0e 02		        LD      C,2             ;set 'writing to unused space' flag. 
e69a 22 e5 e9		WTSEQ8: LD      (BLKNMBR),HL    ;save sector to write. 
e69d c5			        PUSH    BC 
e69e cd d1 df		        CALL    TRKSEC1         ;determine its track and sector numbers. 
e6a1 c1			        POP     BC 
e6a2 cd b8 df		        CALL    DOWRITE         ;now write out 128 bytes of zeros. 
e6a5 2a e5 e9		        LD      HL,(BLKNMBR)    ;get sector number. 
e6a8 0e 00		        LD      C,0             ;set normal write flag. 
e6aa 3a c4 e9		        LD      A,(BLKMASK)     ;determine if we have written the entire 
e6ad 47			        LD      B,A             ;physical block. 
e6ae a5			        AND     L 
e6af b8			        CP      B 
e6b0 23			        INC     HL              ;prepare for the next one. 
e6b1 c2 9a e6		        JP      NZ,WTSEQ8       ;continue until (BLKMASK+1) sectors written. 
e6b4 e1			        POP     HL              ;reset next sector number. 
e6b5 22 e5 e9		        LD      (BLKNMBR),HL 
e6b8 cd da e1		        CALL    DEFDMA          ;and reset dma address. 
e6bb			; 
e6bb			;   Normal disk write. Set the desired track and sector then 
e6bb			; do the actual write. 
e6bb			; 
e6bb cd d1 df		WTSEQ9: CALL    TRKSEC1         ;determine track and sector for this write. 
e6be c1			        POP     BC              ;get write status flag. 
e6bf c5			        PUSH    BC 
e6c0 cd b8 df		        CALL    DOWRITE         ;and write this out. 
e6c3 c1			        POP     BC 
e6c4 3a e3 e9		        LD      A,(SAVNREC)     ;get number of records in file. 
e6c7 21 e1 e9		        LD      HL,SAVNXT       ;get last record written. 
e6ca be			        CP      (HL) 
e6cb da d2 e6		        JP      C,WTSEQ10 
e6ce 77			        LD      (HL),A          ;we have to update record count. 
e6cf 34			        INC     (HL) 
e6d0 0e 02		        LD      C,2 
e6d2			; 
e6d2			;*   This area has been patched to correct disk update problem 
e6d2			;* when using blocking and de-blocking in the BIOS. 
e6d2			; 
e6d2 00			WTSEQ10:NOP                     ;was 'dcr c' 
e6d3 00			        NOP                     ;was 'dcr c' 
e6d4 21 00 00		        LD      HL,0            ;was 'jnz wtseq99' 
e6d7			; 
e6d7			; *   End of patch. 
e6d7			; 
e6d7 f5			        PUSH    AF 
e6d8 cd 69 e1		        CALL    GETS2           ;set 'extent written to' flag. 
e6db e6 7f		        AND     7FH             ;(* clear bit 7 *) 
e6dd 77			        LD      (HL),A 
e6de f1			        POP     AF              ;get record count for this extent. 
e6df fe 7f		WTSEQ99:CP      127             ;is it full? 
e6e1 c2 00 e7		        JP      NZ,WTSEQ12 
e6e4 3a d5 e9		        LD      A,(MODE)        ;yes, are we in sequential mode? 
e6e7 fe 01		        CP      1 
e6e9 c2 00 e7		        JP      NZ,WTSEQ12 
e6ec cd d2 e0		        CALL    SETNREC         ;yes, set next record number. 
e6ef cd 5a e5		        CALL    GETNEXT         ;and get next empty space in directory. 
e6f2 21 45 df		        LD      HL,STATUS       ;ok? 
e6f5 7e			        LD      A,(HL) 
e6f6 b7			        OR      A 
e6f7 c2 fe e6		        JP      NZ,WTSEQ11 
e6fa 3d			        DEC     A               ;yes, set record count to -1. 
e6fb 32 e3 e9		        LD      (SAVNREC),A 
e6fe 36 00		WTSEQ11:LD      (HL),0          ;clear status. 
e700 c3 d2 e0		WTSEQ12:JP      SETNREC         ;set next record to access. 
e703			; 
e703			;   For random i/o, set the fcb for the desired record number 
e703			; based on the 'r0,r1,r2' bytes. These bytes in the fcb are 
e703			; used as follows: 
e703			; 
e703			;       fcb+35            fcb+34            fcb+33 
e703			;  |     'r-2'      |      'r-1'      |      'r-0'     | 
e703			;  |7             0 | 7             0 | 7             0| 
e703			;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0| 
e703			;  |    overflow   | | extra |  extent   |   record #  | 
e703			;  | ______________| |_extent|__number___|_____________| 
e703			;                     also 's2' 
e703			; 
e703			;   On entry, register (C) contains 0ffh if this is a read 
e703			; and thus we can not access unwritten disk space. Otherwise, 
e703			; another extent will be opened (for writing) if required. 
e703			; 
e703 af			POSITION: XOR   A               ;set random i/o flag. 
e704 32 d5 e9		        LD      (MODE),A 
e707			; 
e707			;   Special entry (function #40). M/PM ? 
e707			; 
e707 c5			POSITN1:PUSH    BC              ;save read/write flag. 
e708 2a 43 df		        LD      HL,(PARAMS)     ;get address of fcb. 
e70b eb			        EX      DE,HL 
e70c 21 21 00		        LD      HL,33           ;now get byte 'r0'. 
e70f 19			        ADD     HL,DE 
e710 7e			        LD      A,(HL) 
e711 e6 7f		        AND     7FH             ;keep bits 0-6 for the record number to access. 
e713 f5			        PUSH    AF 
e714 7e			        LD      A,(HL)          ;now get bit 7 of 'r0' and bits 0-3 of 'r1'. 
e715 17			        RLA      
e716 23			        INC     HL 
e717 7e			        LD      A,(HL) 
e718 17			        RLA      
e719 e6 1f		        AND     1FH             ;and save this in bits 0-4 of (C). 
e71b 4f			        LD      C,A             ;this is the extent byte. 
e71c 7e			        LD      A,(HL)          ;now get the extra extent byte. 
e71d 1f			        RRA      
e71e 1f			        RRA      
e71f 1f			        RRA      
e720 1f			        RRA      
e721 e6 0f		        AND     0FH 
e723 47			        LD      B,A             ;and save it in (B). 
e724 f1			        POP     AF              ;get record number back to (A). 
e725 23			        INC     HL              ;check overflow byte 'r2'. 
e726 6e			        LD      L,(HL) 
e727 2c			        INC     L 
e728 2d			        DEC     L 
e729 2e 06		        LD      L,6             ;prepare for error. 
e72b c2 8b e7		        JP      NZ,POSITN5      ;out of disk space error. 
e72e 21 20 00		        LD      HL,32           ;store record number into fcb. 
e731 19			        ADD     HL,DE 
e732 77			        LD      (HL),A 
e733 21 0c 00		        LD      HL,12           ;and now check the extent byte. 
e736 19			        ADD     HL,DE 
e737 79			        LD      A,C 
e738 96			        SUB     (HL)            ;same extent as before? 
e739 c2 47 e7		        JP      NZ,POSITN2 
e73c 21 0e 00		        LD      HL,14           ;yes, check extra extent byte 's2' also. 
e73f 19			        ADD     HL,DE 
e740 78			        LD      A,B 
e741 96			        SUB     (HL) 
e742 e6 7f		        AND     7FH 
e744 ca 7f e7		        JP      Z,POSITN3       ;same, we are almost done then. 
e747			; 
e747			;  Get here when another extent is required. 
e747			; 
e747 c5			POSITN2:PUSH    BC 
e748 d5			        PUSH    DE 
e749 cd a2 e4		        CALL    CLOSEIT         ;close current extent. 
e74c d1			        POP     DE 
e74d c1			        POP     BC 
e74e 2e 03		        LD      L,3             ;prepare for error. 
e750 3a 45 df		        LD      A,(STATUS) 
e753 3c			        INC     A 
e754 ca 84 e7		        JP      Z,POSITN4       ;close error. 
e757 21 0c 00		        LD      HL,12           ;put desired extent into fcb now. 
e75a 19			        ADD     HL,DE 
e75b 71			        LD      (HL),C 
e75c 21 0e 00		        LD      HL,14           ;and store extra extent byte 's2'. 
e75f 19			        ADD     HL,DE 
e760 70			        LD      (HL),B 
e761 cd 51 e4		        CALL    OPENIT          ;try and get this extent. 
e764 3a 45 df		        LD      A,(STATUS)      ;was it there? 
e767 3c			        INC     A 
e768 c2 7f e7		        JP      NZ,POSITN3 
e76b c1			        POP     BC              ;no. can we create a new one (writing?). 
e76c c5			        PUSH    BC 
e76d 2e 04		        LD      L,4             ;prepare for error. 
e76f 0c			        INC     C 
e770 ca 84 e7		        JP      Z,POSITN4       ;nope, reading unwritten space error. 
e773 cd 24 e5		        CALL    GETEMPTY        ;yes we can, try to find space. 
e776 2e 05		        LD      L,5             ;prepare for error. 
e778 3a 45 df		        LD      A,(STATUS) 
e77b 3c			        INC     A 
e77c ca 84 e7		        JP      Z,POSITN4       ;out of space? 
e77f			; 
e77f			;   Normal return location. Clear error code and return. 
e77f			; 
e77f c1			POSITN3:POP     BC              ;restore stack. 
e780 af			        XOR     A               ;and clear error code byte. 
e781 c3 01 df		        JP      SETSTAT 
e784			; 
e784			;   Error. Set the 's2' byte to indicate this (why?). 
e784			; 
e784 e5			POSITN4:PUSH    HL 
e785 cd 69 e1		        CALL    GETS2 
e788 36 c0		        LD      (HL),0C0H 
e78a e1			        POP     HL 
e78b			; 
e78b			;   Return with error code (presently in L). 
e78b			; 
e78b c1			POSITN5:POP     BC 
e78c 7d			        LD      A,L             ;get error code. 
e78d 32 45 df		        LD      (STATUS),A 
e790 c3 78 e1		        JP      SETS2B7 
e793			; 
e793			;   Read a random record. 
e793			; 
e793 0e ff		READRAN:LD      C,0FFH          ;set 'read' status. 
e795 cd 03 e7		        CALL    POSITION        ;position the file to proper record. 
e798 cc c1 e5		        CALL    Z,RDSEQ1        ;and read it as usual (if no errors). 
e79b c9			        RET      
e79c			; 
e79c			;   Write to a random record. 
e79c			; 
e79c 0e 00		WRITERAN: LD    C,0             ;set 'writing' flag. 
e79e cd 03 e7		        CALL    POSITION        ;position the file to proper record. 
e7a1 cc 03 e6		        CALL    Z,WTSEQ1        ;and write as usual (if no errors). 
e7a4 c9			        RET      
e7a5			; 
e7a5			;   Compute the random record number. Enter with (HL) pointing 
e7a5			; to a fcb an (DE) contains a relative location of a record 
e7a5			; number. On exit, (C) contains the 'r0' byte, (B) the 'r1' 
e7a5			; byte, and (A) the 'r2' byte. 
e7a5			; 
e7a5			;   On return, the zero flag is set if the record is within 
e7a5			; bounds. Otherwise, an overflow occured. 
e7a5			; 
e7a5 eb			COMPRAND: EX    DE,HL           ;save fcb pointer in (DE). 
e7a6 19			        ADD     HL,DE           ;compute relative position of record #. 
e7a7 4e			        LD      C,(HL)          ;get record number into (BC). 
e7a8 06 00		        LD      B,0 
e7aa 21 0c 00		        LD      HL,12           ;now get extent. 
e7ad 19			        ADD     HL,DE 
e7ae 7e			        LD      A,(HL)          ;compute (BC)=(record #)+(extent)*128. 
e7af 0f			        RRCA                    ;move lower bit into bit 7. 
e7b0 e6 80		        AND     80H             ;and ignore all other bits. 
e7b2 81			        ADD     A,C             ;add to our record number. 
e7b3 4f			        LD      C,A 
e7b4 3e 00		        LD      A,0             ;take care of any carry. 
e7b6 88			        ADC     A,B 
e7b7 47			        LD      B,A 
e7b8 7e			        LD      A,(HL)          ;now get the upper bits of extent into 
e7b9 0f			        RRCA                    ;bit positions 0-3. 
e7ba e6 0f		        AND     0FH             ;and ignore all others. 
e7bc 80			        ADD     A,B             ;add this in to 'r1' byte. 
e7bd 47			        LD      B,A 
e7be 21 0e 00		        LD      HL,14           ;get the 's2' byte (extra extent). 
e7c1 19			        ADD     HL,DE 
e7c2 7e			        LD      A,(HL) 
e7c3 87			        ADD     A,A             ;and shift it left 4 bits (bits 4-7). 
e7c4 87			        ADD     A,A 
e7c5 87			        ADD     A,A 
e7c6 87			        ADD     A,A 
e7c7 f5			        PUSH    AF              ;save carry flag (bit 0 of flag byte). 
e7c8 80			        ADD     A,B             ;now add extra extent into 'r1'. 
e7c9 47			        LD      B,A 
e7ca f5			        PUSH    AF              ;and save carry (overflow byte 'r2'). 
e7cb e1			        POP     HL              ;bit 0 of (L) is the overflow indicator. 
e7cc 7d			        LD      A,L 
e7cd e1			        POP     HL              ;and same for first carry flag. 
e7ce b5			        OR      L               ;either one of these set? 
e7cf e6 01		        AND     01H             ;only check the carry flags. 
e7d1 c9			        RET      
e7d2			; 
e7d2			;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to 
e7d2			; reflect the last record used for a random (or other) file. 
e7d2			; This reads the directory and looks at all extents computing 
e7d2			; the largerst record number for each and keeping the maximum 
e7d2			; value only. Then 'r0', 'r1', and 'r2' will reflect this 
e7d2			; maximum record number. This is used to compute the space used 
e7d2			; by a random file. 
e7d2			; 
e7d2 0e 0c		RANSIZE:LD      C,12            ;look thru directory for first entry with 
e7d4 cd 18 e3		        CALL    FINDFST         ;this name. 
e7d7 2a 43 df		        LD      HL,(PARAMS)     ;zero out the 'r0, r1, r2' bytes. 
e7da 11 21 00		        LD      DE,33 
e7dd 19			        ADD     HL,DE 
e7de e5			        PUSH    HL 
e7df 72			        LD      (HL),D          ;note that (D)=0. 
e7e0 23			        INC     HL 
e7e1 72			        LD      (HL),D 
e7e2 23			        INC     HL 
e7e3 72			        LD      (HL),D 
e7e4 cd f5 e1		RANSIZ1:CALL    CKFILPOS        ;is there an extent to process? 
e7e7 ca 0c e8		        JP      Z,RANSIZ3       ;no, we are done. 
e7ea cd 5e e1		        CALL    FCB2HL          ;set (HL) pointing to proper fcb in dir. 
e7ed 11 0f 00		        LD      DE,15           ;point to last record in extent. 
e7f0 cd a5 e7		        CALL    COMPRAND        ;and compute random parameters. 
e7f3 e1			        POP     HL 
e7f4 e5			        PUSH    HL              ;now check these values against those 
e7f5 5f			        LD      E,A             ;already in fcb. 
e7f6 79			        LD      A,C             ;the carry flag will be set if those 
e7f7 96			        SUB     (HL)            ;in the fcb represent a larger size than 
e7f8 23			        INC     HL              ;this extent does. 
e7f9 78			        LD      A,B 
e7fa 9e			        SBC     A,(HL) 
e7fb 23			        INC     HL 
e7fc 7b			        LD      A,E 
e7fd 9e			        SBC     A,(HL) 
e7fe da 06 e8		        JP      C,RANSIZ2 
e801 73			        LD      (HL),E          ;we found a larger (in size) extent. 
e802 2b			        DEC     HL              ;stuff these values into fcb. 
e803 70			        LD      (HL),B 
e804 2b			        DEC     HL 
e805 71			        LD      (HL),C 
e806 cd 2d e3		RANSIZ2:CALL    FINDNXT         ;now get the next extent. 
e809 c3 e4 e7		        JP      RANSIZ1         ;continue til all done. 
e80c e1			RANSIZ3:POP     HL              ;we are done, restore the stack and 
e80d c9			        RET                     ;return. 
e80e			; 
e80e			;   Function to return the random record position of a given 
e80e			; file which has been read in sequential mode up to now. 
e80e			; 
e80e 2a 43 df		SETRAN: LD      HL,(PARAMS)     ;point to fcb. 
e811 11 20 00		        LD      DE,32           ;and to last used record. 
e814 cd a5 e7		        CALL    COMPRAND        ;compute random position. 
e817 21 21 00		        LD      HL,33           ;now stuff these values into fcb. 
e81a 19			        ADD     HL,DE 
e81b 71			        LD      (HL),C          ;move 'r0'. 
e81c 23			        INC     HL 
e81d 70			        LD      (HL),B          ;and 'r1'. 
e81e 23			        INC     HL 
e81f 77			        LD      (HL),A          ;and lastly 'r2'. 
e820 c9			        RET      
e821			; 
e821			;   This routine select the drive specified in (ACTIVE) and 
e821			; update the login vector and bitmap table if this drive was 
e821			; not already active. 
e821			; 
e821 2a af e9		LOGINDRV: LD    HL,(LOGIN)      ;get the login vector. 
e824 3a 42 df		        LD      A,(ACTIVE)      ;get the default drive. 
e827 4f			        LD      C,A 
e828 cd ea e0		        CALL    SHIFTR          ;position active bit for this drive 
e82b e5			        PUSH    HL              ;into bit 0. 
e82c eb			        EX      DE,HL 
e82d cd 59 df		        CALL    SELECT          ;select this drive. 
e830 e1			        POP     HL 
e831 cc 47 df		        CALL    Z,SLCTERR       ;valid drive? 
e834 7d			        LD      A,L             ;is this a newly activated drive? 
e835 1f			        RRA      
e836 d8			        RET     C 
e837 2a af e9		        LD      HL,(LOGIN)      ;yes, update the login vector. 
e83a 4d			        LD      C,L 
e83b 44			        LD      B,H 
e83c cd 0b e1		        CALL    SETBIT 
e83f 22 af e9		        LD      (LOGIN),HL      ;and save. 
e842 c3 a3 e2		        JP      BITMAP          ;now update the bitmap. 
e845			; 
e845			;   Function to set the active disk number. 
e845			; 
e845 3a d6 e9		SETDSK: LD      A,(EPARAM)      ;get parameter passed and see if this 
e848 21 42 df		        LD      HL,ACTIVE       ;represents a change in drives. 
e84b be			        CP      (HL) 
e84c c8			        RET     Z 
e84d 77			        LD      (HL),A          ;yes it does, log it in. 
e84e c3 21 e8		        JP      LOGINDRV 
e851			; 
e851			;   This is the 'auto disk select' routine. The firsst byte 
e851			; of the fcb is examined for a drive specification. If non 
e851			; zero then the drive will be selected and loged in. 
e851			; 
e851 3e ff		AUTOSEL:LD      A,0FFH          ;say 'auto-select activated'. 
e853 32 de e9		        LD      (AUTO),A 
e856 2a 43 df		        LD      HL,(PARAMS)     ;get drive specified. 
e859 7e			        LD      A,(HL) 
e85a e6 1f		        AND     1FH             ;look at lower 5 bits. 
e85c 3d			        DEC     A               ;adjust for (1=A, 2=B) etc. 
e85d 32 d6 e9		        LD      (EPARAM),A      ;and save for the select routine. 
e860 fe 1e		        CP      1EH             ;check for 'no change' condition. 
e862 d2 75 e8		        JP      NC,AUTOSL1      ;yes, don't change. 
e865 3a 42 df		        LD      A,(ACTIVE)      ;we must change, save currently active 
e868 32 df e9		        LD      (OLDDRV),A      ;drive. 
e86b 7e			        LD      A,(HL)          ;and save first byte of fcb also. 
e86c 32 e0 e9		        LD      (AUTOFLAG),A    ;this must be non-zero. 
e86f e6 e0		        AND     0E0H            ;whats this for (bits 6,7 are used for 
e871 77			        LD      (HL),A          ;something)? 
e872 cd 45 e8		        CALL    SETDSK          ;select and log in this drive. 
e875 3a 41 df		AUTOSL1:LD      A,(USERNO)      ;move user number into fcb. 
e878 2a 43 df		        LD      HL,(PARAMS)     ;(* upper half of first byte *) 
e87b b6			        OR      (HL) 
e87c 77			        LD      (HL),A 
e87d c9			        RET                     ;and return (all done). 
e87e			; 
e87e			;   Function to return the current cp/m version number. 
e87e			; 
e87e 3e 22		GETVER: LD      A,022H          ;version 2.2 
e880 c3 01 df		        JP      SETSTAT 
e883			; 
e883			;   Function to reset the disk system. 
e883			; 
e883 21 00 00		RSTDSK: LD      HL,0            ;clear write protect status and log 
e886 22 ad e9		        LD      (WRTPRT),HL     ;in vector. 
e889 22 af e9		        LD      (LOGIN),HL 
e88c af			        XOR     A               ;select drive 'A'. 
e88d 32 42 df		        LD      (ACTIVE),A 
e890 21 80 00		        LD      HL,TBUFF        ;setup default dma address. 
e893 22 b1 e9		        LD      (USERDMA),HL 
e896 cd da e1		        CALL    DEFDMA 
e899 c3 21 e8		        JP      LOGINDRV        ;now log in drive 'A'. 
e89c			; 
e89c			;   Function to open a specified file. 
e89c			; 
e89c cd 72 e1		OPENFIL:CALL    CLEARS2         ;clear 's2' byte. 
e89f cd 51 e8		        CALL    AUTOSEL         ;select proper disk. 
e8a2 c3 51 e4		        JP      OPENIT          ;and open the file. 
e8a5			; 
e8a5			;   Function to close a specified file. 
e8a5			; 
e8a5 cd 51 e8		CLOSEFIL: CALL  AUTOSEL         ;select proper disk. 
e8a8 c3 a2 e4		        JP      CLOSEIT         ;and close the file. 
e8ab			; 
e8ab			;   Function to return the first occurence of a specified file 
e8ab			; name. If the first byte of the fcb is '?' then the name will 
e8ab			; not be checked (get the first entry no matter what). 
e8ab			; 
e8ab 0e 00		GETFST: LD      C,0             ;prepare for special search. 
e8ad eb			        EX      DE,HL 
e8ae 7e			        LD      A,(HL)          ;is first byte a '?'? 
e8af fe 3f		        CP      '?' 
e8b1 ca c2 e8		        JP      Z,GETFST1       ;yes, just get very first entry (zero length match). 
e8b4 cd a6 e0		        CALL    SETEXT          ;get the extension byte from fcb. 
e8b7 7e			        LD      A,(HL)          ;is it '?'? if yes, then we want 
e8b8 fe 3f		        CP      '?'             ;an entry with a specific 's2' byte. 
e8ba c4 72 e1		        CALL    NZ,CLEARS2      ;otherwise, look for a zero 's2' byte. 
e8bd cd 51 e8		        CALL    AUTOSEL         ;select proper drive. 
e8c0 0e 0f		        LD      C,15            ;compare bytes 0-14 in fcb (12&13 excluded). 
e8c2 cd 18 e3		GETFST1:CALL    FINDFST         ;find an entry and then move it into 
e8c5 c3 e9 e1		        JP      MOVEDIR         ;the users dma space. 
e8c8			; 
e8c8			;   Function to return the next occurence of a file name. 
e8c8			; 
e8c8 2a d9 e9		GETNXT: LD      HL,(SAVEFCB)    ;restore pointers. note that no 
e8cb 22 43 df		        LD      (PARAMS),HL     ;other dbos calls are allowed. 
e8ce cd 51 e8		        CALL    AUTOSEL         ;no error will be returned, but the 
e8d1 cd 2d e3		        CALL    FINDNXT         ;results will be wrong. 
e8d4 c3 e9 e1		        JP      MOVEDIR 
e8d7			; 
e8d7			;   Function to delete a file by name. 
e8d7			; 
e8d7 cd 51 e8		DELFILE:CALL    AUTOSEL         ;select proper drive. 
e8da cd 9c e3		        CALL    ERAFILE         ;erase the file. 
e8dd c3 01 e3		        JP      STSTATUS        ;set status and return. 
e8e0			; 
e8e0			;   Function to execute a sequential read of the specified 
e8e0			; record number. 
e8e0			; 
e8e0 cd 51 e8		READSEQ:CALL    AUTOSEL         ;select proper drive then read. 
e8e3 c3 bc e5		        JP      RDSEQ 
e8e6			; 
e8e6			;   Function to write the net sequential record. 
e8e6			; 
e8e6 cd 51 e8		WRTSEQ: CALL    AUTOSEL         ;select proper drive then write. 
e8e9 c3 fe e5		        JP      WTSEQ 
e8ec			; 
e8ec			;   Create a file function. 
e8ec			; 
e8ec cd 72 e1		FCREATE:CALL    CLEARS2         ;clear the 's2' byte on all creates. 
e8ef cd 51 e8		        CALL    AUTOSEL         ;select proper drive and get the next 
e8f2 c3 24 e5		        JP      GETEMPTY        ;empty directory space. 
e8f5			; 
e8f5			;   Function to rename a file. 
e8f5			; 
e8f5 cd 51 e8		RENFILE:CALL    AUTOSEL         ;select proper drive and then switch 
e8f8 cd 16 e4		        CALL    CHGNAMES        ;file names. 
e8fb c3 01 e3		        JP      STSTATUS 
e8fe			; 
e8fe			;   Function to return the login vector. 
e8fe			; 
e8fe 2a af e9		GETLOG: LD      HL,(LOGIN) 
e901 c3 29 e9		        JP      GETPRM1 
e904			; 
e904			;   Function to return the current disk assignment. 
e904			; 
e904 3a 42 df		GETCRNT:LD      A,(ACTIVE) 
e907 c3 01 df		        JP      SETSTAT 
e90a			; 
e90a			;   Function to set the dma address. 
e90a			; 
e90a eb			PUTDMA: EX      DE,HL 
e90b 22 b1 e9		        LD      (USERDMA),HL    ;save in our space and then get to 
e90e c3 da e1		        JP      DEFDMA          ;the bios with this also. 
e911			; 
e911			;   Function to return the allocation vector. 
e911			; 
e911 2a bf e9		GETALOC:LD      HL,(ALOCVECT) 
e914 c3 29 e9		        JP      GETPRM1 
e917			; 
e917			;   Function to return the read-only status vector. 
e917			; 
e917 2a ad e9		GETROV: LD      HL,(WRTPRT) 
e91a c3 29 e9		        JP      GETPRM1 
e91d			; 
e91d			;   Function to set the file attributes (read-only, system). 
e91d			; 
e91d cd 51 e8		SETATTR:CALL    AUTOSEL         ;select proper drive then save attributes. 
e920 cd 3b e4		        CALL    SAVEATTR 
e923 c3 01 e3		        JP      STSTATUS 
e926			; 
e926			;   Function to return the address of the disk parameter block 
e926			; for the current drive. 
e926			; 
e926 2a bb e9		GETPARM:LD      HL,(DISKPB) 
e929 22 45 df		GETPRM1:LD      (STATUS),HL 
e92c c9			        RET      
e92d			; 
e92d			;   Function to get or set the user number. If (E) was (FF) 
e92d			; then this is a request to return the current user number. 
e92d			; Else set the user number from (E). 
e92d			; 
e92d 3a d6 e9		GETUSER:LD      A,(EPARAM)      ;get parameter. 
e930 fe ff		        CP      0FFH            ;get user number? 
e932 c2 3b e9		        JP      NZ,SETUSER 
e935 3a 41 df		        LD      A,(USERNO)      ;yes, just do it. 
e938 c3 01 df		        JP      SETSTAT 
e93b e6 1f		SETUSER:AND     1FH             ;no, we should set it instead. keep low 
e93d 32 41 df		        LD      (USERNO),A      ;bits (0-4) only. 
e940 c9			        RET      
e941			; 
e941			;   Function to read a random record from a file. 
e941			; 
e941 cd 51 e8		RDRANDOM: CALL  AUTOSEL         ;select proper drive and read. 
e944 c3 93 e7		        JP      READRAN 
e947			; 
e947			;   Function to compute the file size for random files. 
e947			; 
e947 cd 51 e8		WTRANDOM: CALL  AUTOSEL         ;select proper drive and write. 
e94a c3 9c e7		        JP      WRITERAN 
e94d			; 
e94d			;   Function to compute the size of a random file. 
e94d			; 
e94d cd 51 e8		FILESIZE: CALL  AUTOSEL         ;select proper drive and check file length 
e950 c3 d2 e7		        JP      RANSIZE 
e953			; 
e953			;   Function #37. This allows a program to log off any drives. 
e953			; On entry, set (DE) to contain a word with bits set for those 
e953			; drives that are to be logged off. The log-in vector and the 
e953			; write protect vector will be updated. This must be a M/PM 
e953			; special function. 
e953			; 
e953 2a 43 df		LOGOFF: LD      HL,(PARAMS)     ;get drives to log off. 
e956 7d			        LD      A,L             ;for each bit that is set, we want 
e957 2f			        CPL                     ;to clear that bit in (LOGIN) 
e958 5f			        LD      E,A             ;and (WRTPRT). 
e959 7c			        LD      A,H 
e95a 2f			        CPL      
e95b 2a af e9		        LD      HL,(LOGIN)      ;reset the login vector. 
e95e a4			        AND     H 
e95f 57			        LD      D,A 
e960 7d			        LD      A,L 
e961 a3			        AND     E 
e962 5f			        LD      E,A 
e963 2a ad e9		        LD      HL,(WRTPRT) 
e966 eb			        EX      DE,HL 
e967 22 af e9		        LD      (LOGIN),HL      ;and save. 
e96a 7d			        LD      A,L             ;now do the write protect vector. 
e96b a3			        AND     E 
e96c 6f			        LD      L,A 
e96d 7c			        LD      A,H 
e96e a2			        AND     D 
e96f 67			        LD      H,A 
e970 22 ad e9		        LD      (WRTPRT),HL     ;and save. all done. 
e973 c9			        RET      
e974			; 
e974			;   Get here to return to the user. 
e974			; 
e974 3a de e9		GOBACK: LD      A,(AUTO)        ;was auto select activated? 
e977 b7			        OR      A 
e978 ca 91 e9		        JP      Z,GOBACK1 
e97b 2a 43 df		        LD      HL,(PARAMS)     ;yes, but was a change made? 
e97e 36 00		        LD      (HL),0          ;(* reset first byte of fcb *) 
e980 3a e0 e9		        LD      A,(AUTOFLAG) 
e983 b7			        OR      A 
e984 ca 91 e9		        JP      Z,GOBACK1 
e987 77			        LD      (HL),A          ;yes, reset first byte properly. 
e988 3a df e9		        LD      A,(OLDDRV)      ;and get the old drive and select it. 
e98b 32 d6 e9		        LD      (EPARAM),A 
e98e cd 45 e8		        CALL    SETDSK 
e991 2a 0f df		GOBACK1:LD      HL,(USRSTACK)   ;reset the users stack pointer. 
e994 f9			        LD      SP,HL 
e995 2a 45 df		        LD      HL,(STATUS)     ;get return status. 
e998 7d			        LD      A,L             ;force version 1.4 compatability. 
e999 44			        LD      B,H 
e99a c9			        RET                     ;and go back to user. 
e99b			; 
e99b			;   Function #40. This is a special entry to do random i/o. 
e99b			; For the case where we are writing to unused disk space, this 
e99b			; space will be zeroed out first. This must be a M/PM special 
e99b			; purpose function, because why would any normal program even 
e99b			; care about the previous contents of a sector about to be 
e99b			; written over. 
e99b			; 
e99b cd 51 e8		WTSPECL:CALL    AUTOSEL         ;select proper drive. 
e99e 3e 02		        LD      A,2             ;use special write mode. 
e9a0 32 d5 e9		        LD      (MODE),A 
e9a3 0e 00		        LD      C,0             ;set write indicator. 
e9a5 cd 07 e7		        CALL    POSITN1         ;position the file. 
e9a8 cc 03 e6		        CALL    Z,WTSEQ1        ;and write (if no errors). 
e9ab c9			        RET      
e9ac			; 
e9ac			;************************************************************** 
e9ac			;* 
e9ac			;*     BDOS data storage pool. 
e9ac			;* 
e9ac			;************************************************************** 
e9ac			; 
e9ac e5			EMPTYFCB: DEFB  0E5H            ;empty directory segment indicator. 
e9ad 00 00		WRTPRT: DEFW    0               ;write protect status for all 16 drives. 
e9af 00 00		LOGIN:  DEFW    0               ;drive active word (1 bit per drive). 
e9b1 80 00		USERDMA:DEFW    080H            ;user's dma address (defaults to 80h). 
e9b3			; 
e9b3			;   Scratch areas from parameter block. 
e9b3			; 
e9b3 00 00		SCRATCH1: DEFW  0               ;relative position within dir segment for file (0-3). 
e9b5 00 00		SCRATCH2: DEFW  0               ;last selected track number. 
e9b7 00 00		SCRATCH3: DEFW  0               ;last selected sector number. 
e9b9			; 
e9b9			;   Disk storage areas from parameter block. 
e9b9			; 
e9b9 00 00		DIRBUF: DEFW    0               ;address of directory buffer to use. 
e9bb 00 00		DISKPB: DEFW    0               ;contains address of disk parameter block. 
e9bd 00 00		CHKVECT:DEFW    0               ;address of check vector. 
e9bf 00 00		ALOCVECT: DEFW  0               ;address of allocation vector (bit map). 
e9c1			; 
e9c1			;   Parameter block returned from the bios. 
e9c1			; 
e9c1 00 00		SECTORS:DEFW    0               ;sectors per track from bios. 
e9c3 00			BLKSHFT:DEFB    0               ;block shift. 
e9c4 00			BLKMASK:DEFB    0               ;block mask. 
e9c5 00			EXTMASK:DEFB    0               ;extent mask. 
e9c6 00 00		DSKSIZE:DEFW    0               ;disk size from bios (number of blocks-1). 
e9c8 00 00		DIRSIZE:DEFW    0               ;directory size. 
e9ca 00 00		ALLOC0: DEFW    0               ;storage for first bytes of bit map (dir space used). 
e9cc 00 00		ALLOC1: DEFW    0 
e9ce 00 00		OFFSET: DEFW    0               ;first usable track number. 
e9d0 00 00		XLATE:  DEFW    0               ;sector translation table address. 
e9d2			; 
e9d2			; 
e9d2 00			CLOSEFLG: DEFB  0               ;close flag (=0ffh is extent written ok). 
e9d3 00			RDWRTFLG: DEFB  0               ;read/write flag (0ffh=read, 0=write). 
e9d4 00			FNDSTAT:DEFB    0               ;filename found status (0=found first entry). 
e9d5 00			MODE:   DEFB    0               ;I/o mode select (0=random, 1=sequential, 2=special random). 
e9d6 00			EPARAM: DEFB    0               ;storage for register (E) on entry to bdos. 
e9d7 00			RELBLOCK: DEFB  0               ;relative position within fcb of block number written. 
e9d8 00			COUNTER:DEFB    0               ;byte counter for directory name searches. 
e9d9 00 00 00 00	SAVEFCB:DEFW    0,0             ;save space for address of fcb (for directory searches). 
e9dd 00			BIGDISK:DEFB    0               ;if =0 then disk is > 256 blocks long. 
e9de 00			AUTO:   DEFB    0               ;if non-zero, then auto select activated. 
e9df 00			OLDDRV: DEFB    0               ;on auto select, storage for previous drive. 
e9e0 00			AUTOFLAG: DEFB  0               ;if non-zero, then auto select changed drives. 
e9e1 00			SAVNXT: DEFB    0               ;storage for next record number to access. 
e9e2 00			SAVEXT: DEFB    0               ;storage for extent number of file. 
e9e3 00 00		SAVNREC:DEFW    0               ;storage for number of records in file. 
e9e5 00 00		BLKNMBR:DEFW    0               ;block number (physical sector) used within a file or logical sect 
e9e7 00 00		LOGSECT:DEFW    0               ;starting logical (128 byte) sector of block (physical sector). 
e9e9 00			FCBPOS: DEFB    0               ;relative position within buffer for fcb of file of interest. 
e9ea 00 00		FILEPOS:DEFW    0               ;files position within directory (0 to max entries -1). 
e9ec			; 
e9ec			;   Disk directory buffer checksum bytes. One for each of the 
e9ec			; 16 possible drives. 
e9ec			; 
e9ec 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00	CKSUMTBL: DEFB  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
e9fc			; 
e9fc			;   Extra space ? 
e9fc			; 
e9fc 00 00 00 00	        DEFB    0,0,0,0 
ea00			; 
ea00			;************************************************************** 
ea00			;* 
ea00			;*        B I O S   J U M P   T A B L E 
ea00			;* 
ea00			;************************************************************** 
ea00			; 
ea00			;BOOT:   JP      0               ;NOTE WE USE FAKE DESTINATIONS 
ea00			;WBOOT:  JP      0 
ea00			;CONST:  JP      0 
ea00			;CONIN:  JP      0 
ea00			;CONOUT: JP      0 
ea00			;LIST:   JP      0 
ea00			;PUNCH:  JP      0 
ea00			;READER: JP      0 
ea00			;HOME:   JP      0 
ea00			;SELDSK: JP      0 
ea00			;SETTRK: JP      0 
ea00			;SETSEC: JP      0 
ea00			;SETDMA: JP      0 
ea00			;READ:   JP      0 
ea00			;WRITE:  JP      0 
ea00			;PRSTAT: JP      0 
ea00			;SECTRN: JP      0 
ea00			; 
ea00			;* 
ea00			;******************   E N D   O F   C P / M   ***************** 
ea00			;* 
ea00			 
# End of file ../cpm-2.2/src/cpm22.asm
ea00			 
ea00			;########################################################################## 
ea00			; 
ea00			; The BIOS vector table has to have its entries named AND located precisely 
ea00			; to match the included CP/M code above.   
ea00			; 
ea00			; Specifically, the BIOS branch vectors must start at CPM_BASE+0x1600.   
ea00			; 
ea00			;########################################################################## 
ea00			if $ != CPM_BASE+0x1600 
ea00				ERROR	THE BIOS VECTOR TABLE IS IN THE WRONG PLACE 
ea00			endif 
ea00			 
ea00 c3 33 ea		BOOT:   JP      .bios_boot 
ea03 c3 85 eb		WBOOT:  JP      .bios_wboot 
ea06 c3 4f ec		CONST:  JP      .bios_const 
ea09 c3 56 ec		CONIN:  JP      .bios_conin 
ea0c c3 59 ec		CONOUT: JP      .bios_conout 
ea0f c3 5c ec		LIST:   JP      .bios_list 
ea12 c3 61 ec		PUNCH:  JP      .bios_punch 
ea15 c3 62 ec		READER: JP      .bios_reader 
ea18 c3 e1 ec		HOME:   JP      disk_home 
ea1b c3 98 ec		SELDSK: JP      disk_seldsk 
ea1e c3 e9 ec		SETTRK: JP      disk_settrk 
ea21 c3 ee ec		SETSEC: JP      disk_setsec 
ea24 c3 f3 ec		SETDMA: JP      disk_setdma 
ea27 c3 06 ed		READ:   JP      disk_read 
ea2a c3 fb ec		WRITE:  JP      disk_write 
ea2d c3 5e ec		PRSTAT: JP      .bios_prstat 
ea30 c3 f8 ec		SECTRN: JP      disk_sectrn 
ea33			 
ea33			;########################################################################## 
ea33			; 
ea33			; CP/M 2.2 Alteration Guide p17: 
ea33			; The BOOT entry point gets control from the cold start loader and is 
ea33			; responsible for basic system initialization, including sending a signon 
ea33			; message. 
ea33			; 
ea33			; If the IOBYTE function is implemented, it must be set at this point. 
ea33			; 
ea33			; The various system parameters which are set by the WBOOT entry point 
ea33			; must be initialized (see .go_cpm), and control is transferred to the CCP  
ea33			; at 3400H+b for further processing. 
ea33			; 
ea33			; Note that reg C must be set to zero to select drive A. 
ea33			; 
ea33			;########################################################################## 
ea33			.bios_boot: 
ea33				; This will select low-bank E, idle the SD card, and idle the printer 
ea33 3e e7			ld		a,gpio_out_sd_mosi|gpio_out_sd_clk|gpio_out_sd_ssel|(.low_bank<<4) 
ea35 32 c0 fa			ld		(gpio_out_cache),a 
ea38 d3 10			out		(gpio_out),a 
ea3a			 
ea3a				; make sure we have a viable stack 
ea3a 31 81 fb			ld		sp,bios_stack				; use the private BIOS stack to get started 
ea3d			 
ea3d				; Note: console should still be initialized from the boot loader 
ea3d				;		call .init_console 
ea3d			 
ea3d			if .debug > 0 
ea3d				call	iputs 
ea3d				db		"\r\n.bios_boot entered\r\n\0" 
ea3d				call	iputs 
ea3d				db		"NOTICE: Debug level is set to: 0x\0" 
ea3d				ld		a,.debug				; A = the current debug level 
ea3d				call	hexdump_a				; print the current level number 
ea3d				call	puts_crlf				; and a newline 
ea3d			endif 
ea3d			 
ea3d				; Display a hello world message. 
ea3d 21 56 ea			ld		hl,.boot_msg 
ea40 cd 74 f6			call	puts 
ea43			 
ea43				; For sanity sake, wipe the zero-page so we aren't confused by  
ea43				; whatever random noise the flash boot-loader has left there. 
ea43 21 00 00			ld		hl,0 
ea46 11 01 00			ld		de,1 
ea49 01 ff 00			ld		bc,0xff 
ea4c 36 00			ld		(hl),0 
ea4e ed b0			ldir 
ea50			 
ea50				; Either ensure the stack is in high RAM or disable IRQs to call disk_init! 
ea50 cd 69 ec			call	disk_init		; initialize anything needed for disk read/write  
ea53 c3 22 ec			jp		.go_cpm 
ea56			 
ea56			.boot_msg: 
ea56 ..				db		"\r\n\n" 
ea59 ..				db		"****************************************************************************\r\n\n"	 
eaa8 ..				db		" Z80 Retro BIOS Copyright (C) 2021 John Winans\r\n" 
ead8 ..				db		" Reworked for TeachZ80 2024 Christian Luethi\r\n" 
eb06 ..				db	    " CP/M 2.2 Copyright (C) 1979 Digital Research\r\n\n" 
eb36 ..				db		"****************************************************************************\r\n\0" 
eb85			 
eb85			;########################################################################## 
eb85			; 
eb85			; CP/M 2.2 Alteration Guide p17: 
eb85			; The WBOOT entry point gets control when a warm start occurs.  A warm 
eb85			; start is performed whenever a user program branches to location 0x0000. 
eb85			; 
eb85			; The CP/M CCP and BDOS must be re-loaded from the first two tracks of  
eb85			; drive A up to, but not including, the BIOS. 
eb85			; 
eb85			; The WBOOT & BDOS jump instructions in page-zero must be initialized  
eb85			; (see .go_cpm), and control is transferred to the CCP at 3400H+b for  
eb85			; further processing. 
eb85			; 
eb85			; Upon completion of the initialization, the WBOOT program must branch 
eb85			; to the CCP at 3400H+b to (re)start the system. Upon entry to the CCP, 
eb85			; register C is set to the drive to select after system initialization. 
eb85			; 
eb85			;########################################################################## 
eb85			 
eb85			; WARNING: The following assumes that CPM_BASE%128 is zero! 
eb85			 
eb85			.wb_nsects:	equ (BOOT-CPM_BASE)/128				; number of sectors to load 
eb85			.wb_trk:	equ (CPM_BASE-LOAD_BASE)/512		; first track number (rounded down) 
eb85			.wb_sec:	equ ((CPM_BASE-LOAD_BASE)/128)&0x03	; first sector number 
eb85			 
eb85			 
eb85			.bios_wboot: 
eb85				; We can't just blindly set SP=bios_stack here because disk_read can overwrite it! 
eb85				; But we CAN set to use other areas that we KNOW are not currently in use! 
eb85 31 41 fb			ld		sp,.bios_wboot_stack			; the disk_dirbuf is garbage right now 
eb88			 
eb88			 
eb88			if .debug >= 2 
eb88				call	iputs 
eb88				db		"\r\n.bios_wboot entered\r\n\0" 
eb88			endif 
eb88			 
eb88				; reload the CCP and BDOS 
eb88 0e 00			ld		c,0								; C = drive number (0=A) 
eb8a cd 98 ec			call	disk_seldsk						; load the OS from drive A 
eb8d			 
eb8d 01 0a 00			ld		bc,.wb_trk						; BC = track number whgere the CCP starts 
eb90 cd e9 ec			call	disk_settrk 
eb93			 
eb93 01 00 00			ld		bc,.wb_sec						; sector where the CCP begins on .wb_trk 
eb96 cd ee ec			call	disk_setsec 
eb99			 
eb99 01 00 d4			ld		bc,CPM_BASE						; starting address to read the OS into 
eb9c cd f3 ec			call	disk_setdma 
eb9f			 
eb9f 01 2c 00			ld		bc,.wb_nsects					; BC = gross number of sectors to read 
eba2			.wboot_loop: 
eba2 c5				push	bc								; save the remaining sector count 
eba3 cd 06 ed			call	disk_read						; read 1 sector 
eba6 b7				or	a									; disk_read sets A=0 on success 
eba7 28 50			jr	z,.wboot_sec_ok						; if read was OK, continue processing 
eba9			 
eba9				; If there was a read error, stop. 
eba9 cd 6d f6			call	iputs 
ebac ..				db      "\r\n\r\nERROR: WBOOT READ FAILED.  HALTING." 
ebd3 ..				db      "\r\n\n*** PRESS RESET TO REBOOT ***\r\n" 
ebf5 00				db      0 
ebf6 c3 f6 eb			jp      $               				; endless spin loop 
ebf9			 
ebf9			.wboot_sec_ok: 
ebf9				; advance the DMA pointer by 128 bytes 
ebf9 2a 70 ed			ld		hl,(disk_dma)					; HL = the last used DMA address 
ebfc 11 80 00			ld		de,128 
ebff 19				add		hl,de							; HL += 128 
ec00 44				ld		b,h 
ec01 4d				ld		c,l								; BC = HL 
ec02 cd f3 ec			call	disk_setdma 
ec05			 
ec05				; increment the sector/track numbers 
ec05 3a 75 ed			ld		a,(disk_sec)					; A = last used sector number (low byte only for 0..3) 
ec08 3c				inc		a 
ec09 e6 03			and		0x03							; if A+1 = 4 then A=0 
ec0b 20 09			jr		nz,.wboot_sec					; if A+1 !=4 then do not advance the track number 
ec0d			 
ec0d				; advance to the next track 
ec0d ed 4b 73 ed		ld		bc,(disk_track) 
ec11 03				inc		bc 
ec12 cd e9 ec			call	disk_settrk 
ec15 af				xor		a								; set A=0 for first sector on new track 
ec16			 
ec16			.wboot_sec: 
ec16 06 00			ld		b,0 
ec18 4f				ld		c,a 
ec19 cd ee ec			call	disk_setsec 
ec1c			 
ec1c c1				pop		bc								; BC = remaining sector counter value 
ec1d 0b				dec		bc								; BC -= 1 
ec1e 78				ld		a,b 
ec1f b1				or		c 
ec20 20 80			jr		nz,.wboot_loop					; if BC != 0 then goto .wboot_loop 
ec22			 
ec22			 
ec22				; fall through into .go_cpm... 
ec22			.go_cpm: 
ec22 3e c3			ld		a,0xc3							; opcode for JP 
ec24 32 00 00			ld		(0),a 
ec27 21 03 ea			ld		hl,WBOOT 
ec2a 22 01 00			ld		(1),hl							; address 0 now = JP WBOOT 
ec2d			 
ec2d 32 05 00			ld		(5),a							; opcode for JP 
ec30 21 06 dc			ld		hl,FBASE 
ec33 22 06 00			ld		(6),hl							; address 6 now = JP FBASE 
ec36			 
ec36 01 80 00			ld		bc,0x80							; this is here because it is in the example CBIOS (AG p.52) 
ec39 cd f3 ec			call	disk_setdma 
ec3c			 
ec3c			if .debug >= 3 
ec3c				; dump the zero-page for reference 
ec3c				ld		hl,0		; start address 
ec3c				ld		bc,0x100	; number of bytes 
ec3c				ld		e,1		; fancy format 
ec3c				call	hexdump 
ec3c			endif 
ec3c			 
ec3c			if 1 
ec3c 0e 00			ld		c,0								; default = drive A (if previous was invalid) 
ec3e 3a 04 00			ld		a,(4)           				; load the current disk # from page-zero into A 
ec41 e6 0f			and		0x0f           				 	; the drive number is in the 4 lsbs 
ec43 fe 08			cp		dph_vec_num 
ec45 d2 00 d4			jp		nc,CPM_BASE     				; if A >= dph_vec_num then bad drive (use 0) 
ec48			 
ec48 3a 04 00			ld		a,(4)           				; load the current disk # from page-zero into a/c 
ec4b 4f				ld		c,a 
ec4c			else 
ec4c				ld		c,0								; The ONLY valid drive WE have is A! 
ec4c			endif 
ec4c c3 00 d4			jp		CPM_BASE						; start the CCP 
ec4f			 
ec4f			;########################################################################## 
ec4f			; 
ec4f			; CP/M 2.2 Alteration Guide p17: 
ec4f			; If the console device is ready for reading then return 0FFH in register A. 
ec4f			; Else return 00H in register A. 
ec4f			; 
ec4f			;########################################################################## 
ec4f			.bios_const: 
ec4f cd 40 f6			call	con_rx_ready 
ec52 c8				ret		z								; A = 0 = not ready 
ec53 3e ff			ld		a,0xff 
ec55 c9				ret										; A = 0xff = ready 
ec56			 
ec56			;########################################################################## 
ec56			; 
ec56			; CP/M 2.2 Alteration Guide p17: 
ec56			; Read the next console character into register A and set the parity bit 
ec56			; (high order bit) to zero.  If no console character is ready, wait until 
ec56			; a character is typed before returning. 
ec56			; 
ec56			;########################################################################## 
ec56			.bios_conin: 
ec56			if 1 
ec56 c3 65 f6			jp		con_rx_char 
ec59			else 
ec59				; a simple hack to let us dump the dmcache status on demand 
ec59				call	con_rx_char 
ec59				cp		0x1B							; escape key?? 
ec59				ret		nz								; if not an escape then return 
ec59				call	z,disk_dmcache_debug_wedge		; else tail-call the debug wedge 
ec59				ld		a,0x1B							; restore the trigger key value 
ec59				ret 
ec59			endif 
ec59			 
ec59			;########################################################################## 
ec59			; 
ec59			; CP/M 2.2 Alteration Guide p18: 
ec59			; Send the character from register C to the console output device.  The 
ec59			; character is in ASCII, with high order parity bit set to zero. 
ec59			; 
ec59			;########################################################################## 
ec59			.bios_conout: 
ec59 c3 53 f6			jp		con_tx_char 
ec5c			 
ec5c			;########################################################################## 
ec5c			; 
ec5c			; CP/M 2.2 Alteration Guide p18: 
ec5c			; Send the character from register C to the currently assigned listing 
ec5c			; device.  The character is in ASCII with zero parity. 
ec5c			; 
ec5c			;########################################################################## 
ec5c			.bios_list: 
ec5c c9				ret 
ec5d			 
ec5d			.init_list: 
ec5d c9				ret 
ec5e			 
ec5e			;########################################################################## 
ec5e			; 
ec5e			; CP/M 2.2 Alteration Guide p20: 
ec5e			; Return the ready status of the list device.  Used by the DESPOOL program 
ec5e			; to improve console response during its operation.  The value 00 is 
ec5e			; returned in A of the list device is not ready to accept a character, and 
ec5e			; 0FFH if a character can be sent to the printer.  
ec5e			; 
ec5e			; Note that a 00 value always suffices. 
ec5e			; 
ec5e			; Clobbers AF 
ec5e			;########################################################################## 
ec5e			.bios_prstat: 
ec5e 3e 00			ld		a,0 
ec60 c9				ret 
ec61			 
ec61			;########################################################################## 
ec61			; 
ec61			; CP/M 2.2 Alteration Guide p18: 
ec61			; Send the character from register C to the currently assigned punch device. 
ec61			; The character is in ASCII with zero parity. 
ec61			; 
ec61			; The Z80 Retro! has no punch device. Discard any data written. 
ec61			; 
ec61			;########################################################################## 
ec61			.bios_punch: 
ec61 c9				ret 
ec62			 
ec62			;########################################################################## 
ec62			; 
ec62			; CP/M 2.2 Alteration Guide p18: 
ec62			; Read the next character from the currently assigned reader device into 
ec62			; register A with zero parity (high order bit must be zero), an end of 
ec62			; file condition is reported by returning an ASCII control-Z (1AH). 
ec62			; 
ec62			; The Z80 Retro! has no tape device. Return the EOF character. 
ec62			; 
ec62			;########################################################################## 
ec62			.bios_reader: 
ec62 3e 1a			ld		a,0x1a 
ec64 c9				ret 
ec65			 
ec65			;########################################################################## 
ec65			; Initialize the console port.  Note that this includes CTC port 1. 
ec65			;########################################################################## 
ec65			.init_console: 
ec65 cd 2c f6			call 	sioa_init_64 
ec68 c9				ret	 
ec69			 
ec69			;########################################################################## 
ec69			; Libraries 
ec69			;########################################################################## 
ec69			include 'disk_callgate.asm' 
ec69			;**************************************************************************** 
ec69			; 
ec69			;	 Copyright (C) 2021,2022,2023 John Winans 
ec69			; 
ec69			;	 This library is free software; you can redistribute it and/or 
ec69			;	 modify it under the terms of the GNU Lesser General Public 
ec69			;	 License as published by the Free Software Foundation; either 
ec69			;	 version 2.1 of the License, or (at your option) any later version. 
ec69			; 
ec69			;	 This library is distributed in the hope that it will be useful, 
ec69			;	 but WITHOUT ANY WARRANTY; without even the implied warranty of 
ec69			;	 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
ec69			;	 Lesser General Public License for more details. 
ec69			; 
ec69			;	 You should have received a copy of the GNU Lesser General Public 
ec69			;	 License along with this library; if not, write to the Free Software 
ec69			;	 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 
ec69			;	 USA 
ec69			; 
ec69			; https://github.com/Z80-Retro/ 
ec69			; 
ec69			;**************************************************************************** 
ec69			; A call-gate that directs disk subroutine calls into the correct 
ec69			; driver based on which drive is being referred to. 
ec69			.disk_debug:	equ	0 
ec69			 
ec69			;**************************************************************************** 
ec69			; For each drive, find the init function from the DPH->DPB and call it. 
ec69			;**************************************************************************** 
ec69			disk_init: 
ec69			 
ec69			if .disk_debug >= 1 
ec69			    call    iputs 
ec69			    db      "disk_init entered: \0" 
ec69			    call    disk_dump 
ec69			endif 
ec69			 
ec69 fd 21 fa f5		ld		iy,dph_vec			; IY = &dph_vec 
ec6d 06 08			ld		b,dph_vec_num		; count to initialize 
ec6f			.init_loop: 
ec6f fd 6e 00			ld		l,(iy+0) 
ec72 fd 66 01			ld		h,(iy+1)			; HL = dph[0] 
ec75 22 77 ed			ld		(disk_dph),hl		; set disk_dph in case it is needed 
ec78			 
ec78 e5				push	hl 
ec79 dd e1			pop		ix					; IX = dph[0] 
ec7b			 
ec7b dd 6e 0a			ld		l,(ix+10) 
ec7e dd 66 0b			ld		h,(ix+11) 
ec81 e5				push	hl 
ec82 dd e1			pop		ix					; IX = DPB address 
ec84			 
ec84 dd 6e fa			ld		l,(ix-6) 
ec87 dd 66 fb			ld		h,(ix-5)			; HL = disk init func address 
ec8a			 
ec8a fd e5			push	iy 
ec8c c5				push	bc 
ec8d e9				jp		(hl) 
ec8e c1				pop		bc 
ec8f fd e1			pop		iy 
ec91			 
ec91 fd 23			inc		iy					; point to the next table entry 
ec93 fd 23			inc		iy 
ec95			 
ec95 10 d8			djnz	.init_loop 
ec97			 
ec97 c9				ret 
ec98			 
ec98			 
ec98			;**************************************************************************** 
ec98			;**************************************************************************** 
ec98			disk_seldsk: 
ec98			 
ec98			if .disk_debug >= 2 
ec98				push	bc 
ec98				call    iputs 
ec98				db		"disk_seldsk entered\r\n\0" 
ec98				pop		bc 
ec98			endif 
ec98				; check if the disk is valid 
ec98 79			    ld      a,c 
ec99 fe 08			cp		dph_vec_num 
ec9b 30 37			jr		nc,.seldsk_fail		; if (a >= dph_vec_num) then error 
ec9d			 
ec9d 32 72 ed		    ld      (disk_disk),a 
eca0			 
eca0				; disk is valid, find the DPH 
eca0 21 fa f5			ld		hl,dph_vec			; default = invalid 
eca3 cb 27			sla		a					; A = A * 2 
eca5 4f				ld		c,a 
eca6 06 00			ld		b,0 
eca8 09				add		hl,bc				; HL = HL + A * 2 
eca9 4e				ld		c,(hl) 
ecaa 23				inc		hl 
ecab 46				ld		b,(hl) 
ecac 21 00 00			ld		hl,0 
ecaf 09				add		hl,bc				; HL = DPH for drive n 
ecb0 e5				push	hl 
ecb1 22 77 ed			ld		(disk_dph),hl		; save the current DPH for reference 
ecb4			 
ecb4				; find and make handy the read and write handler pointers 
ecb4 e5				push	hl 
ecb5 dd e1			pop		ix					; IX = DPH for drive n 
ecb7			 
ecb7 dd 6e 0a			ld		l,(ix+10) 
ecba dd 66 0b			ld		h,(ix+11) 
ecbd			if 0 
ecbd				push 	hl 
ecbd				call	iputs 
ecbd				db		"ix=\0" 
ecbd				push	ix 
ecbd				pop		de 
ecbd				ld		a,d 
ecbd				call	hexdump_a 
ecbd				ld		a,e 
ecbd				call	hexdump_a 
ecbd			 
ecbd				call	iputs 
ecbd				db		", hl=\0" 
ecbd				ld		a,h 
ecbd				call	hexdump_a 
ecbd				ld		a,l 
ecbd				call	hexdump_a 
ecbd			 
ecbd				call	iputs 
ecbd				db		"\r\nvars:\r\n\0" 
ecbd			 
ecbd				ld		hl,disk_dma 
ecbd				ld		bc,16 
ecbd				ld		e,1 
ecbd				call	hexdump	 
ecbd				pop		hl 
ecbd			endif 
ecbd			 
ecbd e5				push	hl 
ecbe dd e1			pop		ix					; IX = DPB address 
ecc0			 
ecc0 dd 6e fc			ld		l,(ix-4) 
ecc3 dd 66 fd			ld		h,(ix-3)			; HL = disk read func address 
ecc6 22 7d ed			ld		(.cur_disk_read),hl 
ecc9 dd 6e fe			ld		l,(ix-2) 
eccc dd 66 ff			ld		h,(ix-1)			; HL = disk write func address 
eccf 22 7f ed			ld		(.cur_disk_write),hl 
ecd2			 
ecd2			if 0 
ecd2				call	iputs 
ecd2				db		"disk_seldsk: iy=\0" 
ecd2				push	iy 
ecd2				pop		de 
ecd2				ld		a,d 
ecd2				call	hexdump_a 
ecd2				ld		a,e 
ecd2				call	hexdump_a 
ecd2			 
ecd2				call	iputs 
ecd2				db		", ix=\0" 
ecd2				push	ix 
ecd2				pop		de 
ecd2				ld		a,d 
ecd2				call	hexdump_a 
ecd2				ld		a,e 
ecd2				call	hexdump_a 
ecd2			 
ecd2				call	iputs 
ecd2				db		", hl=\0" 
ecd2				ld		a,h 
ecd2				call	hexdump_a 
ecd2				ld		a,l 
ecd2				call	hexdump_a 
ecd2			 
ecd2				call	iputs 
ecd2				db		"\r\nvars:\r\n\0" 
ecd2				 
ecd2				ld		hl,disk_dma 
ecd2				ld		bc,16 
ecd2				ld		e,1 
ecd2				call	hexdump	 
ecd2			endif 
ecd2			 
ecd2 e1				pop		hl					; HL = DPH 
ecd3 c9				ret 
ecd4			 
ecd4			.seldsk_fail: 
ecd4				; if the disk select failed, make sure we don't get wierd 
ecd4 21 00 00			ld		hl,0 
ecd7 22 77 ed			ld		(disk_dph),hl 
ecda 22 7d ed			ld		(.cur_disk_read),hl 
ecdd 22 7f ed			ld		(.cur_disk_write),hl 
ece0			 
ece0 c9				ret		; HL = 0 = fail 
ece1			 
ece1			 
ece1			;**************************************************************************** 
ece1			;**************************************************************************** 
ece1			disk_home: 
ece1 01 00 00			ld		bc,0				; just set the track number to zero 
ece4 ed 43 73 ed		ld		(disk_track),bc 
ece8			 
ece8			if .disk_debug >= 2 
ece8				call	iputs 
ece8				db		"disk_home entered:\r\n\0" 
ece8				call	disk_dump 
ece8			endif 
ece8 c9				ret 
ece9			 
ece9			;**************************************************************************** 
ece9			;**************************************************************************** 
ece9			disk_settrk: 
ece9 ed 43 73 ed		ld		(disk_track),bc 
eced			if .disk_debug >= 2 
eced				call	iputs 
eced				db		"disk_settrk entered:\r\n\0" 
eced				call	disk_dump 
eced			endif 
eced c9				ret 
ecee			 
ecee			;**************************************************************************** 
ecee			;**************************************************************************** 
ecee			disk_setsec: 
ecee ed 43 75 ed		ld		(disk_sec),bc 
ecf2			 
ecf2			if .disk_debug >= 2 
ecf2				call	iputs 
ecf2				db		"disk_setsec entered:\r\n\0" 
ecf2				call	disk_dump 
ecf2			endif 
ecf2 c9				ret 
ecf3			 
ecf3			;**************************************************************************** 
ecf3			;**************************************************************************** 
ecf3			disk_setdma: 
ecf3 ed 43 70 ed		ld		(disk_dma),bc 
ecf7			 
ecf7			if .disk_debug >= 2 
ecf7				call	iputs 
ecf7				db		"disk_setdma entered:\r\n\0" 
ecf7				call	disk_dump 
ecf7			endif 
ecf7 c9				ret 
ecf8			 
ecf8			;**************************************************************************** 
ecf8			; No skew factor.  1:1. 
ecf8			;**************************************************************************** 
ecf8			disk_sectrn: 
ecf8 60				ld      h,b 
ecf9 69				ld      l,c 
ecfa c9				ret 
ecfb			 
ecfb			;**************************************************************************** 
ecfb			;**************************************************************************** 
ecfb			disk_write: 
ecfb			if .disk_debug >= 1 
ecfb				call	iputs 
ecfb				db		"disk_write entered:\r\n\0" 
ecfb				call	disk_dump 
ecfb			endif 
ecfb 2a 7f ed			ld		hl,(.cur_disk_write) 
ecfe 7c				ld		a,h 
ecff b5				or		l 
ed00 28 01			jr		z,.disk_fail 
ed02 e9				jp		(hl)				; tail-call the driver 
ed03			 
ed03			.disk_fail: 
ed03 3e 01			ld	a,1						; A = 1 = ERROR 
ed05 c9				ret 
ed06			 
ed06			;**************************************************************************** 
ed06			;**************************************************************************** 
ed06			disk_read: 
ed06			if .disk_debug >= 1 
ed06				call	iputs 
ed06				db		"disk_read entered:\r\n\0" 
ed06				call	disk_dump 
ed06			endif 
ed06			 
ed06 2a 7d ed			ld		hl,(.cur_disk_read) 
ed09 7c				ld		a,h 
ed0a b5				or		l 
ed0b 28 f6			jr		z,.disk_fail 
ed0d e9				jp		(hl)			; tail-call the driver 
ed0e			 
ed0e			;**************************************************************************** 
ed0e			;**************************************************************************** 
ed0e			disk_dump: 
ed0e cd 6d f6			call    iputs 
ed11 ..				db      'disk=0x\0' 
ed19			 
ed19 3a 72 ed			ld      a,(disk_disk) 
ed1c cd 24 f7			call    hexdump_a 
ed1f			 
ed1f cd 6d f6			call    iputs 
ed22 ..				db      ", track=0x\0" 
ed2d 3a 74 ed			ld      a,(disk_track+1) 
ed30 cd 24 f7			call    hexdump_a 
ed33 3a 73 ed			ld      a,(disk_track) 
ed36 cd 24 f7			call    hexdump_a 
ed39			 
ed39 cd 6d f6			call    iputs 
ed3c ..				db      ", sector=0x\0" 
ed48 3a 76 ed			ld      a,(disk_sec+1) 
ed4b cd 24 f7			call    hexdump_a 
ed4e 3a 75 ed			ld      a,(disk_sec) 
ed51 cd 24 f7			call    hexdump_a 
ed54			 
ed54 cd 6d f6			call    iputs 
ed57 ..				db      ", dma=0x\0" 
ed60 3a 71 ed			ld      a,(disk_dma+1) 
ed63 cd 24 f7			call    hexdump_a 
ed66 3a 70 ed			ld      a,(disk_dma) 
ed69 cd 24 f7			call    hexdump_a 
ed6c cd 86 f6			call    puts_crlf 
ed6f			 
ed6f c9				ret 
ed70			 
ed70			;**************************************************************************** 
ed70			; These are global because they are read by the disk drivers. 
ed70			;**************************************************************************** 
ed70 00 00		disk_dma:			dw	0		; The current DMA address 
ed72 00			disk_disk:			db	0		; The currently selected disk (only 8-bits used for this one!) 
ed73 00 00		disk_track:			dw	0		; The current track 
ed75 00 00		disk_sec:			dw	0		; The current sector 
ed77 00 00		disk_dph:			dw	0		; The DPH of the currently selected disk 
ed79			 
ed79			; When running from a disk/SD, disk_offset_xxx represent the physical 
ed79			; address of the starting block number. 
ed79 00 08		disk_offset_low:	dw	0x0800		; backward compatible default block number 
ed7b 00 00		disk_offset_hi:		dw	0x0000 
ed7d			 
ed7d			;**************************************************************************** 
ed7d			; When a disk is selected, the address of the READ and WRITE driver  
ed7d			; functions are cached here so that future calls to same will be  
ed7d			; dispatched appropriately.  
ed7d			; @see disk_seldsk 
ed7d			;**************************************************************************** 
ed7d 00 00		.cur_disk_read:		dw	0 
ed7f 00 00		.cur_disk_write:	dw	0 
ed81			 
ed81			include 'disk_config.asm' 
ed81			;**************************************************************************** 
ed81			; Configure the BIOS drive DPH structures here. 
ed81			; 
ed81			; WARNING 
ed81			; 	Do *NOT* expected to mount the same drive more than one  
ed81			;	way and expect it to work without corrupting the drive! 
ed81			;**************************************************************************** 
ed81			; List of available disk drivers 
ed81			disk_driver_nochache:	equ 	1 
ed81			disk_driver_dmcache:	equ 	2 
ed81			 
ed81			; Driver to use in bios 
ed81			cpm_disk_driver:	equ		disk_driver_nochache 
ed81			 
ed81			 
ed81			if cpm_disk_driver = disk_driver_nochache 
ed81			 
ed81				; The SD card offset specified here is relative to the start of the 
ed81				; boot partition. The 32-bit boot partition base address is 
ed81				; expected to be stored in disk_offset_hi and disk_offset_low 
ed81				include 'disk_nocache.asm' 
ed81			;**************************************************************************** 
ed81			; 
ed81			;    Z80 Retro! BIOS  
ed81			; 
ed81			;    Copyright (C) 2021,2022,2023 John Winans 
ed81			; 
ed81			;    This library is free software; you can redistribute it and/or 
ed81			;    modify it under the terms of the GNU Lesser General Public 
ed81			;    License as published by the Free Software Foundation; either 
ed81			;    version 2.1 of the License, or (at your option) any later version. 
ed81			; 
ed81			;    This library is distributed in the hope that it will be useful, 
ed81			;    but WITHOUT ANY WARRANTY; without even the implied warranty of 
ed81			;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
ed81			;    Lesser General Public License for more details. 
ed81			; 
ed81			;    You should have received a copy of the GNU Lesser General Public 
ed81			;    License along with this library; if not, write to the Free Software 
ed81			;    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 
ed81			;    USA 
ed81			; 
ed81			;**************************************************************************** 
ed81			 
ed81			;########################################################################## 
ed81			; set .nc_debug to: 
ed81			;    0 = no debug output 
ed81			;    1 = print messages from new code under development 
ed81			;    2 = print all the above plus the primairy 'normal' debug messages 
ed81			;    3 = print all the above plus verbose 'noisy' debug messages 
ed81			;########################################################################## 
ed81			.nc_debug:	equ	0 
ed81			 
ed81			;########################################################################## 
ed81			; 
ed81			; CP/M 2.2 Alteration Guide p19: 
ed81			; Assuming the drive has been selected, the track has been set, the sector 
ed81			; has been set, and the DMA address has been specified, the READ subroutine 
ed81			; attempts to read one sector based upon these parameters, and returns the 
ed81			; following error codes in register A: 
ed81			; 
ed81			;    0 no errors occurred 
ed81			;    1 non-recoverable error condition occurred 
ed81			; 
ed81			; When an error is reported the BDOS will print the message "BDOS ERR ON 
ed81			; x: BAD SECTOR".  The operator then has the option of typing <cr> to ignore 
ed81			; the error, or ctl-C to abort. 
ed81			; 
ed81			;########################################################################## 
ed81			.nocache_read: 
ed81			if .nc_debug >= 1 
ed81				call	iputs 
ed81				db		".nocache_read entered: \0" 
ed81				call	disk_dump 
ed81			endif 
ed81			 
ed81				; switch to a local stack (we only have a few levels when called from the BDOS!) 
ed81 e5				push	hl					; save HL into the caller's stack 
ed82 21 00 00			ld		hl,0 
ed85 39				add		hl,sp				; HL = SP 
ed86 31 81 fb			ld		sp,bios_stack		; SP = temporary private BIOS stack area 
ed89 e5				push	hl					; save the old SP value in the BIOS stack 
ed8a			 
ed8a c5				push	bc					; save the register pairs we will otherwise clobber 
ed8b d5				push	de					; this is not critical but may make WBOOT cleaner later 
ed8c			 
ed8c 2a 73 ed			ld		hl,(disk_track)		; HL = CP/M track number 
ed8f			 
ed8f				;Check to see if the disk number has changed - Trevor Jacobs - 02-15-2023 
ed8f 3a 77 ed			ld		a,(disk_dph) 
ed92 47				ld		b,a 
ed93 3a 3d f1			ld		a,(.disk_dph_last) 
ed96 b8				cp		b 
ed97 c2 b7 ed			jp		nz,.read_block		; not the same, force a new read 
ed9a			 
ed9a 3a 78 ed			ld		a,(disk_dph+1) 
ed9d 47				ld		b,a 
ed9e 3a 3e f1			ld		a,(.disk_dph_last+1) 
eda1 b8				cp		b 
eda2 c2 b7 ed			jp		nz,.read_block		; not the same, force a new read 
eda5			 
eda5				; Check to see if the SD block in .sdbuf is already the one we want 
eda5 3a 3c ef			ld		a,(.sdbuf_val)		; get the .sdbuf valid flag 
eda8 b7				or		a					; is it a non-zero value? 
eda9 20 0c			jr		nz,.read_block		; block buffer is invalid, read the SD block 
edab			 
edab 3a 3a ef			ld		a,(.sdbuf_trk)		; A = CP/M track LSB 
edae bd				cp		l					; is it the one we want? 
edaf 20 06			jr		nz,.read_block		; LSB does not match, read the SD block 
edb1			 
edb1 3a 3b ef			ld		a,(.sdbuf_trk+1)	; A = CP/M track MSB 
edb4 bc				cp		h					; is it the one we want? 
edb5 28 3e			jr		z,.read_sd_ok		; The SD block in .sdbuf is the one we want! 
edb7			 
edb7			.read_block: 
edb7			if .nc_debug >= 2 
edb7				call	iputs 
edb7				db		".nocache_read cache miss: \0" 
edb7				call	disk_dump 
edb7			endif 
edb7				; Remember drive that is in the cache - Trevor Jacobs - 02-15-2023 
edb7 ed 5b 77 ed		ld		de,(disk_dph) 
edbb ed 53 3d f1		ld		(.disk_dph_last),de 
edbf			 
edbf				; Assume all will go well reading the SD card block. 
edbf				; We only need to touch this if we are going to actually read the SD card. 
edbf 22 3a ef			ld		(.sdbuf_trk),hl		; store the current CP/M track number in the .sdbuf 
edc2 af				xor		a					; A = 0 
edc3 32 3c ef			ld		(.sdbuf_val),a		; mark the .sdbuf as valid 
edc6			 
edc6 cd 0b ef			call	.calc_sd_block		; DE,HL = partition_base + HL 
edc9			 
edc9				; push the 32-bit physical SD block number into the stack in little-endian order 
edc9 d5				push	de					; 32-bit SD block number (big end) 
edca e5				push	hl					; 32-bit SD block number (little end) 
edcb 11 3d ef			ld		de,.sdbuf			; DE = target buffer to read the 512-byte block 
edce cd 6c f8			call	sd_readBlock		; read the SD block 
edd1 e1				pop		hl					; clean the SD block number from the stack 
edd2 d1				pop		de	 
edd3			 
edd3 b7				or		a					; was the SD driver read OK? 
edd4 28 1f			jr		z,.read_sd_ok 
edd6			 
edd6 cd 6d f6			call	iputs 
edd9 ..				db		"BIOS_READ FAILED!\r\n\0" 
eded 3e 01			ld		a,1					; tell CP/M the read failed 
edef 32 3c ef			ld		(.sdbuf_val),a		; mark the .sdbuf as invalid 
edf2 c3 0c ee			jp		.read_ret 
edf5			 
edf5			.read_sd_ok: 
edf5			 
edf5				; calculate the CP/M sector offset address (disk_sec*128) 
edf5 af				xor		a					;clear a, clear carry 
edf6 6f				ld		l,a 
edf7 3a 75 ed			ld		a,(disk_sec)		; must be less than 16 
edfa 1f				rra							; divide a by 2, remainder into carry 
edfb cb 1d			rr		l					; carry into l 
edfd 67				ld		h,a					; HL = A*128 
edfe			 
edfe				; calculate the address of the CP/M sector in the .sdbuf 
edfe 01 3d ef			ld		bc,.sdbuf 
ee01 09				add		hl,bc				; HL = @ of cpm sector in the .sdbuf 
ee02			 
ee02				; copy the data of interest from the SD block 
ee02 ed 5b 70 ed		ld		de,(disk_dma)		; target address 
ee06 01 80 00			ld		bc,0x0080			; number of bytes to copy 
ee09 ed b0			ldir 
ee0b			 
ee0b af				xor	a						; A = 0 = read OK 
ee0c			 
ee0c			.read_ret: 
ee0c d1				pop		de					; restore saved regs 
ee0d c1				pop		bc 
ee0e e1				pop		hl					; HL = original saved stack pointer 
ee0f f9				ld		sp,hl				; SP = original stack address 
ee10 e1				pop		hl					; restore the original  HL value 
ee11			 
ee11 c9				ret 
ee12			 
ee12			;########################################################################## 
ee12			; 
ee12			; CP/M 2.2 Alteration Guide p19: 
ee12			; Write the data from the currently selected DMA address to the currently 
ee12			; selected drive, track, and sector.  The error codes given in the READ 
ee12			; command are returned in register A: 
ee12			; 
ee12			;    0 no errors occurred 
ee12			;    1 non-recoverable error condition occurred 
ee12			; 
ee12			; p34 adds: Upon entry the value of C will be useful for blocking 
ee12			; and deblocking a drive's physical sector sizes: 
ee12			; 
ee12			;  0 = normal sector write 
ee12			;  1 = write into a directory sector 
ee12			;  2 = first sector of a newly used block 
ee12			; 
ee12			; Return the following completion status in register A: 
ee12			; 
ee12			;    0 no errors occurred 
ee12			;    1 non-recoverable error condition occurred 
ee12			; 
ee12			; When an error is reported the BDOS will print the message "BDOS ERR ON 
ee12			; x: BAD SECTOR".  The operator then has the option of typing <cr> to ignore 
ee12			; the error, or ctl-C to abort. 
ee12			; 
ee12			;########################################################################## 
ee12			.nocache_write: 
ee12			 
ee12			if .nc_debug >= 1 
ee12				push	bc 
ee12				call	iputs 
ee12				db		".nocache_write entered, C=\0" 
ee12				pop		bc 
ee12				push	bc 
ee12				ld		a,c 
ee12				call	hexdump_a 
ee12				call	iputs 
ee12				db		": \0" 
ee12				call	disk_dump 
ee12				pop	bc 
ee12			endif 
ee12			 
ee12				; switch to a local stack (we only have a few levels when called from the BDOS!) 
ee12 e5				push	hl					; save HL into the caller's stack 
ee13 21 00 00			ld		hl,0 
ee16 39				add		hl,sp				; HL = SP 
ee17 31 81 fb			ld		sp,bios_stack		; SP = temporary private BIOS stack area 
ee1a e5				push	hl					; save the old SP value in the BIOS stack 
ee1b d5				push	de					; save the register pairs we will otherwise clobber 
ee1c c5				push	bc 
ee1d			 
ee1d 2a 73 ed			ld	hl,(disk_track)			; HL = CP/M track number 
ee20			 
ee20				;Check to see if the disk number has changed - Trevor Jacobs - 02-15-2023 
ee20 3a 77 ed			ld		a,(disk_dph) 
ee23 47				ld		b,a 
ee24 3a 3d f1			ld		a,(.disk_dph_last) 
ee27 b8				cp		b 
ee28 c2 49 ee			jp		nz,.write_miss		; not the same, force a new read 
ee2b			 
ee2b 3a 78 ed			ld		a,(disk_dph+1) 
ee2e 47				ld		b,a 
ee2f 3a 3e f1			ld		a,(.disk_dph_last+1) 
ee32 b8				cp		b 
ee33 c2 49 ee			jp		nz,.write_miss		; not the same, force a new read 
ee36			 
ee36				; Check to see if the SD block in .sdbuf is already the one we want 
ee36 3a 3c ef			ld		a,(.sdbuf_val)		; get the .sdbuf valid flag 
ee39 b7				or		a					; is it a non-zero value? 
ee3a 20 0d			jr		nz,.write_miss		; block buffer is invalid, pre-read the SD block 
ee3c			 
ee3c 3a 3a ef			ld		a,(.sdbuf_trk)		; A = CP/M track LSB 
ee3f bd				cp		l					; is it the one we want? 
ee40 20 07			jr		nz,.write_miss		; LSB does not match, pre-read the SD block 
ee42			 
ee42 3a 3b ef			ld		a,(.sdbuf_trk+1)	; A = CP/M track MSB 
ee45 bc				cp		h					; is it the one we want? 
ee46 ca b0 ee			jp		z,.write_sdbuf		; The SD block in .sdbuf is the one we want! 
ee49			 
ee49			.write_miss: 
ee49			if .nc_debug >= 1 
ee49				call	iputs 
ee49				db		".write cache miss: \0" 
ee49				call	bios_debug_disk 
ee49			endif 
ee49				; Remember drive that is in the cache - Trevor Jacobs - 02-15-2023 
ee49 ed 5b 77 ed		ld		de,(disk_dph) 
ee4d ed 53 3d f1		ld		(.disk_dph_last),de 
ee51			 
ee51				; Assume all will go well reading the SD card block. 
ee51				; We only need to touch this if we are going to actually read the SD card. 
ee51 22 3a ef			ld		(.sdbuf_trk),hl		; store the current CP/M track number in the .sdbuf 
ee54 af				xor		a					; A = 0 
ee55 32 3c ef			ld		(.sdbuf_val),a		; mark the .sdbuf as valid 
ee58			 
ee58				; if C==2 then we are writing into an alloc block (and therefore an SD block) that is not dirty 
ee58 c1				pop		bc					; restore C in case was clobbered above 
ee59 c5				push	bc 
ee5a 3e 02			ld		a,2 
ee5c b9				cp		c 
ee5d 20 10			jr		nz,.write_prerd 
ee5f			 
ee5f				; padd the SD buffer with all 0xe5 
ee5f 21 3d ef			ld		hl,.sdbuf			; buffer to initialize 
ee62 11 3e ef			ld		de,.sdbuf+1			; buffer+1 
ee65 01 ff 01			ld		bc,0x1ff			; number of bytes to initialize 
ee68 36 e5			ld		(hl),0xe5			; set the first byte to 0xe5 
ee6a ed b0			ldir						; set the rest of the bytes to 0xe5 
ee6c c3 b0 ee			jp		.write_sdbuf		; go to write logic (skip the SD card pre-read) 
ee6f			 
ee6f			.write_prerd: 
ee6f				; pre-read the block so we can replace one sector and write it back 
ee6f cd 0b ef			call	.calc_sd_block		; DE,HL = partition_base + HL 
ee72			 
ee72				; push the 32-bit physical SD block number into the stack in little-endian order 
ee72 d5				push	de					; 32-bit SD block number (big end) 
ee73 e5				push	hl					; 32-bit SD block number (little end) 
ee74 11 3d ef			ld		de,.sdbuf			; DE = target buffer to read the 512-byte block 
ee77 cd 6c f8			call	sd_readBlock		; pre-read the SD block 
ee7a e1				pop		hl					; clean the SD block number from the stack 
ee7b d1				pop		de 
ee7c b7				or		a					; was the SD driver read OK? 
ee7d 28 31			jr		z,.write_sdbuf 
ee7f			 
ee7f cd 6d f6			call	iputs 
ee82 ..				db		"BIOS_WRITE SD CARD PRE-READ FAILED!\r\n\0" 
eea8 3e 01			ld		a,1					; tell CP/M the read failed 
eeaa 32 3c ef			ld		(.sdbuf_val),a		; mark the .sdbuf as invalid 
eead c3 05 ef			jp		.write_ret 
eeb0			 
eeb0			.write_sdbuf: 
eeb0				; calculate the CP/M sector offset address (disk_sec*128) 
eeb0 af				xor		a					;clear a, clear carry 
eeb1 6f				ld		l,a 
eeb2 3a 75 ed			ld		a,(disk_sec)		; must be less than 16 
eeb5 1f				rra							; divide a by 2, remainder into carry 
eeb6 cb 1d			rr		l					; carry into l 
eeb8 67				ld		h,a					; HL = A*128 
eeb9			 
eeb9				; calculate the address of the CP/M sector in the .sdbuf 
eeb9 01 3d ef			ld		bc,.sdbuf 
eebc 09				add		hl,bc				; HL = @ of cpm sector in the .sdbuf 
eebd 54				ld		d,h 
eebe 5d				ld		e,l					; DE = @ of cpm sector in the .sdbuf 
eebf			 
eebf				; copy the data of interest /into/ the SD block 
eebf 2a 70 ed			ld		hl,(disk_dma)		; source address 
eec2 01 80 00			ld		bc,0x0080			; number of bytes to copy 
eec5 ed b0			ldir 
eec7			 
eec7				; write the .sdbuf contents to the SD card 
eec7 2a 73 ed			ld      hl,(disk_track) 
eeca cd 0b ef			call	.calc_sd_block		; DE,HL = partition_base + HL 
eecd			 
eecd d5				push	de					; SD block number to write 
eece e5				push	hl 
eecf 11 3d ef			ld		de,.sdbuf			; DE = target buffer to read the 512-byte block 
eed2 cd f0 f8			call	sd_writeBlock		; write the SD block 
eed5 e1				pop		hl					; clean the SD block number from the stack 
eed6 d1				pop		de 
eed7			 
eed7 b7				or		a 
eed8 28 2b			jr		z,.write_ret 
eeda			 
eeda cd 6d f6			call	iputs 
eedd ..				db		"BIOS_WRITE SD CARD WRITE FAILED!\r\n\0" 
ef00 3e 01			ld		a,1					; tell CP/M the read failed 
ef02 32 3c ef			ld		(.sdbuf_val),a		; mark the .sdbuf as invalid 
ef05			 
ef05			.write_ret: 
ef05 c1				pop		bc 
ef06 d1				pop		de					; restore saved regs 
ef07 e1				pop		hl					; HL = original saved stack pointer 
ef08 f9				ld		sp,hl				; SP = original stack address 
ef09 e1				pop		hl					; restore the original  HL value 
ef0a c9				ret 
ef0b			 
ef0b			;########################################################################## 
ef0b			; Calculate the address of the SD block, given the CP/M track number 
ef0b			; in HL and the fact that the currently selected drive's DPH is in  
ef0b			; disk_dph. 
ef0b			; HL = CP/M track number 
ef0b			; Return: the 32-bit block number in DE,HL 
ef0b			; Based on proposal from Trevor Jacobs - 02-15-2023 
ef0b			;########################################################################## 
ef0b			.calc_sd_block: 
ef0b dd 2a 77 ed		ld		ix,(disk_dph)		; IX = current DPH base address 
ef0f dd 5e 10			ld		e,(ix+16)			; DE = low-word of the SD starting block 
ef12 dd 56 11			ld		d,(ix+17)			; DE = low-word of the SD starting block 
ef15 19				add		hl,de 
ef16 e5				push 	hl 
ef17 dd 6e 12			ld		l,(ix+18) 
ef1a dd 66 13			ld		h,(ix+19) 
ef1d 11 00 00			ld		de,0 
ef20 ed 5a			adc		hl,de				; cy flag still set from add hl,de 
ef22 5d				ld		e,l 
ef23 54				ld		d,h 
ef24 e1				pop		hl 
ef25			 
ef25				; add the partition offset 
ef25 3a 79 ed			ld		a,(disk_offset_low) 
ef28 85				add		l 
ef29 6f				ld		l,a 
ef2a 3a 7a ed			ld		a,(disk_offset_low+1) 
ef2d 8c				adc		a,h					; cy flag still set from prior add 
ef2e 67				ld		h,a 
ef2f 3a 7b ed			ld		a,(disk_offset_hi) 
ef32 8b				adc		a,e 
ef33 5f				ld		e,a 
ef34 3a 7c ed			ld		a,(disk_offset_hi+1) 
ef37 8a				adc		a,d 
ef38 57				ld		d,a 
ef39 c9				ret 
ef3a			 
ef3a			;########################################################################## 
ef3a			; A single SD block cache 
ef3a			;########################################################################## 
ef3a			.sdbuf_trk:			; The CP/M track number last left in the .sdbuf 
ef3a 0xff...			ds	2,0xff		; initial value = garbage 
ef3c			.sdbuf_val:			; The CP/M track number in .sdbuf_trk is valid when this is 0 
ef3c 0xff...			ds	1,0xff		; initial value = INVALID 
ef3d			.sdbuf:				; scratch area to use for SD block reading and writing 
ef3d 0xa5...			ds	512,0xa5	; initial value = garbage 
f13d			.disk_dph_last:		; the drive that has a block in the cache 
f13d 00 00			dw	0			; an impossible DPH address 
f13f			 
f13f			;########################################################################## 
f13f			; Called once before library is used. 
f13f			;########################################################################## 
f13f			.nocache_init: 
f13f			;	call	iputs 
f13f			;	db	'NOTICE: disk_nocache library installed. Disk cache disabled.\r\n\0' 
f13f 3e 01			ld		a,1 
f141 32 3c ef			ld		(.sdbuf_val),a	; mark .sdbuf_trk as invalid 
f144 c9				ret 
f145			 
f145			;########################################################################## 
f145			; Goal: Define a CP/M-compatible filesystem that can be implemented using 
f145			; an SDHC card.  An SDHC card is comprised of a number of 512-byte blocks. 
f145			; 
f145			; Plan: 
f145			; - Put 4 128-byte CP/M sectors into each 512-byte SDHC block. 
f145			; - Treat each SDHC block as a CP/M track. 
f145			; 
f145			; This CP/M filesystem has: 
f145			;  128 bytes/sector (CP/M requirement) 
f145			;  4 sectors/track (Retro BIOS designer's choice) 
f145			;  65536 total sectors (max CP/M limit) 
f145			;  65536*128 = 8388608 gross bytes (max CP/M limit) 
f145			;  65536/4 = 16384 tracks 
f145			;  8192 allocation block size BLS (Retro BIOS designer's choice) 
f145			;  8388608/8192 = 1024 gross allocation blocks in our filesystem 
f145			;  32 = number of reserved tracks to hold the O/S 
f145			;  32*512 = 16384 total reserved track bytes 
f145			;  floor(1024-16384/8192) = 1022 total allocation blocks, absent the reserved tracks 
f145			;  512 directory entries (Retro BIOS designer's choice) 
f145			;  512*32 = 16384 total bytes in the directory 
f145			;  ceiling(16384/8192) = 2 allocation blocks for the directory 
f145			; 
f145			;                  DSM<256   DSM>255 
f145			;  BLS  BSH BLM    ------EXM-------- 
f145			;  1024  3    7       0         x 
f145			;  2048  4   15       1         0 
f145			;  4096  5   31       3         1a 
f145			;  8192  6   63       7         3  <---------------------- 
f145			; 16384  7  127      15         7 
f145			; 
f145			; ** NOTE: This filesystem design is inefficient because it is unlikely 
f145			;          that ALL of the allocation blocks will ultimately get used!a 
f145			;########################################################################## 
f145			 
f145			nocache_dph:	macro	sdblk_hi sdblk_lo 
f145				dw	0			; +0 XLT sector translation table (no xlation done) 
f145				dw	0			; +2 scratchpad 
f145				dw	0			; +4 scratchpad 
f145				dw	0			; +6 scratchpad 
f145				dw	disk_dirbuf	; +8 DIRBUF pointer 
f145				dw	nocache_dpb	; +10 DPB pointer 
f145				dw	0			; +12 CSV pointer (optional, not implemented) 
f145				dw	.alv		; +14 ALV pointer 
f145				dw	sdblk_lo	; +16 32-bit starting SD card block offset 
f145				dw	sdblk_hi	; +18 
f145			 
f145			.alv:	ds	0 
f145				ds	(1021/8)+1,0xaa	; scratchpad used by BDOS for disk allocation info 
f145				endm 
f145			 
f145			;########################################################################## 
f145			; The DPB is shared by all the SD drives. 
f145			;########################################################################## 
f145 3f f1			dw	.nocache_init	; .sd_dpb-6	pointer to the init function 
f147 81 ed			dw	.nocache_read	; .sd_dpb-4	pointer to the read function 
f149 12 ee			dw	.nocache_write	; .sd_dpb-2	pointer to the write function 
f14b			nocache_dpb: 
f14b 04 00			dw	4		; SPT 
f14d 06				db	6		; BSH 
f14e 3f				db	63		; BLM 
f14f 03				db	3		; EXM 
f150 fd 03			dw	1021	; DSM (max allocation block number) 
f152 ff 01			dw	511		; DRM 
f154 c0				db	0xc0	; AL0 
f155 00				db	0x00	; AL1 
f156 00 00			dw	0		; CKS 
f158 20 00			dw	32		; OFF
# End of file disk_nocache.asm
f15a				.dph0:	nocache_dph    0x0000 0x0000	; SD logical drive 0  A: 
f15a 00 00			dw	0			; +0 XLT sector translation table (no xlation done) 
f15c 00 00			dw	0			; +2 scratchpad 
f15e 00 00			dw	0			; +4 scratchpad 
f160 00 00			dw	0			; +6 scratchpad 
f162 c1 fa			dw	disk_dirbuf	; +8 DIRBUF pointer 
f164 4b f1			dw	nocache_dpb	; +10 DPB pointer 
f166 00 00			dw	0			; +12 CSV pointer (optional, not implemented) 
f168 6e f1			dw	.alv		; +14 ALV pointer 
f16a 00 00			dw	0x0000	; +16 32-bit starting SD card block offset 
f16c 00 00			dw	0x0000	; +18 
f16e 00...		.alv:	ds	0 
f16e 0xaa...			ds	(1021/8)+1,0xaa	; scratchpad used by BDOS for disk allocation info 
f1ee				endm 
# End of macro nocache_dph
f1ee				.dph1:	nocache_dph    0x0000 0x4000	; SD logical drive 1  B: 
f1ee 00 00			dw	0			; +0 XLT sector translation table (no xlation done) 
f1f0 00 00			dw	0			; +2 scratchpad 
f1f2 00 00			dw	0			; +4 scratchpad 
f1f4 00 00			dw	0			; +6 scratchpad 
f1f6 c1 fa			dw	disk_dirbuf	; +8 DIRBUF pointer 
f1f8 4b f1			dw	nocache_dpb	; +10 DPB pointer 
f1fa 00 00			dw	0			; +12 CSV pointer (optional, not implemented) 
f1fc 02 f2			dw	.alv		; +14 ALV pointer 
f1fe 00 40			dw	0x4000	; +16 32-bit starting SD card block offset 
f200 00 00			dw	0x0000	; +18 
f202 00...		.alv:	ds	0 
f202 0xaa...			ds	(1021/8)+1,0xaa	; scratchpad used by BDOS for disk allocation info 
f282				endm 
# End of macro nocache_dph
f282				.dph2:	nocache_dph    0x0000 0x8000	; SD logical drive 2  C: 
f282 00 00			dw	0			; +0 XLT sector translation table (no xlation done) 
f284 00 00			dw	0			; +2 scratchpad 
f286 00 00			dw	0			; +4 scratchpad 
f288 00 00			dw	0			; +6 scratchpad 
f28a c1 fa			dw	disk_dirbuf	; +8 DIRBUF pointer 
f28c 4b f1			dw	nocache_dpb	; +10 DPB pointer 
f28e 00 00			dw	0			; +12 CSV pointer (optional, not implemented) 
f290 96 f2			dw	.alv		; +14 ALV pointer 
f292 00 80			dw	0x8000	; +16 32-bit starting SD card block offset 
f294 00 00			dw	0x0000	; +18 
f296 00...		.alv:	ds	0 
f296 0xaa...			ds	(1021/8)+1,0xaa	; scratchpad used by BDOS for disk allocation info 
f316				endm 
# End of macro nocache_dph
f316				.dph3:	nocache_dph    0x0000 0xc000	; SD logical drive 3  D: 
f316 00 00			dw	0			; +0 XLT sector translation table (no xlation done) 
f318 00 00			dw	0			; +2 scratchpad 
f31a 00 00			dw	0			; +4 scratchpad 
f31c 00 00			dw	0			; +6 scratchpad 
f31e c1 fa			dw	disk_dirbuf	; +8 DIRBUF pointer 
f320 4b f1			dw	nocache_dpb	; +10 DPB pointer 
f322 00 00			dw	0			; +12 CSV pointer (optional, not implemented) 
f324 2a f3			dw	.alv		; +14 ALV pointer 
f326 00 c0			dw	0xc000	; +16 32-bit starting SD card block offset 
f328 00 00			dw	0x0000	; +18 
f32a 00...		.alv:	ds	0 
f32a 0xaa...			ds	(1021/8)+1,0xaa	; scratchpad used by BDOS for disk allocation info 
f3aa				endm 
# End of macro nocache_dph
f3aa				.dph4:	nocache_dph    0x0001 0x0000	; SD logical drive 4  E: 
f3aa 00 00			dw	0			; +0 XLT sector translation table (no xlation done) 
f3ac 00 00			dw	0			; +2 scratchpad 
f3ae 00 00			dw	0			; +4 scratchpad 
f3b0 00 00			dw	0			; +6 scratchpad 
f3b2 c1 fa			dw	disk_dirbuf	; +8 DIRBUF pointer 
f3b4 4b f1			dw	nocache_dpb	; +10 DPB pointer 
f3b6 00 00			dw	0			; +12 CSV pointer (optional, not implemented) 
f3b8 be f3			dw	.alv		; +14 ALV pointer 
f3ba 00 00			dw	0x0000	; +16 32-bit starting SD card block offset 
f3bc 01 00			dw	0x0001	; +18 
f3be 00...		.alv:	ds	0 
f3be 0xaa...			ds	(1021/8)+1,0xaa	; scratchpad used by BDOS for disk allocation info 
f43e				endm 
# End of macro nocache_dph
f43e				.dph5:	nocache_dph    0x0001 0x4000	; SD logical drive 5  F: 
f43e 00 00			dw	0			; +0 XLT sector translation table (no xlation done) 
f440 00 00			dw	0			; +2 scratchpad 
f442 00 00			dw	0			; +4 scratchpad 
f444 00 00			dw	0			; +6 scratchpad 
f446 c1 fa			dw	disk_dirbuf	; +8 DIRBUF pointer 
f448 4b f1			dw	nocache_dpb	; +10 DPB pointer 
f44a 00 00			dw	0			; +12 CSV pointer (optional, not implemented) 
f44c 52 f4			dw	.alv		; +14 ALV pointer 
f44e 00 40			dw	0x4000	; +16 32-bit starting SD card block offset 
f450 01 00			dw	0x0001	; +18 
f452 00...		.alv:	ds	0 
f452 0xaa...			ds	(1021/8)+1,0xaa	; scratchpad used by BDOS for disk allocation info 
f4d2				endm 
# End of macro nocache_dph
f4d2				.dph6:	nocache_dph    0x0001 0x8000	; SD logical drive 6  G: 
f4d2 00 00			dw	0			; +0 XLT sector translation table (no xlation done) 
f4d4 00 00			dw	0			; +2 scratchpad 
f4d6 00 00			dw	0			; +4 scratchpad 
f4d8 00 00			dw	0			; +6 scratchpad 
f4da c1 fa			dw	disk_dirbuf	; +8 DIRBUF pointer 
f4dc 4b f1			dw	nocache_dpb	; +10 DPB pointer 
f4de 00 00			dw	0			; +12 CSV pointer (optional, not implemented) 
f4e0 e6 f4			dw	.alv		; +14 ALV pointer 
f4e2 00 80			dw	0x8000	; +16 32-bit starting SD card block offset 
f4e4 01 00			dw	0x0001	; +18 
f4e6 00...		.alv:	ds	0 
f4e6 0xaa...			ds	(1021/8)+1,0xaa	; scratchpad used by BDOS for disk allocation info 
f566				endm 
# End of macro nocache_dph
f566				.dph7:	nocache_dph    0x0001 0xc000	; SD logical drive 7  H: 
f566 00 00			dw	0			; +0 XLT sector translation table (no xlation done) 
f568 00 00			dw	0			; +2 scratchpad 
f56a 00 00			dw	0			; +4 scratchpad 
f56c 00 00			dw	0			; +6 scratchpad 
f56e c1 fa			dw	disk_dirbuf	; +8 DIRBUF pointer 
f570 4b f1			dw	nocache_dpb	; +10 DPB pointer 
f572 00 00			dw	0			; +12 CSV pointer (optional, not implemented) 
f574 7a f5			dw	.alv		; +14 ALV pointer 
f576 00 c0			dw	0xc000	; +16 32-bit starting SD card block offset 
f578 01 00			dw	0x0001	; +18 
f57a 00...		.alv:	ds	0 
f57a 0xaa...			ds	(1021/8)+1,0xaa	; scratchpad used by BDOS for disk allocation info 
f5fa				endm 
# End of macro nocache_dph
f5fa			 
f5fa				dph_vec: 
f5fa 5a f1				dw	.dph0 
f5fc ee f1				dw	.dph1 
f5fe 82 f2				dw	.dph2 
f600 16 f3				dw	.dph3 
f602 aa f3				dw	.dph4 
f604 3e f4				dw	.dph5 
f606 d2 f4				dw	.dph6 
f608 66 f5				dw	.dph7 
f60a			endif 
f60a			 
f60a			 
f60a			if cpm_disk_driver = disk_driver_dmcache 
f60a			 
f60a				; NOTE: dmcache ONLY works on a single-partition starting at SD block number 0x0800 
f60a				include 'disk_dmcache.asm' 
f60a				.dph0:	dmcache_dph	0x0000 0x0800	; This is absolute, NOT partition-relative! 
f60a			 
f60a				dph_vec: 
f60a					dw	.dph0 
f60a			 
f60a			endif 
f60a			 
f60a			dph_vec_num:	equ	($-dph_vec)/2		; number of configured drives 
# End of file disk_config.asm
# End of file disk_callgate.asm
f60a			include 'sio.asm' 
f60a			;**************************************************************************** 
f60a			;	Adopted for Teach Z80 
f60a			; 
f60a			;	Allows initialization with /64 clock division, to allow more 
f60a			;	Baudrates generated directly from the TeachZ80 synthetic clock 
f60a			;	wihtout using the CTC dividers 
f60a			; 
f60a			;	Keeps full compatibility with original code from John 
f60a			; 
f60a			;**************************************************************************** 
f60a			; 
f60a			;	 Copyright (C) 2021 John Winans 
f60a			; 
f60a			;	 This library is free software; you can redistribute it and/or 
f60a			;	 modify it under the terms of the GNU Lesser General Public 
f60a			;	 License as published by the Free Software Foundation; either 
f60a			;	 version 2.1 of the License, or (at your option) any later version. 
f60a			; 
f60a			;	 This library is distributed in the hope that it will be useful, 
f60a			;	 but WITHOUT ANY WARRANTY; without even the implied warranty of 
f60a			;	 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
f60a			;	 Lesser General Public License for more details. 
f60a			; 
f60a			;	 You should have received a copy of the GNU Lesser General Public 
f60a			;	 License along with this library; if not, write to the Free Software 
f60a			;	 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 
f60a			;	 USA 
f60a			; 
f60a			; https://github.com/johnwinans/2063-Z80-cpm 
f60a			; 
f60a			;**************************************************************************** 
f60a			 
f60a			; Drivers for the SIO  
f60a			 
f60a			;############################################################## 
f60a			; Initialization string for the Z80 SIO, clock /16 
f60a			;############################################################## 
f60a			.sio_init_wr_16: 
f60a 18				db	00011000b	; wr0 = reset everything 
f60b 04				db	00000100b	; wr0 = select reg 4 
f60c 44				db	01000100b	; wr4 = /16 N1 (115200 from 1.8432 MHZ clk) 
f60d 03				db	00000011b	; wr0 = select reg 3 
f60e c1				db	11000001b	; wr3 = RX enable, 8 bits/char 
f60f 05				db	00000101b	; wr0 = select reg 5 
f610 68				db	01101000b	; wr5 = DTR=0, TX enable, 8 bits/char 
f611			.sio_init_len_wr:   equ $-.sio_init_wr_16 
f611			 
f611			 
f611			;############################################################## 
f611			; Initialization string for the Z80 SIO, clock /64 
f611			;############################################################## 
f611			.sio_init_wr_64: 
f611 18				db	00011000b	; wr0 = reset everything 
f612 04				db	00000100b	; wr0 = select reg 4 
f613 c4				db	11000100b	; wr4 = /64 N1 (115200 from 7.3728 MHZ clk) 
f614 03				db	00000011b	; wr0 = select reg 3 
f615 c1				db	11000001b	; wr3 = RX enable, 8 bits/char 
f616 05				db	00000101b	; wr0 = select reg 5 
f617 68				db	01101000b	; wr5 = DTR=0, TX enable, 8 bits/char 
f618			 
f618			;############################################################## 
f618			; init SIO port A/B 
f618			; Clobbers HL, BC, AF 
f618			;############################################################## 
f618			siob_init: 
f618 0e 33			ld	c,sio_bc	; port to write into (port B control) 
f61a c3 1f f6			jp	.sio_init 
f61d			 
f61d			sioa_init: 
f61d 0e 32			ld	c,sio_ac	; port to write into (port A control) 
f61f			 
f61f			.sio_init: 
f61f 21 0a f6			ld	hl,.sio_init_wr_16	; point to init string 
f622 06 07			ld	b,.sio_init_len_wr ; number of bytes to send 
f624 ed b3			otir			; write B bytes from (HL) into port in the C reg 
f626 c9				ret 
f627			 
f627			;############################################################## 
f627			; init SIO port A/B with clock divided by 64 
f627			; Clobbers HL, BC, AF 
f627			;############################################################## 
f627			siob_init_64: 
f627 0e 33			ld	c,sio_bc	; port to write into (port B control) 
f629 c3 2e f6			jp	.sio_init_64 
f62c			 
f62c			sioa_init_64: 
f62c 0e 32			ld	c,sio_ac	; port to write into (port A control) 
f62e			 
f62e			.sio_init_64: 
f62e 21 11 f6			ld	hl,.sio_init_wr_64	; point to init string 
f631 06 07			ld	b,.sio_init_len_wr ; number of bytes to send 
f633 ed b3			otir			; write B bytes from (HL) into port in the C reg 
f635 c9				ret 
f636			 
f636			;############################################################## 
f636			; Return NZ if sio A tx is ready 
f636			; Clobbers: AF 
f636			;############################################################## 
f636			sioa_tx_ready: 
f636 db 32			in	a,(sio_ac)	; read sio control status byte 
f638 e6 04			and	4		    ; check the xmtr empty bit 
f63a c9				ret			    ; a = 0 = not ready 
f63b			 
f63b			;############################################################## 
f63b			; Return NZ if sio B tx is ready 
f63b			; Clobbers: AF 
f63b			;############################################################## 
f63b			siob_tx_ready: 
f63b db 33			in	a,(sio_bc)	; read sio control status byte 
f63d e6 04			and	4		    ; check the xmtr empty bit 
f63f c9				ret			    ; a = 0 = not ready 
f640			 
f640			;############################################################## 
f640			; Return NZ (with A=1) if sio A rx is ready and Z (with A=0) if not ready. 
f640			; Clobbers: AF 
f640			;############################################################## 
f640			con_rx_ready: 
f640			sioa_rx_ready: 
f640 db 32			in	a,(sio_ac)	; read sio control status byte 
f642 e6 01			and	1		    ; check the rcvr ready bit 
f644 c9				ret			    ; 0 = not ready 
f645			 
f645			;############################################################## 
f645			; Return NZ (with A=1) if sio B rx is ready and Z (with A=0) if not ready.  
f645			; Clobbers: AF 
f645			;############################################################## 
f645			siob_rx_ready: 
f645 db 33			in	a,(sio_bc)	; read sio control status byte 
f647 e6 01			and	1		    ; check the rcvr ready bit 
f649 c9				ret			    ; 0 = not ready 
f64a			 
f64a			;############################################################## 
f64a			; Wait for the transmitter to become ready and then 
f64a			; print the character in the C register. 
f64a			; Clobbers: AF 
f64a			;############################################################## 
f64a			siob_tx_char: 
f64a cd 3b f6			call siob_tx_ready 
f64d 28 fb			jr	 z,siob_tx_char 
f64f 79				ld	 a,c 
f650 d3 31			out	 (sio_bd),a	; send the character 
f652 c9				ret 
f653			 
f653			con_tx_char: 
f653			sioa_tx_char: 
f653 cd 36 f6			call sioa_tx_ready 
f656 28 fb			jr	 z,sioa_tx_char 
f658 79				ld	 a,c 
f659 d3 30			out  (sio_ad),a	; send the character 
f65b c9				ret 
f65c			 
f65c			;############################################################## 
f65c			; Wait for the receiver to become ready and then return the  
f65c			; character in the A register. 
f65c			; Clobbers: AF 
f65c			;############################################################## 
f65c			siob_rx_char: 
f65c cd 45 f6			call	siob_rx_ready 
f65f 28 fb			jr	z,siob_rx_char 
f661 3a 31 00			ld	a,(sio_bd) 
f664 c9				ret 
f665			 
f665			con_rx_char: 
f665			sioa_rx_char: 
f665 cd 40 f6			call	sioa_rx_ready 
f668 28 fb			jr	z,sioa_rx_char 
f66a db 30			in	a,(sio_ad) 
f66c c9				ret
# End of file sio.asm
f66d			include 'puts.asm' 
f66d			;**************************************************************************** 
f66d			; 
f66d			;    Copyright (C) 2021 John Winans 
f66d			; 
f66d			;    This library is free software; you can redistribute it and/or 
f66d			;    modify it under the terms of the GNU Lesser General Public 
f66d			;    License as published by the Free Software Foundation; either 
f66d			;    version 2.1 of the License, or (at your option) any later version. 
f66d			; 
f66d			;    This library is distributed in the hope that it will be useful, 
f66d			;    but WITHOUT ANY WARRANTY; without even the implied warranty of 
f66d			;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
f66d			;    Lesser General Public License for more details. 
f66d			; 
f66d			;    You should have received a copy of the GNU Lesser General Public 
f66d			;    License along with this library; if not, write to the Free Software 
f66d			;    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 
f66d			;    USA 
f66d			; 
f66d			; https://github.com/johnwinans/2063-Z80-cpm 
f66d			; 
f66d			;**************************************************************************** 
f66d			 
f66d			;############################################################## 
f66d			; Write the null-terminated string starting after the call 
f66d			; instruction invoking this subroutine to the console. 
f66d			; Clobbers AF, C 
f66d			;############################################################## 
f66d			iputs: 
f66d e3			        ex      (sp),hl                 ; hl = @ of string to print 
f66e cd 7a f6			call	.puts_loop 
f671 23			        inc     hl                      ; point past the end of the string 
f672 e3			        ex      (sp),hl 
f673 c9			        ret 
f674			 
f674			;############################################################## 
f674			; Write the null-terminated staring starting at the address in  
f674			; HL to the console.   
f674			; Clobbers: AF, C 
f674			;############################################################## 
f674			puts: 
f674 e5				push	hl 
f675 cd 7a f6			call	.puts_loop 
f678 e1				pop	hl 
f679 c9				ret 
f67a			 
f67a			.puts_loop: 
f67a 7e			        ld      a,(hl)                  ; get the next byte to send 
f67b b7			        or      a 
f67c 28 07		        jr      z,.puts_done            ; if A is zero, return 
f67e 4f			        ld      c,a 
f67f cd 53 f6		        call    con_tx_char 
f682 23			        inc     hl                      ; point to next byte to write 
f683 18 f5		        jr      .puts_loop 
f685			.puts_done: 
f685 c9			        ret 
f686			 
f686			;############################################################## 
f686			; Print a CRLF  
f686			; Clobbers AF, C 
f686			;############################################################## 
f686			puts_crlf: 
f686 cd 6d f6		        call    iputs 
f689 ..			        defb    '\r\n\0' 
f68c c9			        ret 
f68d			 
f68d			;############################################################## 
f68d			; Prints the (unsigned) value in HL as a decimal value to the 
f68d			; console. If e is 1, leading zeros are not printed 
f68d			; Clobbers nothing 
f68d			;############################################################## 
f68d			puts_decimal: 
f68d f5			        push	af 
f68e d5				push	de 
f68f e5				push	hl 
f690 c5				push	bc 
f691 01 f0 d8		        ld      bc, -10000 
f694 cd b5 f6		        call    .puts_decimal_start 
f697 01 18 fc		        ld      bc, -1000 
f69a cd b5 f6		        call    .puts_decimal_start 
f69d 01 9c ff		        ld      bc, -100 
f6a0 cd b5 f6		        call    .puts_decimal_start 
f6a3 01 f6 ff		        ld      bc, -10 
f6a6 cd b5 f6		        call    .puts_decimal_start 
f6a9 3e 30		        ld      a,'0' 
f6ab 85			        add     a, l 
f6ac 4f			        ld      c, a 
f6ad cd 53 f6		        call    con_tx_char 
f6b0 c1			        pop	bc 
f6b1 e1				pop	hl 
f6b2 d1				pop	de 
f6b3 f1				pop	af 
f6b4 c9			        ret 
f6b5			 
f6b5			.puts_decimal_start: 
f6b5 16 ff		        ld      d,-1                    ; use d as a counter 
f6b7			.puts_decimal_loop: 
f6b7 14			        inc     d                       ; increment d 
f6b8 09			        add     hl,bc                   ; hl = hl + bc (bc is negative). if result is < 0, carry is set 
f6b9 38 fc		        jr      c,.puts_decimal_loop    ; if carry is 1, hl was bigger than -bc, continue loop 
f6bb ed 42		        sbc     hl,bc                   ; hl = hl-bc-c. (bc is negative) restores hl to what it was before the last loop 
f6bd 7a			        ld      a, d                    ; check if d is zero 
f6be b7			        or      a                        
f6bf 20 04		        jr      nz,.puts_dec_print      ; if not zero, print it 
f6c1 7b			        ld      a, e                    ; if zero, check e 
f6c2 b7			        or      a 
f6c3 20 09		        jr      nz,.puts_dec_skip       ; if e is not zero, skip printing d 
f6c5			.puts_dec_print: 
f6c5 7a			        ld      a, d                    ; add ascii of '0' 
f6c6 c6 30		        add     '0' 
f6c8 4f			        ld      c, a                    ; store in c to print         
f6c9 1e 00		        ld      e, 0                    ; clear e, all following characters print now 
f6cb cd 53 f6		        call    con_tx_char 
f6ce			.puts_dec_skip: 
f6ce c9			        ret
# End of file puts.asm
f6cf			include 'hexdump.asm' 
f6cf			;**************************************************************************** 
f6cf			; 
f6cf			;	 Copyright (C) 2021 John Winans 
f6cf			; 
f6cf			;	 This library is free software; you can redistribute it and/or 
f6cf			;	 modify it under the terms of the GNU Lesser General Public 
f6cf			;	 License as published by the Free Software Foundation; either 
f6cf			;	 version 2.1 of the License, or (at your option) any later version. 
f6cf			; 
f6cf			;	 This library is distributed in the hope that it will be useful, 
f6cf			;	 but WITHOUT ANY WARRANTY; without even the implied warranty of 
f6cf			;	 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
f6cf			;	 Lesser General Public License for more details. 
f6cf			; 
f6cf			;	 You should have received a copy of the GNU Lesser General Public 
f6cf			;	 License along with this library; if not, write to the Free Software 
f6cf			;	 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 
f6cf			;	 USA 
f6cf			; 
f6cf			; https://github.com/johnwinans/2063-Z80-cpm 
f6cf			; 
f6cf			;**************************************************************************** 
f6cf			 
f6cf			;############################################################################# 
f6cf			; Dump BC bytes of memory from address in HL. 
f6cf			; if E is zero, no fancy formatting 
f6cf			; Does not clobber any registers 
f6cf			;############################################################################# 
f6cf			hexdump: 
f6cf f5				push	af 
f6d0 d5				push	de 
f6d1 e5				push	hl 
f6d2 c5				push	bc 
f6d3 c3 f3 f6			jp	    .hexdump0 
f6d6			 
f6d6			.hexdump_loop: 
f6d6 7b				ld	    a,e			; fancy format or continuous? 
f6d7 b7				or	    a 
f6d8 28 0e			jr	    z,.hd_not8		; not fancy -> hd_not8 
f6da			 
f6da 7d				ld	    a,l 
f6db e6 0f			and	    0x0f 
f6dd 28 11			jr	    z,.hexdump0n 
f6df fe 08			cp	    0x08			; put an extra space between positiioons 7 and 8 
f6e1 20 05			jr	    nz,.hd_not8 
f6e3 0e 20			ld	    c,' ' 
f6e5 cd 53 f6			call	con_tx_char 
f6e8			.hd_not8: 
f6e8 0e 20			ld	    c,' ' 
f6ea cd 53 f6			call	con_tx_char 
f6ed c3 05 f7			jp	    .hexdump1 
f6f0			 
f6f0			.hexdump0n: 
f6f0 cd 86 f6			call	puts_crlf 
f6f3			.hexdump0: 
f6f3 7c				ld	    a,h 
f6f4 cd 24 f7			call	hexdump_a 
f6f7 7d				ld	    a,l 
f6f8 cd 24 f7			call	hexdump_a 
f6fb 0e 3a			ld	    c,':' 
f6fd cd 53 f6			call	con_tx_char 
f700 0e 20			ld	    c,' ' 
f702 cd 53 f6			call	con_tx_char 
f705				 
f705			.hexdump1: 
f705 7e				ld	    a,(hl) 
f706 cd 24 f7			call	hexdump_a 
f709 23				inc	    hl 
f70a			 
f70a c1				pop	    bc 
f70b 0b				dec	    bc 
f70c c5				push	bc 
f70d			 
f70d 78				ld	    a,b 
f70e b1				or	    c 
f70f 20 c5			jr	    nz,.hexdump_loop 
f711 cd 86 f6			call	puts_crlf 
f714			 
f714 c1				pop	    bc 
f715 e1				pop	    hl 
f716 d1				pop	    de 
f717 f1				pop	    af 
f718 c9				ret 
f719			 
f719			;############################################################################# 
f719			; Print the value in HL in hex 
f719			; Clobbers C 
f719			;############################################################################# 
f719			hexdump_hl: 
f719 f5				push 	af 
f71a 7c				ld	    a,h 
f71b cd 24 f7			call	hexdump_a 
f71e 7d				ld	    a,l 
f71f cd 24 f7			call	hexdump_a 
f722 f1				pop		af 
f723 c9				ret 
f724			 
f724			;############################################################################# 
f724			; Print the value in A in hex 
f724			; Clobbers C 
f724			;############################################################################# 
f724			hexdump_a: 
f724 f5				push	af 
f725 cb 3f			srl	a 
f727 cb 3f			srl	a 
f729 cb 3f			srl	a 
f72b cb 3f			srl	a 
f72d cd 39 f7			call	.hexdump_nib 
f730 f1				pop	af 
f731 f5				push	af 
f732 e6 0f			and	0x0f 
f734 cd 39 f7			call	.hexdump_nib 
f737 f1				pop	af 
f738 c9				ret 
f739			 
f739			.hexdump_nib: 
f739 c6 30			add	'0' 
f73b fe 3a			cp	'9'+1 
f73d fa 42 f7			jp	m,.hexdump_num 
f740 c6 07			add	'A'-'9'-1 
f742			.hexdump_num: 
f742 4f				ld	c,a 
f743 c3 53 f6			jp	con_tx_char	   ; tail
# End of file hexdump.asm
f746			include 'sdcard.asm' 
f746			;**************************************************************************** 
f746			; 
f746			;   TeachZ80 SD Card Driver 
f746			; 
f746			;   Based on the original code from John Winans, published under GNU LGPL: 
f746			;   https://github.com/Z80-Retro/2063-Z80-cpm/blob/main/lib/sdcard.asm 
f746			; 
f746			;	An SD card library suitable for talking to SD cards in SPI mode 0.	 
f746			; 
f746			; 	References: 
f746			; 	- SD Simplified Specifications, Physical Layer Simplified Specification,  
f746			;   	Version 8.00:    https://www.sdcard.org/downloads/pls/ 
f746			; 
f746			; 	The details on operating an SD card in SPI mode can be found in  
f746			; 	Section 7 of the SD specification, p242-264. 
f746			; 
f746			; 	To initialize an SDHC/SDXC card: 
f746			; 	- send at least 74 CLKs 
f746			; 	- send CMD0 & expect reply message = 0x01 (enter SPI mode) 
f746			; 	- send CMD8 (establish that the host uses Version 2.0 SD SPI protocol) 
f746			; 	- send ACMD41 (finish bringing the SD card on line) 
f746			; 	- send CMD58 to verify the card is SDHC/SDXC mode (512-byte block size) 
f746			; 
f746			; 	At this point the card is on line and ready to read and write  
f746			; 	memory blocks. 
f746			; 
f746			; 	- use CMD17 to read one 512-byte block 
f746			; 	- use CMD24 to write one 512-byte block 
f746			; 
f746			;	Author: 
f746			;	Christian Luethi 
f746			; 
f746			;############################################################################ 
f746			 
f746			;**************************************************************************** 
f746			; Constants 
f746			;**************************************************************************** 
f746			.sd_debug: 		equ 1 
f746 40 00 00 00 00 95	.sd_cmd0:		db	 0|0x40,0,0,0,0,0x94|0x01 
f74c 48 00 00 01 aa 87	.sd_cmd8:		db	 8|0x40,0,0,0x01,0xaa,0x86|0x01 
f752 77 00 00 00 00 01	.sd_cmd55:		db	55|0x40,0,0,0,0,0x00|0x01 
f758 69 40 00 00 00 01	.sd_acmd41:		db	41|0x40,0x40,0,0,0,0x00|0x01 
f75e 7a 00 00 00 00 01	.sd_cmd58:		db	58|0x40,0,0,0,0,0x00|0x01 
f764			 
f764			;############################################################################ 
f764			; SSEL = HI (deassert) 
f764			; wait at least 1 msec after power up 
f764			; send at least 74 (80) SCLK rising edges 
f764			; Clobbers A, B, C 
f764			;############################################################################ 
f764			.sd_wakeup: 
f764 06 0a			ld		b,10						; 10*8 = 80 bits to read 
f766 0e ff			ld		c,0xFF						; set c=0xff, write will leave MOSI high 
f768			.sd_wakeup_loop: 
f768 cd 99 f9			call	spi_write8					; write 8 bits (causes 8 clocks with MOSI high) 
f76b 10 fb			djnz	.sd_wakeup_loop				; if not yet done, do another byte 
f76d c9				ret 
f76e			 
f76e			;############################################################################ 
f76e			; Set SSEL high or low 
f76e			; Generate 8 clocks before and after, according SD specification 
f76e			; Clobbers A, C 
f76e			;############################################################################ 
f76e			.sd_ssel_low: 
f76e 0e ff			ld		c, 0xFF						; set c=0xff, write will leave MOSI high 
f770 cd 99 f9			call	spi_write8					; generate 8 clocks 
f773 3a c0 fa			ld		a,(gpio_out_cache)			; read output cache 
f776 e6 fb			and		~gpio_out_sd_ssel			; clear sd_sel bit 
f778 e6 fd			and		~gpio_out_sd_clk			; not required 
f77a d3 10			out		(gpio_out_0),a				; set sd_sel line to the required state 
f77c 32 c0 fa			ld		(gpio_out_cache), a			; update the output cache with the new state 
f77f cd 99 f9			call	spi_write8					; create another 8 clocks 
f782 c9				ret		 
f783			 
f783			.sd_ssel_high: 
f783 0e ff			ld		c, 0xFF						; set c=0xff, write will leave MOSI high 
f785 cd 99 f9			call	spi_write8					; generate 8 clocks 
f788 3a c0 fa			ld		a,(gpio_out_cache)			; read output cache 
f78b f6 04			or		gpio_out_sd_ssel			; set sd_sel bit 
f78d e6 fd			and		~gpio_out_sd_clk			; not required 
f78f d3 10			out		(gpio_out_0),a				; set sd_sel line to the required state 
f791 32 c0 fa			ld		(gpio_out_cache), a			; update the output cache with the new state 
f794 cd 99 f9			call	spi_write8					; create another 8 clocks 
f797 c9				ret		 
f798			 
f798			;############################################################################ 
f798			; Send the command pointed by IX and reads expected amount of reseponse bytes 
f798			; The response is stored in the .sd_scratch buffer. The amount of bytes sent 
f798			; in a command is fixed to 6. If e is set to one, the function also controls 
f798			; the ssel line. If e is set to one, ssel line needs to be controlled by  
f798			; the calling function (required for read and writes) 
f798			;	- IX: Address of buffer to send to card 
f798			;	- B : Amount of bytes to read 
f798			;	- E : 0 = Do not control SSEL, 1 = control SSEL 
f798			; 
f798			; When reading, the function tries up to 0x0F times to read a byte with  
f798			; bit 7 cleared according the SD specification. When received, or after,  
f798			; the maximum amount of retries, it continues to read the reamining amount 
f798			; of bytes and returns 
f798			; 
f798			; Clobbers A, IX, IY 
f798			;####################################################################cat ######## 
f798			.sd_command: 
f798 d5				push 	de								; for later convenience 
f799 c5				push 	bc								; required by the function 
f79a cb 43			bit		0,e								; check if bit 0 in e is 0 
f79c 28 03			jr		z,.sd_command_send				; if so, skip controlling ssel 
f79e cd 6e f7			call	.sd_ssel_low					; set ssel low 
f7a1			.sd_command_send: 
f7a1 fd 21 93 f9		ld		iy,.sd_scratch					; iy = scratch buffer 
f7a5 06 06			ld		b, 6							; we will send 6 bytes 
f7a7			.sd_command_send_loop: 
f7a7 dd 4e 00			ld 		c,(ix+0)						; load next character to send 
f7aa cd 99 f9			call	spi_write8;						; send the character 
f7ad dd 23			inc		ix								; ix point to next character 
f7af 10 f6			djnz	.sd_command_send_loop			; repeat until b is 0							 
f7b1 06 0f			ld		b, 0x0f							; b now holds the max amount of read-tries before giving up 
f7b3			.sd_command_read_start:						 
f7b3 cd 26 fa			call 	spi_read8						; read one byte 
f7b6 cb 7f			bit		7,a								; check if bit 7 is set 
f7b8 28 02			jr		z,.sd_command_read_remaining	; if not set, continue reading remaining bytes, else try again 
f7ba 10 f7			djnz	.sd_command_read_start			; repeat until b is 0 
f7bc			.sd_command_read_remaining:							 
f7bc fd 77 00			ld		(iy+0),a						; store the last byte received 
f7bf c1				pop		bc								; peek original bc 
f7c0 c5				push 	bc	 
f7c1 05				dec		b								; decrement b 
f7c2 28 0c			jr		z,.sd_command_finish			; if here b is zero, we are done 
f7c4 fd 23			inc 	iy								; increment destination pointer 
f7c6			.sd_command_read_loop: 
f7c6 cd 26 fa			call 	spi_read8						; read next byte 
f7c9 fd 77 00			ld		(iy+0),a						; store it 
f7cc fd 23			inc 	iy	 
f7ce 10 f6			djnz	.sd_command_read_loop			; repeat until b is 0 
f7d0			.sd_command_finish: 
f7d0 c1				pop		bc								; restore  
f7d1 d1				pop 	de								; restore  
f7d2 cb 43			bit		0,e								; check if bit 0 in e is 0 
f7d4 28 03			jr		z,.sd_command_exit				; if so, skip controlling ssel 
f7d6 cd 83 f7			call	.sd_ssel_high					; set ssel low 
f7d9			.sd_command_exit: 
f7d9 c9				ret 
f7da			 
f7da			;############################################################################ 
f7da			; Initialize the SD and make it ready to following block read and writes 
f7da			; 
f7da			; Performs the following: 
f7da			;	- check if a card is installed in the slot 
f7da			; 	- wake-up the SD card by sending 80 clocks with ssel set high 
f7da			; 	- send CMD 0, check valid reposnse 
f7da			;	- send CMD 8, check valid response 
f7da			;	- loop sending CMD 55 followed by ACMD41, and wait until card becomes ready 
f7da			;	- send CMD 58 and check card capacity (SD or XC) 
f7da			; 
f7da			; Returns the result of the operation in A: 
f7da			; 	- A = 0 : Card successfully accessed 
f7da			; 	- A = 1 : CMD 0 unexpected response 
f7da			; 	- A = 2 : CMD 8 unesxpectd response 
f7da			; 	- A = 3 : ACMD 41 timed out, card not ready 
f7da			;	- A = 4 : CMD 58 invalid response ,card not ready 
f7da			;	- A = 5 : CMD 58 unsupported card format (not SD, XC) 
f7da			;	- A = 6 : No card in SD slot 
f7da			; 
f7da			; Clobbers everything 
f7da			;############################################################################ 
f7da			sd_initialize: 
f7da			 
f7da				; **** Check if there is a card in the slot ******************************	 
f7da db 00			in      a,(gpio_in_0)            	; read input port       
f7dc e6 40		    and     gpio_in_0_sd_det			; check if sd_det line is low (card installed) 
f7de 28 03		    jr      z,.sd_access_wakeup			; go to next command 
f7e0 3e 06			ld		a, 6						; return error 6 
f7e2 c9				ret 
f7e3			 
f7e3				; **** Wakeup the card by sending 80 clocks ******************************	 
f7e3			.sd_access_wakeup: 
f7e3 cd 64 f7			call	.sd_wakeup					; send 80 clocks 
f7e6			 
f7e6			.sd_access_cmd_0: 
f7e6				; **** SEND CMD 0  - (GO_IDLE) *******************************************	 
f7e6				; Read one byte, the expected result is 0x01	 
f7e6 06 01			ld		b,1							; 1 byte response expected 
f7e8 1e 01			ld 		e,1							; control ssel 
f7ea dd 21 46 f7		ld 		ix,.sd_cmd0					; send CMD 0 
f7ee cd 98 f7			call 	.sd_command					; send 
f7f1 3a 93 f9			ld		a,(.sd_scratch)				; check received byte 
f7f4 fe 01			cp		0x01						; must be 0x01 
f7f6 28 03			jr	    z,.sd_access_cmd_8			; jump to next command 
f7f8 3e 01			ld		a, 1						; return error 1 
f7fa c9				ret									 
f7fb			 
f7fb				; **** SEND CMD 8 (SEND_IF_COND) *****************************************	 
f7fb				; The response should be: 0x01 0x00 0x00 0x01 0xAA. 
f7fb				; for simplicity we just check the first byte for now 
f7fb			.sd_access_cmd_8: 
f7fb 06 05			ld		b,5							; 5 byte response expected 
f7fd dd 21 4c f7		ld 		ix,.sd_cmd8					; send CMD 8 
f801 cd 98 f7			call 	.sd_command					; send 
f804 3a 93 f9			ld		a,(.sd_scratch)				; check received byte 
f807 fe 01			cp		0x01						; must be 0x01 
f809 28 03			jr	    z,.sd_access_acmd_41		; jump to next command 
f80b 3e 02			ld		a, 2						; return error 2 
f80d c9				ret	 
f80e			 
f80e				; **** SEND ACMD41 (SD_SEND_OP_COND) **************************************	 
f80e				; this must be sent after a CMD 55 (APP_CMD), and can take up to one second 
f80e				; The response od CMD 55 should be 0x01, ACMD41 should return 0x00 (ready!) 
f80e				; if a try does is not successful, waste a bit of time. increase the wait time  
f80e				; with every try, getting the card ready can take up to one second 
f80e			.sd_access_acmd_41: 
f80e 16 ff			ld		d, 0xFF						; maximum tries for ACMD55, use d as a counter 
f810 21 00 00			ld		hl,0						; inital wait time 
f813			.sd_access_acmd_41_next: 
f813 06 01			ld		b,1							; 1 byte response expected for CMD 55 
f815 dd 21 52 f7		ld 		ix,.sd_cmd55				; send CMD 55 
f819 cd 98 f7			call 	.sd_command					; send 
f81c 3a 93 f9			ld		a,(.sd_scratch)				; check received byte 
f81f fe 01			cp		0x01						; must be 0x01 
f821 20 0e			jr		nz,.sd_access_acmd_41_delay	; response was not 0x01, delay before next try 
f823 dd 21 58 f7		ld 		ix,.sd_acmd41  				; response was 0x01, continue with ACMD41 
f827 cd 98 f7			call 	.sd_command					; send 
f82a 3a 93 f9			ld		a,(.sd_scratch)				; check received byte 
f82d fe 00			cp		0x00						; must be 0x00 
f82f 28 13			jr	    z,.sd_access_cmd_58			; jump to next command if it is 
f831			.sd_access_acmd_41_delay:			 
f831 15				dec		d							; decrement try counter				 
f832 28 0d			jr		z,.sd_access_acmd_41_error  ; if zero, return error 
f834 01 00 01			ld		bc, 0x100					; increment the wait time 
f837 09				add		hl, bc						 
f838 e5				push 	hl	 
f839			.sd_access_acmd_41_delay_loop: 
f839 2b				dec		hl							; decrement until hl is 0 
f83a 7c				ld		a,h 
f83b b5				or		l 
f83c 20 fb			jr		nz,.sd_access_acmd_41_delay_loop 
f83e e1				pop		hl							; restore hl for next loop 
f83f 18 d2			jr		.sd_access_acmd_41_next		; start next try 
f841			.sd_access_acmd_41_error: 
f841 3e 03			ld		a, 3						; timeout, return error 3 
f843 c9				ret 
f844			 
f844				; **** SEND CMD 58 (READ_OCR) ********************************************	 
f844				; Check if its SDHC or SDXC card  
f844				; Only these cards are supported, they have 512 bytes blockside by default		 
f844				; The first response byte expects a 0x00 (card ready) 
f844				; The second response byte expects bit 6 set high 
f844			.sd_access_cmd_58: 
f844 06 05			ld		b,5							; 5 byte response expected 
f846 dd 21 5e f7		ld 		ix,.sd_cmd58				; send CMD 8 
f84a cd 98 f7			call 	.sd_command					; send 
f84d dd 21 93 f9		ld		ix,.sd_scratch				; access response buffer with an index register  
f851 dd 7e 00			ld		a,(ix+0)					; check the first recevived byte 
f854 fe 00			cp		0x00						; check if byte 0 is 0 
f856 28 03			jr		z,.sd_access_cmd_58_2		; if so, check send byte received 
f858 3e 04			ld		a, 4						; else, return error 4 
f85a c9				ret 
f85b			.sd_access_cmd_58_2: 
f85b dd 21 93 f9		ld		ix,.sd_scratch				; access the reponse buffer with an index register 
f85f dd 7e 01			ld		a,(ix+1)					; check the second recevived byte 
f862 cb 77			bit		6,a							; check bit 6 
f864 20 03			jr		nz,.sd_access_complete		; if it is not zero, everything is ok 
f866 3e 05			ld 		a, 5						; else, return error 5 
f868 c9				ret 
f869			.sd_access_complete: 
f869 3e 00			ld 		a, 0						; all complete with no error 
f86b c9				ret 
f86c			 
f86c			 
f86c			;############################################################################ 
f86c			; Read one block of SD data into RAM 
f86c			; 
f86c			; Read one block given by the 32-bit (little endian) number at  
f86c			; the top of the stack into the buffer given by address in DE. 
f86c			; 
f86c			; - clear SSEL line 
f86c			; - send command 17 
f86c			; - read for CMD ACK 
f86c			; - wait for 'data token' 
f86c			; - read data block 
f86c			; - read data CRC 
f86c			; - set SSEL line 
f86c			; 
f86c			; Returns the result of the operation in A: 
f86c			; 	- A = 0 : Block sucessfully read 
f86c			; 	- A = 1 : Card not ready 
f86c			; 	- A = 2 : Timout happened when waiting for data token 
f86c			;	- A = 3	: Invalid data token received 
f86c			; 
f86c			; Clobbers AF, IX 
f86c			;############################################################################ 
f86c			sd_readBlock: 
f86c				; Stack orgqanization at this point:  sp +13 = block number 31-24 
f86c													; sp +12 = block number 23-16 
f86c													; sp +11 = block number 15-08 
f86c													; sp +10 = block number 07-00 
f86c													; sp +9 = return @ High 
f86c													; sp +8 = return @ Low 
f86c c5				push	bc							; sp +6/7 = bc 
f86d e5				push	hl							; sp +4/5 = hl 
f86e fd e5			push	iy							; sp +2/3 = iy 
f870 d5				push 	de							; sp +0/1 = de 
f871			 
f871				; **** Generate CMD17 command buffer************************************** 
f871 dd 21 93 f9		ld		ix,.sd_scratch				; ix = buffer to sd command buffer 
f875 fd 21 00 00		ld		iy,0	 
f879 fd 39			add		iy,sp						; iy = address if current stackpointer 
f87b			 
f87b dd 36 00 51		ld		(ix+0),17|0x40				; CMD 17 command byte 
f87f fd 7e 0d			ld		a,(iy+13)					; CMD 17 block number 31-24 
f882 dd 77 01			ld		(ix+1),a					 
f885 fd 7e 0c			ld		a,(iy+12)					; CMD 17 block number 23-16		 
f888 dd 77 02			ld		(ix+2),a 
f88b fd 7e 0b			ld		a,(iy+11)					; CMD 17 block number 15-08 
f88e dd 77 03			ld		(ix+3),a 
f891 fd 7e 0a			ld		a,(iy+10)					; CMD 17 block number 07-00 
f894 dd 77 04			ld		(ix+4),a 
f897 dd 36 05 01		ld		(ix+5),0x00|0x01			; the CRC byte 
f89b			 
f89b				; **** Send command to the card ****************************************** 
f89b cd 6e f7			call	.sd_ssel_low				; SSEL line low 
f89e 06 01			ld		b,1							; CMD 17 expects 1 byte reponse 
f8a0 1e 00			ld		e,0							; SSEL line controlled manually		 
f8a2 cd 98 f7			call	.sd_command					; send command to card 
f8a5 3a 93 f9			ld		a,(.sd_scratch)				; check if card returned 0x00 -> ok 
f8a8 b7				or		a 
f8a9 28 04			jr		z,.sd_read_wait_token		; if zero, start waiting for the token 
f8ab 06 01			ld		b,1							; else, return error 1 
f8ad 18 37			jr		.sd_read_exit		 
f8af			 
f8af				; **** Wait for Data token *********************************************** 
f8af			.sd_read_wait_token: 
f8af 01 00 10			ld		bc, 0x1000					; data token loop max tries 
f8b2			.sd_read_wait_token_loop: 
f8b2 cd 26 fa			call	spi_read8					; read one byte from the card 
f8b5 fe ff			cp		0xFF						; compare with 0xFF 
f8b7 20 09			jr		nz,.sd_check_token 			; if not 0xFF, check the token 
f8b9 0b				dec		bc							; decrement counter 
f8ba 78				ld		a,b 
f8bb b1				or		c 
f8bc 20 f4			jr		nz,.sd_read_wait_token_loop ; if not zero, next try 
f8be 06 02			ld		b,2							; if zero, timeout happened, return error 2 
f8c0 18 24			jr		.sd_read_exit 
f8c2			 
f8c2				; **** Check if received to ken is valid ********************************* 
f8c2			.sd_check_token: 
f8c2 fe fe			cp		0xFE						; 0xFE is the expected token when card is ready to send 
f8c4 28 04			jr		z,.sd_read_data 			; if 0xFE, start reading data 
f8c6 06 03			ld		b,3							; if not, return error 3 
f8c8 18 1c			jr		.sd_read_exit	 
f8ca			 
f8ca				; **** Read the data ***************************************************** 
f8ca			.sd_read_data: 
f8ca dd e1			pop 	ix							; restore de from stack and store it in ix 
f8cc dd e5			push	ix							; push it to the stack again, it will be removed when functions exits 
f8ce 01 00 02			ld		bc,512						; use bc as a counter, we read 512 bytes from the card 
f8d1			.sd_read_data_loop:	 
f8d1 cd 26 fa			call	spi_read8					; read one byte from the card 
f8d4 dd 77 00			ld		(ix+0),a					; store it 
f8d7 dd 23			inc 	ix							; increment destination pointer 
f8d9 0b				dec		bc							; decrement counter 
f8da 78				ld		a,b	 
f8db b1				or		c 
f8dc 20 f3			jr		nz,.sd_read_data_loop		; if counter is not zero, read next byte 
f8de			 
f8de				; **** Read CRC ********************************************************** 
f8de cd 26 fa			call	spi_read8					; read first byte and ignore it 
f8e1 cd 26 fa			call	spi_read8					; read second byte and ignore it 
f8e4 06 00			ld		b,0							; we are done, return 0 
f8e6			 
f8e6			.sd_read_exit: 
f8e6 cd 83 f7			call	.sd_ssel_high				; set ssel line again 
f8e9 d1				pop 	de							; cleanup stack 
f8ea fd e1			pop 	iy							; cleanup stack 
f8ec e1				pop 	hl							; cleanup stack 
f8ed 78				ld		a,b							; copy return code 
f8ee c1				pop 	bc							; cleanup stack 
f8ef c9				ret	 
f8f0			 
f8f0			;############################################################################ 
f8f0			; Write one block of data in RAM to the SD card 
f8f0			; 
f8f0			; Write one block of data pointed by DE to the SD card block given by the  
f8f0			; 32-bit (little endian) number at the top of the stack  
f8f0			; 
f8f0			; - clear SSEL line 
f8f0			; - send command 24 
f8f0			; - read for CMD ACK 
f8f0			; -	send data 'data token' 
f8f0			; - write data block 
f8f0			; - wait for data response toke 
f8f0			; - check data response token 
f8f0			; - set SSEL line 
f8f0			; - clear SSEL line 
f8f0			; - wait while card is busy 
f8f0			; - set SSEL line 
f8f0			; 
f8f0			; Returns the result of the operation in A: 
f8f0			; 	- A = 0 : Block sucessfully written 
f8f0			; 	- A = 1 : Card not ready 
f8f0			; 	- A = 2 : Timout happened while waiting for data response token 
f8f0			;	- A = 3	: Invalid data token received 
f8f0			;	- A = 4	: Timout happened while card is busy 
f8f0			; 
f8f0			; Clobbers AF, IX 
f8f0			;############################################################################ 
f8f0			sd_writeBlock: 
f8f0				; Stack orgqanization at this point:  sp +13 = block number 31-24 
f8f0													; sp +12 = block number 23-16 
f8f0													; sp +11 = block number 15-08 
f8f0													; sp +10 = block number 07-00 
f8f0													; sp +9 = return @ High 
f8f0													; sp +8 = return @ Low 
f8f0 c5				push	bc							; sp +6/7 = bc 
f8f1 e5				push	hl							; sp +4/5 = hl 
f8f2 fd e5			push	iy							; sp +2/3 = iy 
f8f4 d5				push 	de							; sp +0/1 = de 
f8f5			 
f8f5				; **** Generate CMD24 command buffer************************************** 
f8f5 dd 21 93 f9		ld		ix,.sd_scratch				; ix = buffer to sd command buffer 
f8f9 fd 21 00 00		ld		iy,0	 
f8fd fd 39			add		iy,sp						; iy = address if current stackpointer 
f8ff			 
f8ff dd 36 00 58		ld		(ix+0),24|0x40				; CMD 24 command byte 
f903 fd 7e 0d			ld		a,(iy+13)					; CMD 24 block number 31-24 
f906 dd 77 01			ld		(ix+1),a					 
f909 fd 7e 0c			ld		a,(iy+12)					; CMD 24 block number 23-16	 
f90c dd 77 02			ld		(ix+2),a 
f90f fd 7e 0b			ld		a,(iy+11)					; CMD 24 block number 15-08 
f912 dd 77 03			ld		(ix+3),a 
f915 fd 7e 0a			ld		a,(iy+10)					; CMD 24 block number 07-00 
f918 dd 77 04			ld		(ix+4),a 
f91b dd 36 05 01		ld		(ix+5),0x00|0x01			; the CRC byte 
f91f			 
f91f				; **** Send command to the card ****************************************** 
f91f cd 6e f7			call	.sd_ssel_low				; SSEL line low 
f922 06 01			ld		b,1							; CMD 24 expects 1 byte reponse 
f924 1e 00			ld		e,0							; SSEL line controlled manually		 
f926 cd 98 f7			call	.sd_command					; send command to card 
f929 3a 93 f9			ld		a,(.sd_scratch)				; check if card returned 0x00 -> ok 
f92c b7				or		a 
f92d 28 04			jr		z,.sd_write_send_token		; if response = 0, then ok 
f92f 06 01			ld		b,1							; else, return error 1 
f931 18 56			jr		.sd_write_exit	 
f933			 
f933				; **** Send data token *************************************************** 
f933			.sd_write_send_token: 
f933 0e ff			ld		c, 0xff						; set c=0xff, send FF 
f935 cd 99 f9			call	spi_write8					 
f938 0e fe			ld		c, 0xfe						; set c=0xfe, send FE 
f93a cd 99 f9			call	spi_write8					 
f93d			 
f93d				; **** Send the data ***************************************************** 
f93d			.sd_send_data: 
f93d dd e1			pop 	ix							; restore de from stack and store it in ix 
f93f dd e5			push	ix							; push it to the stack again, it will be removed when functions exits 
f941 11 00 02			ld		de,512						; use de as a counter, we read 512 bytes from the card 
f944			.sd_send_data_loop:	 
f944 dd 4e 00			ld		c,(ix+0)					; load next byte to c 
f947 cd 99 f9			call	spi_write8					; send it 
f94a dd 23			inc 	ix							; increment source pointer 
f94c 1b				dec		de							; decrement counter 
f94d 7a				ld		a,d	 
f94e b3				or		e 
f94f 20 f3			jr		nz,.sd_send_data_loop		; if counter is not zero, send next byte 
f951			 
f951				; **** Wait for data response token, up to 250ms ************************* 
f951 11 00 f0			ld		de, 0xF000					; use de as a counter 
f954			.sd_send_wait_token: 
f954 cd 26 fa			call	spi_read8					; read one byte 
f957 fe ff			cp		0xff						; compare with 0xff 
f959 20 09			jr		nz,.sd_send_check_token		; if it is not 0xff, we are ok and can continue 
f95b 1b				dec		de							; decrement counter 
f95c 7a				ld		a,d 
f95d b3				or		e 
f95e 20 f4			jr		nz,.sd_send_wait_token		; if counter is not zero, try again 
f960 06 02			ld		b, 2						; timeout occured, return error 2 
f962 18 25			jr		.sd_write_exit	 
f964			 
f964				; **** check data response *********************************************** 
f964			.sd_send_check_token:					; Make sure the response is 0bxxx00101 else is an error 
f964 e6 1f			and		0x1f 
f966 fe 05			cp		0x05 
f968 28 04			jr		z,.sd_send_wait_busy		; if response is ok, continue 
f96a 06 03			ld		b, 3						; else, return error 3 
f96c 18 1b			jr		.sd_write_exit	 
f96e			 
f96e			; **** check data response *********************************************** 
f96e			.sd_send_wait_busy: 
f96e cd 83 f7			call	.sd_ssel_high				; set ssel line 
f971 cd 6e f7			call	.sd_ssel_low				; clear ssel line again 
f974 11 00 00			ld		de, 0						; use de as a counter 
f977			.sd_send_wait_busy_loop: 
f977 cd 26 fa			call	spi_read8					; read one byte 
f97a fe ff			cp		0xff						; compare it with 0xff 
f97c 28 09			jr		z, .sd_write_ok				; if it is 0xff, we are done ok 
f97e 1b			 	dec		de							; decrement counter 
f97f 7a				ld		a,d 
f980 b3				or		e 
f981 20 f4			jr		nz,.sd_send_wait_busy_loop	; if counter is not zero, try again 
f983 06 04			ld		b, 4						; timeout occured, return error 4 
f985 18 02			jr		.sd_write_exit	 
f987			 
f987			; **** complete ********************************************************** 
f987			.sd_write_ok: 
f987 06 00			ld		b, 0						; return success flag 
f989			.sd_write_exit: 
f989 cd 83 f7			call	.sd_ssel_high				; set ssel line 
f98c d1				pop 	de							; cleanup stack 
f98d fd e1			pop 	iy							; cleanup stack 
f98f e1				pop 	hl							; cleanup stack 
f990 78				ld		a,b							; copy return code 
f991 c1				pop 	bc							; cleanup stack 
f992 c9				ret	 
f993			 
f993			;############################################################################ 
f993			; A buffer for exchanging messages with the SD card. 
f993			;############################################################################ 
f993 00...		.sd_scratch: 	ds		6
# End of file sdcard.asm
f999			include 'spi.asm' 
f999			;**************************************************************************** 
f999			; 
f999			;   TeachZ80 SPI Driver 
f999			; 
f999			;   Based on the original code from John Winans, published under GNU LGPL: 
f999			;   https://github.com/Z80-Retro/2063-Z80-cpm/blob/main/lib/spi.asm 
f999			; 
f999			;	An SPI library suitable for tallking to SD cards.	 
f999			; 
f999			;   Author: 
f999			;   Christian Luethi 
f999			; 
f999			;**************************************************************************** 
f999			 
f999			;############################################################################ 
f999			; 
f999			; This library implements SPI mode 0 (SD cards operate on SPI mode 0.) 
f999			; Data changes on falling CLK edge & sampled on rising CLK edge: 
f999			;        __                                             ___ 
f999			; /SSEL    \______________________ ... ________________/      Host --> Device 
f999			;                 __    __    __   ... _    __    __ 
f999			; CLK    ________/  \__/  \__/  \__     \__/  \__/  \______   Host --> Device 
f999			;        _____ _____ _____ _____ _     _ _____ _____ ______ 
f999			; MOSI        \_____X_____X_____X_ ... _X_____X_____/         Host --> Device 
f999			;        _____ _____ _____ _____ _     _ _____ _____ ______ 
f999			; MISO        \_____X_____X_____X_ ... _X_____X_____/         Host <-- Device 
f999			; 
f999			;############################################################################ 
f999			 
f999			;############################################################################ 
f999			; Write 8 bits in C to the SPI port and discard the received data. 
f999			; It is assumed that the gpio_out_cache value matches the current state 
f999			; It also assumes, clock is 0 and mosi is 1 when entering 
f999			; This will leave: CLK=0, MOSI=1 
f999			; Clobbers: A 
f999			;############################################################################ 
f999			spi_write1:	macro bitpos 
f999				and		~gpio_out_sd_clk	; clear clock 
f999				and 	~gpio_out_sd_mosi	; clear mosi 
f999				bit		bitpos,c			; is the bit of C a 1? 
f999				jr		z,.write1_low			 
f999				or		gpio_out_sd_mosi	; set mosi again 
f999			.write1_low: ds 0				; for some reason, these labels disappear if there is no neumonic 
f999				out		(gpio_out),a		; clock falling edge + set data 
f999				or		gpio_out_sd_clk		; clock rising edge 
f999				out		(gpio_out),a		 
f999				endm 
f999			 
f999			spi_write8: 
f999 3a c0 fa			ld		a,(gpio_out_cache)	; get current gpio_out value 
f99c				spi_write1	7				; send bit 7 
f99c e6 fd			and		~gpio_out_sd_clk	; clear clock 
f99e e6 fe			and 	~gpio_out_sd_mosi	; clear mosi 
f9a0 cb 79			bit		7,c			; is the bit of C a 1? 
f9a2 28 02			jr		z,.write1_low			 
f9a4 f6 01			or		gpio_out_sd_mosi	; set mosi again 
f9a6 00...		.write1_low: ds 0				; for some reason, these labels disappear if there is no neumonic 
f9a6 d3 10			out		(gpio_out),a		; clock falling edge + set data 
f9a8 f6 02			or		gpio_out_sd_clk		; clock rising edge 
f9aa d3 10			out		(gpio_out),a		 
f9ac				endm 
# End of macro spi_write1
f9ac				spi_write1	6				; send bit 6 
f9ac e6 fd			and		~gpio_out_sd_clk	; clear clock 
f9ae e6 fe			and 	~gpio_out_sd_mosi	; clear mosi 
f9b0 cb 71			bit		6,c			; is the bit of C a 1? 
f9b2 28 02			jr		z,.write1_low			 
f9b4 f6 01			or		gpio_out_sd_mosi	; set mosi again 
f9b6 00...		.write1_low: ds 0				; for some reason, these labels disappear if there is no neumonic 
f9b6 d3 10			out		(gpio_out),a		; clock falling edge + set data 
f9b8 f6 02			or		gpio_out_sd_clk		; clock rising edge 
f9ba d3 10			out		(gpio_out),a		 
f9bc				endm 
# End of macro spi_write1
f9bc				spi_write1	5				; send bit 5 
f9bc e6 fd			and		~gpio_out_sd_clk	; clear clock 
f9be e6 fe			and 	~gpio_out_sd_mosi	; clear mosi 
f9c0 cb 69			bit		5,c			; is the bit of C a 1? 
f9c2 28 02			jr		z,.write1_low			 
f9c4 f6 01			or		gpio_out_sd_mosi	; set mosi again 
f9c6 00...		.write1_low: ds 0				; for some reason, these labels disappear if there is no neumonic 
f9c6 d3 10			out		(gpio_out),a		; clock falling edge + set data 
f9c8 f6 02			or		gpio_out_sd_clk		; clock rising edge 
f9ca d3 10			out		(gpio_out),a		 
f9cc				endm 
# End of macro spi_write1
f9cc				spi_write1	4				; send bit 4 
f9cc e6 fd			and		~gpio_out_sd_clk	; clear clock 
f9ce e6 fe			and 	~gpio_out_sd_mosi	; clear mosi 
f9d0 cb 61			bit		4,c			; is the bit of C a 1? 
f9d2 28 02			jr		z,.write1_low			 
f9d4 f6 01			or		gpio_out_sd_mosi	; set mosi again 
f9d6 00...		.write1_low: ds 0				; for some reason, these labels disappear if there is no neumonic 
f9d6 d3 10			out		(gpio_out),a		; clock falling edge + set data 
f9d8 f6 02			or		gpio_out_sd_clk		; clock rising edge 
f9da d3 10			out		(gpio_out),a		 
f9dc				endm 
# End of macro spi_write1
f9dc				spi_write1	3				; send bit 3 
f9dc e6 fd			and		~gpio_out_sd_clk	; clear clock 
f9de e6 fe			and 	~gpio_out_sd_mosi	; clear mosi 
f9e0 cb 59			bit		3,c			; is the bit of C a 1? 
f9e2 28 02			jr		z,.write1_low			 
f9e4 f6 01			or		gpio_out_sd_mosi	; set mosi again 
f9e6 00...		.write1_low: ds 0				; for some reason, these labels disappear if there is no neumonic 
f9e6 d3 10			out		(gpio_out),a		; clock falling edge + set data 
f9e8 f6 02			or		gpio_out_sd_clk		; clock rising edge 
f9ea d3 10			out		(gpio_out),a		 
f9ec				endm 
# End of macro spi_write1
f9ec				spi_write1	2				; send bit 2 
f9ec e6 fd			and		~gpio_out_sd_clk	; clear clock 
f9ee e6 fe			and 	~gpio_out_sd_mosi	; clear mosi 
f9f0 cb 51			bit		2,c			; is the bit of C a 1? 
f9f2 28 02			jr		z,.write1_low			 
f9f4 f6 01			or		gpio_out_sd_mosi	; set mosi again 
f9f6 00...		.write1_low: ds 0				; for some reason, these labels disappear if there is no neumonic 
f9f6 d3 10			out		(gpio_out),a		; clock falling edge + set data 
f9f8 f6 02			or		gpio_out_sd_clk		; clock rising edge 
f9fa d3 10			out		(gpio_out),a		 
f9fc				endm 
# End of macro spi_write1
f9fc				spi_write1	1				; send bit 1 
f9fc e6 fd			and		~gpio_out_sd_clk	; clear clock 
f9fe e6 fe			and 	~gpio_out_sd_mosi	; clear mosi 
fa00 cb 49			bit		1,c			; is the bit of C a 1? 
fa02 28 02			jr		z,.write1_low			 
fa04 f6 01			or		gpio_out_sd_mosi	; set mosi again 
fa06 00...		.write1_low: ds 0				; for some reason, these labels disappear if there is no neumonic 
fa06 d3 10			out		(gpio_out),a		; clock falling edge + set data 
fa08 f6 02			or		gpio_out_sd_clk		; clock rising edge 
fa0a d3 10			out		(gpio_out),a		 
fa0c				endm 
# End of macro spi_write1
fa0c				spi_write1	0				; send bit 0 
fa0c e6 fd			and		~gpio_out_sd_clk	; clear clock 
fa0e e6 fe			and 	~gpio_out_sd_mosi	; clear mosi 
fa10 cb 41			bit		0,c			; is the bit of C a 1? 
fa12 28 02			jr		z,.write1_low			 
fa14 f6 01			or		gpio_out_sd_mosi	; set mosi again 
fa16 00...		.write1_low: ds 0				; for some reason, these labels disappear if there is no neumonic 
fa16 d3 10			out		(gpio_out),a		; clock falling edge + set data 
fa18 f6 02			or		gpio_out_sd_clk		; clock rising edge 
fa1a d3 10			out		(gpio_out),a		 
fa1c				endm 
# End of macro spi_write1
fa1c e6 fd			and		~gpio_out_sd_clk	; clear clock 
fa1e f6 01			or		gpio_out_sd_mosi	; set mosi 
fa20 d3 10			out		(gpio_out),a 
fa22 32 c0 fa			ld 		(gpio_out_cache), a ; final state to output cache 
fa25 c9				ret 
fa26			 
fa26			;############################################################################ 
fa26			; Read 8 bits from the SPI & return it in A. 
fa26			; This will leave: CLK=0, MOSI=Unchanged (should be one) 
fa26			; Clobbers A, E 
fa26			;############################################################################ 
fa26			spi_read1:	macro 
fa26				or		gpio_out_sd_clk		; set clock 
fa26				out		(gpio_out),a		; clock rising edge 
fa26				push 	af					; push a, as we change it after 
fa26				in		a,(gpio_in)			; read MISO 
fa26				and 	gpio_in_sd_miso		;  
fa26				or		e					; accumulate the current MISO value 
fa26				ld		e,a					; NOTE: note this only works because gpio_in_sd_miso = 0x80 
fa26				rlc		e					; rotate the data buffer 
fa26				pop		af					; load the output chache again 
fa26				and		~gpio_out_sd_clk	; clear the clock bit 
fa26				out		(gpio_out),a		; clock falling edge edge 
fa26				endm 
fa26			 
fa26			spi_read8: 
fa26 1e 00			ld		e,0					; prepare to accumulate the bits into E 
fa28 3a c0 fa			ld		a,(gpio_out_cache)	; get current gpio_out value 
fa2b				spi_read1					; read bit 7 
fa2b f6 02			or		gpio_out_sd_clk		; set clock 
fa2d d3 10			out		(gpio_out),a		; clock rising edge 
fa2f f5				push 	af					; push a, as we change it after 
fa30 db 00			in		a,(gpio_in)			; read MISO 
fa32 e6 80			and 	gpio_in_sd_miso		;  
fa34 b3				or		e					; accumulate the current MISO value 
fa35 5f				ld		e,a					; NOTE: note this only works because gpio_in_sd_miso = 0x80 
fa36 cb 03			rlc		e					; rotate the data buffer 
fa38 f1				pop		af					; load the output chache again 
fa39 e6 fd			and		~gpio_out_sd_clk	; clear the clock bit 
fa3b d3 10			out		(gpio_out),a		; clock falling edge edge 
fa3d				endm 
# End of macro spi_read1
fa3d				spi_read1					; read bit 6 
fa3d f6 02			or		gpio_out_sd_clk		; set clock 
fa3f d3 10			out		(gpio_out),a		; clock rising edge 
fa41 f5				push 	af					; push a, as we change it after 
fa42 db 00			in		a,(gpio_in)			; read MISO 
fa44 e6 80			and 	gpio_in_sd_miso		;  
fa46 b3				or		e					; accumulate the current MISO value 
fa47 5f				ld		e,a					; NOTE: note this only works because gpio_in_sd_miso = 0x80 
fa48 cb 03			rlc		e					; rotate the data buffer 
fa4a f1				pop		af					; load the output chache again 
fa4b e6 fd			and		~gpio_out_sd_clk	; clear the clock bit 
fa4d d3 10			out		(gpio_out),a		; clock falling edge edge 
fa4f				endm 
# End of macro spi_read1
fa4f				spi_read1					; read bit 5 
fa4f f6 02			or		gpio_out_sd_clk		; set clock 
fa51 d3 10			out		(gpio_out),a		; clock rising edge 
fa53 f5				push 	af					; push a, as we change it after 
fa54 db 00			in		a,(gpio_in)			; read MISO 
fa56 e6 80			and 	gpio_in_sd_miso		;  
fa58 b3				or		e					; accumulate the current MISO value 
fa59 5f				ld		e,a					; NOTE: note this only works because gpio_in_sd_miso = 0x80 
fa5a cb 03			rlc		e					; rotate the data buffer 
fa5c f1				pop		af					; load the output chache again 
fa5d e6 fd			and		~gpio_out_sd_clk	; clear the clock bit 
fa5f d3 10			out		(gpio_out),a		; clock falling edge edge 
fa61				endm 
# End of macro spi_read1
fa61				spi_read1					; read bit 4 
fa61 f6 02			or		gpio_out_sd_clk		; set clock 
fa63 d3 10			out		(gpio_out),a		; clock rising edge 
fa65 f5				push 	af					; push a, as we change it after 
fa66 db 00			in		a,(gpio_in)			; read MISO 
fa68 e6 80			and 	gpio_in_sd_miso		;  
fa6a b3				or		e					; accumulate the current MISO value 
fa6b 5f				ld		e,a					; NOTE: note this only works because gpio_in_sd_miso = 0x80 
fa6c cb 03			rlc		e					; rotate the data buffer 
fa6e f1				pop		af					; load the output chache again 
fa6f e6 fd			and		~gpio_out_sd_clk	; clear the clock bit 
fa71 d3 10			out		(gpio_out),a		; clock falling edge edge 
fa73				endm 
# End of macro spi_read1
fa73				spi_read1					; read bit 3 
fa73 f6 02			or		gpio_out_sd_clk		; set clock 
fa75 d3 10			out		(gpio_out),a		; clock rising edge 
fa77 f5				push 	af					; push a, as we change it after 
fa78 db 00			in		a,(gpio_in)			; read MISO 
fa7a e6 80			and 	gpio_in_sd_miso		;  
fa7c b3				or		e					; accumulate the current MISO value 
fa7d 5f				ld		e,a					; NOTE: note this only works because gpio_in_sd_miso = 0x80 
fa7e cb 03			rlc		e					; rotate the data buffer 
fa80 f1				pop		af					; load the output chache again 
fa81 e6 fd			and		~gpio_out_sd_clk	; clear the clock bit 
fa83 d3 10			out		(gpio_out),a		; clock falling edge edge 
fa85				endm 
# End of macro spi_read1
fa85				spi_read1					; read bit 2 
fa85 f6 02			or		gpio_out_sd_clk		; set clock 
fa87 d3 10			out		(gpio_out),a		; clock rising edge 
fa89 f5				push 	af					; push a, as we change it after 
fa8a db 00			in		a,(gpio_in)			; read MISO 
fa8c e6 80			and 	gpio_in_sd_miso		;  
fa8e b3				or		e					; accumulate the current MISO value 
fa8f 5f				ld		e,a					; NOTE: note this only works because gpio_in_sd_miso = 0x80 
fa90 cb 03			rlc		e					; rotate the data buffer 
fa92 f1				pop		af					; load the output chache again 
fa93 e6 fd			and		~gpio_out_sd_clk	; clear the clock bit 
fa95 d3 10			out		(gpio_out),a		; clock falling edge edge 
fa97				endm 
# End of macro spi_read1
fa97				spi_read1					; read bit 1 
fa97 f6 02			or		gpio_out_sd_clk		; set clock 
fa99 d3 10			out		(gpio_out),a		; clock rising edge 
fa9b f5				push 	af					; push a, as we change it after 
fa9c db 00			in		a,(gpio_in)			; read MISO 
fa9e e6 80			and 	gpio_in_sd_miso		;  
faa0 b3				or		e					; accumulate the current MISO value 
faa1 5f				ld		e,a					; NOTE: note this only works because gpio_in_sd_miso = 0x80 
faa2 cb 03			rlc		e					; rotate the data buffer 
faa4 f1				pop		af					; load the output chache again 
faa5 e6 fd			and		~gpio_out_sd_clk	; clear the clock bit 
faa7 d3 10			out		(gpio_out),a		; clock falling edge edge 
faa9				endm 
# End of macro spi_read1
faa9				spi_read1					; read bit 0 
faa9 f6 02			or		gpio_out_sd_clk		; set clock 
faab d3 10			out		(gpio_out),a		; clock rising edge 
faad f5				push 	af					; push a, as we change it after 
faae db 00			in		a,(gpio_in)			; read MISO 
fab0 e6 80			and 	gpio_in_sd_miso		;  
fab2 b3				or		e					; accumulate the current MISO value 
fab3 5f				ld		e,a					; NOTE: note this only works because gpio_in_sd_miso = 0x80 
fab4 cb 03			rlc		e					; rotate the data buffer 
fab6 f1				pop		af					; load the output chache again 
fab7 e6 fd			and		~gpio_out_sd_clk	; clear the clock bit 
fab9 d3 10			out		(gpio_out),a		; clock falling edge edge 
fabb				endm 
# End of macro spi_read1
fabb 32 c0 fa			ld 		(gpio_out_cache), a ; final state to output cache 
fabe 7b				ld a,e						; final value in a 
fabf c9				ret
# End of file spi.asm
fac0			 
fac0			;########################################################################## 
fac0			; General save areas 
fac0			;########################################################################## 
fac0			 
fac0 00...		gpio_out_cache: 	ds  1		; GPIO output latch cache 
fac1 00...		disk_dirbuf:		ds	128		; scratch directory buffer 
fb41			.bios_wboot_stack:				; (ab)use the BDOS directory buffer as a stack during WBOOT 
fb41			 
fb41			 
fb41			;########################################################################## 
fb41			; Temporary stack used for BIOS calls needing more than a few stack levels. 
fb41			; 
fb41			; WARNING: This is expected to be in memory that is NOT bank-switchable! 
fb41			;########################################################################## 
fb41 0x55...		.bios_stack_lo:		ds	64,0x55	; 32 stack levels = 64 bytes (init to analyze) 
fb81			bios_stack:						; full descending stack starts /after/ the storage area  
fb81			 
fb81			;########################################################################## 
fb81			if $ < BOOT 
fb81				ERROR THE BIOS WRAPPED AROUND PAST 0xffff 
fb81			endif 
fb81				end 
# End of file bios/bios.asm
fb81
