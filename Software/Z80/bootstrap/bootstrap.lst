# File bootstrap.asm
0000			;**************************************************************************** 
0000			; 
0000			;   TeachZ80 Bootstrap 
0000			; 
0000			;   Based on the original code from John Winans, published under GNU LGPL: 
0000			;   https://github.com/Z80-Retro/2063-Z80-cpm/blob/main/boot/firmware.asm 
0000			; 
0000			;   Author: 
0000			;   Christian Luethi 
0000			; 
0000			;   This software is located in the TeachZ80 flash, and is executing the following tasks: 
0000			;   - Copy of this code from Flash to RAM address 0000 
0000			;   - Disabling the FLASH and continue executing the code from RAM 
0000			;   - Initalization of the TeachZ80 Mainboard Hardware (GP outputs, SD Card signals) 
0000			;   - Initialization of SIO A, uses /16 divider (115200 from 1.8432 MHZ clk) 
0000			;	- Read the MBR from the SD card (first block of 512 bytes) 
0000			;	- Access partition 1 on the SD card 
0000			;   - Copy 16k of the O/S from partition 1 into RAM at address LOAD_BASE (C000) 
0000			;   - Jump to the O/S 
0000			; 
0000			;   Version 1.0 - 21.12.2023 
0000			; 
0000			;**************************************************************************** 
0000			 
0000			;**************************************************************************** 
0000			; Constants 
0000			;**************************************************************************** 
0000			.boot_version_major:	equ	   1 
0000			.boot_version_minor:	equ	   0 
0000			.low_bank:              equ   14        ; Use low bank 14 
0000			.load_blks:	            equ	  32        ; SD blocksize is 512, gives 16k to load //TBD! Should be 32, but crashes 
0000			 
0000			;**************************************************************************** 
0000			; Required includes (others follow at the bottom of the code)  
0000			;**************************************************************************** 
0000			include	'../lib/memory.asm' 
0000			;**************************************************************************** 
0000			; 
0000			;    Copyright (C) 2021 John Winans 
0000			; 
0000			;    This library is free software; you can redistribute it and/or 
0000			;    modify it under the terms of the GNU Lesser General Public 
0000			;    License as published by the Free Software Foundation; either 
0000			;    version 2.1 of the License, or (at your option) any later version. 
0000			; 
0000			;    This library is distributed in the hope that it will be useful, 
0000			;    but WITHOUT ANY WARRANTY; without even the implied warranty of 
0000			;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
0000			;    Lesser General Public License for more details. 
0000			; 
0000			;    You should have received a copy of the GNU Lesser General Public 
0000			;    License along with this library; if not, write to the Free Software 
0000			;    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 
0000			;    USA 
0000			; 
0000			; https://github.com/johnwinans/2063-Z80-cpm 
0000			; 
0000			;**************************************************************************** 
0000			 
0000			; Define the memory size to be used for the CP/M configuration 
0000			MEM:    equ 60 
0000			 
0000			; The CPM origin will be at: (MEM-7)*1024 
0000			; This screwy convention is due to the way that that the CP/M origin is defined. 
0000			CPM_BASE:	equ	(MEM-7)*1024 
0000			LOAD_BASE:	equ	0xc000		; where the boot loader reads the image from the SD card
# End of file ../lib/memory.asm
0000			 
0000			;############################################################################## 
0000			; START FROM FLASH 
0000			;##############################################################################  
0000			bootstrap:  org  0x0000						; Z80 cold boot vector 
0000			 
0000 3a 46 03		  	ld      a,(gpio_out_cache)				; Select SRAM low bank 14, initialze outputs 
0003 d3 10		    out	    (gpio_out_0),a 
0005			 
0005 21 00 00			ld	    hl,0							; copy the FLASH into the SRAM 
0008 11 00 00			ld	    de,0							; writing it back into the same address 
000b 01 58 07			ld	    bc,.end 
000e ed b0			ldir	 
0010			 
0010 db 70			in	    a,(flash_disable)				; Disable  FLASH and run from SRAM 
0012			 
0012			;############################################################################## 
0012			; CONTINUE FROM RAM 
0012			;##############################################################################  
0012 31 00 c0			ld      sp, LOAD_BASE                  	; Load stackpointer at LOAD_BASE 
0015 cd 60 03			call    sioa_init                       ; Init the Console SIO 
0018 cd e8 02			call    .print_boot_message             ; Display boot message. 
001b				 
001b			;****************************************************************************** 
001b cd 46 00		    call    .boot_sd                        ; Load boot code from the SD card. 
001e			;****************************************************************************** 
001e			 
001e cd 0b 04		    call    iputs                           ; Emergency stop, something went wrong 
0021 ..				db		"\r\nSYSTEM LOAD FAILED! HALTING.\r\n\0" 
0042			 
0042			.halt_loop: 
0042 76				halt 
0043 c3 42 00			jp      .halt_loop     
0046			 
0046			;############################################################################## 
0046			; Load 16K from the first 32 blocks of partition 1 on the SD card into 
0046			; memory starting at 'LOAD_BASE' and jump to it. 
0046			; If reading the SD card should fail then this function will return. 
0046			; 
0046			; TODO: Sanity-check the partition type, size and design some sort of  
0046			; signature that can be used to recognize the SD card partition as viable. 
0046			;############################################################################## 
0046			.boot_sd: 
0046 cd 0b 04			call	iputs 
0049 ..				db		"\r\nBooting from SD card\r\nReading SD card MBR...\0" 
0078			 
0078				; ######################### Initialize SD Card ######################### 
0078 cd 4c 06			call 	sd_initialize					; initialize sd card 
007b b7				or		a								; check if a is zero > card initialized successfully 
007c ca f1 00			jp		z,.load_mbr						; read the first sector 
007f			 
007f				; SD card initialization error printing 
007f fe 06			cp		6								; error 6, no card in slot 
0081 c2 af 00			jp		nz, .sd_init_print_error		; every other error, print error code 
0084 cd 0b 04			call	iputs							 
0087 ..				db		"\r\nError: No SD card detected in slot\r\n\0" 
00ae c9				ret 
00af			 
00af			.sd_init_print_error:						; print any other error message 
00af f5				push	af 
00b0 cd 0b 04			call	iputs 
00b3 ..				db		"\r\nError: Cannot initialize SD card. Error message: 0x\0" 
00e9 f1				pop 	af 
00ea cd e9 03			call 	hexdump_a 
00ed cd 24 04			call 	puts_crlf 
00f0 c9				ret 
00f1			 
00f1			.load_mbr: 
00f1				; ########## Read the first block on the card (MBR) to LOAD_BASE ########## 
00f1 21 00 00			ld	    hl, 0			                ; SD card block number to read, 32bit 
00f4 e5				push    hl			                    ; push high word to stack 
00f5 e5				push    hl			                    ; push low word to stack 
00f6 11 00 c0			ld	    de,LOAD_BASE		            ; where to store the sector data 
00f9 cd d6 06			call    sd_readBlock					; read the block from the card 
00fc e1				pop	    hl			                    ; remove the block number from the stack again 
00fd e1				pop	    hl								; remove the block number from the stack again 
00fe b7				or	    a                               ; check if a is zero > block read successfully 
00ff ca 47 01			jp		z,.load_os				 
0102			 
0102				; MBR loeading read error 
0102 f5				push	af 
0103 cd 0b 04			call	iputs 
0106 ..				db		"\r\nError: Cannot read MBR from SD card. Error message: 0x\0" 
013f f1				pop 	af 
0140 cd e9 03			call 	hexdump_a 
0143 cd 24 04			call 	puts_crlf 
0146 c9				ret 
0147			 
0147			.load_os: 
0147 cd 0b 04			call	iputs							 
014a ..				db		" done\r\n\0" 
0152			 
0152				; ############ Load the OS from the SD card into LOAD_BASE ############## 
0152 cd 0b 04			call	iputs 
0155 ..				db		'Loading Operating System...\0' 
0171			 
0171 dd 21 c6 c1		ld	    ix,LOAD_BASE+0x01BE+0x08		; this will point to the block number of partition 1 
0175 dd 66 03			ld	    h,(ix+3)						; block number 31-24 -> H 
0178 dd 6e 02			ld	    l,(ix+2)						; block number 23-16 -> L 
017b e5				push    hl								; push high word of the block to read on the stack 
017c dd 66 01			ld	    h,(ix+1)						; block number 15-08 -> H 
017f dd 6e 00			ld	    l,(ix+0)						; block number 07-00 -> L 
0182 e5				push	hl								; push low word of the block to read on the stack 
0183			 
0183				; Stack organization at this point:  	  sp +3 = block number 31-24 
0183														; sp +2 = block number 23-16 
0183														; sp +1 = block number 15-08 
0183														; sp +0 = block number 07-00 
0183			 
0183 11 00 c0			ld	    de,LOAD_BASE					; where to read the sector data into 
0186 21 20 00			ld	    hl,.load_blks					; use hl as a counter, number of blocks to load (should be 32/16KB) 
0189			 
0189			.load_os_loop: 
0189 0e 2e			ld		c,'.' 
018b cd 7a 03			call 	con_tx_char						; print dot to show progress 
018e cd d6 06			call 	sd_readBlock					; read the next block from the card 
0191 b7				or		a								; check result 
0192 20 4a			jr		nz,.boot_error					; if result was not zero, exit with error 
0194 14				inc		d								; update the destination address 
0195 14				inc		d								; incrementing d twice, actually will increment de by 512 
0196 dd 21 00 00		ld		ix,0							; increment the 32-bit block number directly on the stack	 
019a dd 39			add		ix,sp							; ix = sp 
019c dd 34 00			inc	    (ix+0)							; increment block number 07-00 
019f 20 0d			jr	    nz,.load_os_loop_next 
01a1 dd 34 01			inc	    (ix+1)							; if required, increment block number 15-08 
01a4 20 08			jr	    nz,.load_os_loop_next 
01a6 dd 34 02			inc	    (ix+2)							; if required, increment block number 23-16 
01a9 20 03			jr	    nz,.load_os_loop_next 
01ab dd 34 03			inc	    (ix+3)							; if required, increment block number 31-24 
01ae			 
01ae			.load_os_loop_next: 
01ae 2b				dec 	hl								; decrement hl 
01af 7c				ld		a,h								; check if it is zero 
01b0 b5				or		l 
01b1 20 d6			jr		nz,.load_os_loop				; if not, read next block			 
01b3			 
01b3			    ; ##################### Run Loaded Operating System ##################### 
01b3			.boot_os: 
01b3 cd 0b 04			call	iputs 
01b6 ..				db		' done\r\nBooting Operating System\r\n\n\0' 
01d9 e1				pop		hl								; pop low word of the block to read from the stack to hl 
01da d1				pop		de								; pop high word of the block to read from the stack to de 
01db ca 00 c0			jp	    z,LOAD_BASE		    			; Run the code that we just read in from the SD card. 
01de			 
01de			.boot_error: 
01de				; ################################ ERROR ################################ 
01de f5				push 	af 
01df cd 0b 04			call	iputs 
01e2 ..				db		'\r\n\nError: Could not load O/S from card. Read Error 0x\0' 
0218 f1				pop 	af 
0219 cd e9 03			call 	hexdump_a 
021c cd 24 04			call 	puts_crlf 
021f cd 24 04			call 	puts_crlf 
0222 c9				ret 
0223			 
0223			 
0223			;**************************************************************************** 
0223			; Prints the welcome message and generates welcome blink 
0223			;**************************************************************************** 
0223			.boot_message_1: 
0223 ..				db		"\r\n\n****************************************************************************\r\n\n" 
0275 ..				db		" TeachZ80 Bootloader\r\n" 
028b ..				db		" Version: \0" 
0296			.boot_message_2: 
0296 ..			    db		'\r\n\n****************************************************************************\r\n\0' 
02e8			 
02e8			.print_boot_message: 
02e8				; print welcome message including version number 
02e8 21 23 02		    ld  	hl,.boot_message_1 
02eb cd 12 04		    call 	puts 
02ee 1e 01			ld		e, 1 
02f0 21 01 00		    ld  	hl,.boot_version_major 
02f3 cd 2b 04		    call 	puts_decimal 
02f6 0e 2e			ld		c,'.' 
02f8 cd 7a 03			call	con_tx_char 
02fb 21 00 00		    ld  	hl,.boot_version_minor 
02fe cd 2b 04		    call 	puts_decimal 
0301 21 96 02		    ld  	hl,.boot_message_2 
0304 cd 12 04		    call 	puts 
0307			 
0307 3e 01			ld		a, 1 
0309 d3 20			out		(gpio_out_1), a 
030b cd 3d 03			call	.led_delay 
030e 3e 02			ld		a, 2 
0310 d3 20			out		(gpio_out_1), a 
0312 cd 3d 03			call	.led_delay 
0315 3e 04			ld		a, 4 
0317 d3 20			out		(gpio_out_1), a 
0319 cd 3d 03			call	.led_delay 
031c 3e 08			ld		a, 8 
031e d3 20			out		(gpio_out_1), a 
0320 cd 3d 03			call	.led_delay 
0323 3e 04			ld		a, 4 
0325 d3 20			out		(gpio_out_1), a 
0327 cd 3d 03			call	.led_delay 
032a 3e 02			ld		a, 2 
032c d3 20			out		(gpio_out_1), a 
032e cd 3d 03			call	.led_delay 
0331 3e 01			ld		a, 1 
0333 d3 20			out		(gpio_out_1), a 
0335 cd 3d 03			call	.led_delay 
0338 3e 00			ld		a, 0 
033a d3 20			out		(gpio_out_1), a 
033c c9				ret 
033d			.led_delay: 
033d 21 00 70			ld		hl, 0x7000 
0340			.led_delay_loop: 
0340 2b				dec 	hl 
0341 7c				ld		a,h 
0342 b5				or		l 
0343 20 fb			jr		nz,.led_delay_loop 
0345 c9				ret 
0346			 
0346			 
0346			;**************************************************************************** 
0346			; Save area 
0346			;**************************************************************************** 
0346 e5			gpio_out_cache:	 db	 gpio_out_0_sd_mosi|gpio_out_0_sd_ssel|(.low_bank<<4) 
0347			 
0347			;**************************************************************************** 
0347			; Includes 
0347			;**************************************************************************** 
0347			include	'../lib/io.asm' 
0347			 
0347			;**************************************************************************** 
0347			;   TeachZ80 I/O definitions.  
0347			; 
0347			;   Original code from John Winans, Z80 Retro! 
0347			;**************************************************************************** 
0347			 
0347			;**************************************************************************** 
0347			;  TeachZ80 Version 1 IO port definitions 
0347			;**************************************************************************** 
0347			gpio_in_0:          equ     0x00        ; GP input port 0 
0347			gpio_in_1:          equ     0x50        ; GP input port 1 
0347			gpio_out_0:         equ     0x10        ; GP output port 0 
0347			gpio_out_1:         equ     0x20        ; GP output port 1, only lower 4 bits available 
0347			stm32_port:         equ     0x60        ; for communicaation with stm32 
0347			 
0347			sio_ad:             equ     0x30        ; SIO port A, data 
0347			sio_bd:             equ     0x31        ; SIO port B, data 
0347			sio_ac:             equ     0x32        ; SIO port A, control 
0347			sio_bc:             equ     0x33        ; SIO port B, control 
0347			 
0347			ctc_0:              equ     0x40        ; CTC port 0 
0347			ctc_1:              equ     0x41        ; CTC port 1 
0347			ctc_2:              equ     0x42        ; CTC port 2 
0347			ctc_3:              equ     0x43        ; CTC port 3 
0347			 
0347			flash_disable:      equ     0x70        ; dummy-read from this port to disable the FLASH and switch to RAM 
0347			 
0347			;**************************************************************************** 
0347			;  TeachZ80 Bit Assignments 
0347			;**************************************************************************** 
0347			; GP-Output-0 --------------------------------------------------------------- 
0347			gpio_out_0_sd_mosi: equ     0x01 
0347			gpio_out_0_sd_clk:  equ     0x02 
0347			gpio_out_0_sd_ssel: equ     0x04 
0347			gpio_out_0_user_8:  equ     0x08 
0347			gpio_out_0_a15:     equ     0x10 
0347			gpio_out_0_a16:     equ     0x20 
0347			gpio_out_0_a17:     equ     0x40 
0347			gpio_out_0_a18:     equ     0x80 
0347			 
0347			; GP-Output-1 --------------------------------------------------------------- 
0347			gpio_out_1_user_0:  equ     0x01 
0347			gpio_out_1_user_1:  equ     0x02 
0347			gpio_out_1_user_2:  equ     0x04 
0347			gpio_out_1_user_3:  equ     0x08 
0347			gpio_out_1_user_4:  equ     0x10 
0347			gpio_out_1_user_5:  equ     0x20 
0347			gpio_out_1_user_6:  equ     0x40 
0347			gpio_out_1_user_7:  equ     0x80 
0347			 
0347			; GP-Input-0 ---------------------------------------------------------------- 
0347			gpio_in_0_user_0:   equ     0x01 
0347			gpio_in_0_user_1:   equ     0x02 
0347			gpio_in_0_user_2:   equ     0x04 
0347			gpio_in_0_user_3:   equ     0x08 
0347			gpio_in_0_user_4:   equ     0x10 
0347			gpio_in_0_user_5:   equ     0x20 
0347			gpio_in_0_sd_det:   equ     0x40 
0347			gpio_in_0_sd_miso:  equ     0x80 
0347			 
0347			; GP-Input-1 ---------------------------------------------------------------- 
0347			gpio_in_1_user_6:   equ     0x01 
0347			gpio_in_1_user_7:   equ     0x02 
0347			gpio_in_1_user_8:   equ     0x04 
0347			gpio_in_1_user_9:   equ     0x08 
0347			 
0347			 
0347			;**************************************************************************** 
0347			;  Z80 Retro! definitions kept to maintain compatibility with Johns Software 
0347			;**************************************************************************** 
0347			; Z80 Retro Rev 3 IO port definitions 
0347			gpio_in:            equ     0x00        ; GP input port 
0347			gpio_out:           equ     0x10        ; GP output port 
0347			prn_dat:            equ     0x20        ; printer data out 
0347			 
0347			; bit-assignments for General Purpose output port  
0347			gpio_out_sd_mosi:   equ     0x01 
0347			gpio_out_sd_clk:    equ     0x02 
0347			gpio_out_sd_ssel:   equ     0x04 
0347			gpio_out_prn_stb:   equ     0x08 
0347			gpio_out_a15:       equ     0x10 
0347			gpio_out_a16:       equ     0x20 
0347			gpio_out_a17:       equ     0x40 
0347			gpio_out_a18:       equ     0x80 
0347			 
0347			; bit-assignments for General Purpose input port  
0347			gpio_in_prn_err:    equ     0x01 
0347			gpio_in_prn_stat:   equ     0x02 
0347			gpio_in_prn_papr:   equ     0x04 
0347			gpio_in_prn_bsy:    equ     0x08 
0347			gpio_in_prn_ack:    equ     0x10 
0347			gpio_in_user1:      equ     0x20  
0347			gpio_in_sd_det:     equ     0x40 
0347			gpio_in_sd_miso:    equ     0x80
# End of file ../lib/io.asm
0347			include '../lib/sio.asm' 
0347			;**************************************************************************** 
0347			; 
0347			;	 Copyright (C) 2021 John Winans 
0347			; 
0347			;	 This library is free software; you can redistribute it and/or 
0347			;	 modify it under the terms of the GNU Lesser General Public 
0347			;	 License as published by the Free Software Foundation; either 
0347			;	 version 2.1 of the License, or (at your option) any later version. 
0347			; 
0347			;	 This library is distributed in the hope that it will be useful, 
0347			;	 but WITHOUT ANY WARRANTY; without even the implied warranty of 
0347			;	 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
0347			;	 Lesser General Public License for more details. 
0347			; 
0347			;	 You should have received a copy of the GNU Lesser General Public 
0347			;	 License along with this library; if not, write to the Free Software 
0347			;	 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 
0347			;	 USA 
0347			; 
0347			; https://github.com/johnwinans/2063-Z80-cpm 
0347			; 
0347			;**************************************************************************** 
0347			 
0347			; Drivers for the SIO  
0347			 
0347			;############################################################## 
0347			; Return NZ if sio A tx is ready 
0347			; Clobbers: AF 
0347			;############################################################## 
0347			sioa_tx_ready: 
0347 db 32			in	a,(sio_ac)	; read sio control status byte 
0349 e6 04			and	4		    ; check the xmtr empty bit 
034b c9				ret			    ; a = 0 = not ready 
034c			 
034c			;############################################################## 
034c			; Return NZ if sio B tx is ready 
034c			; Clobbers: AF 
034c			;############################################################## 
034c			siob_tx_ready: 
034c db 33			in	a,(sio_bc)	; read sio control status byte 
034e e6 04			and	4		    ; check the xmtr empty bit 
0350 c9				ret			    ; a = 0 = not ready 
0351			 
0351			;############################################################## 
0351			; Return NZ (with A=1) if sio A rx is ready and Z (with A=0) if not ready. 
0351			; Clobbers: AF 
0351			;############################################################## 
0351			con_rx_ready: 
0351			sioa_rx_ready: 
0351 db 32			in	a,(sio_ac)	; read sio control status byte 
0353 e6 01			and	1		    ; check the rcvr ready bit 
0355 c9				ret			    ; 0 = not ready 
0356			 
0356			;############################################################## 
0356			; Return NZ (with A=1) if sio B rx is ready and Z (with A=0) if not ready.  
0356			; Clobbers: AF 
0356			;############################################################## 
0356			siob_rx_ready: 
0356 db 33			in	a,(sio_bc)	; read sio control status byte 
0358 e6 01			and	1		    ; check the rcvr ready bit 
035a c9				ret			    ; 0 = not ready 
035b			 
035b			;############################################################## 
035b			; init SIO port A/B 
035b			; Clobbers HL, BC, AF 
035b			;############################################################## 
035b			siob_init: 
035b 0e 33			ld	c,sio_bc	; port to write into (port B control) 
035d c3 62 03			jp	.sio_init 
0360			 
0360			sioa_init: 
0360 0e 32			ld	c,sio_ac	; port to write into (port A control) 
0362			 
0362			.sio_init: 
0362 21 6a 03			ld	hl,.sio_init_wr	; point to init string 
0365 06 07			ld	b,.sio_init_len_wr ; number of bytes to send 
0367 ed b3			otir			; write B bytes from (HL) into port in the C reg 
0369 c9				ret 
036a			 
036a			;############################################################## 
036a			; Initialization string for the Z80 SIO 
036a			;############################################################## 
036a			.sio_init_wr: 
036a 18				db	00011000b	; wr0 = reset everything 
036b 04				db	00000100b	; wr0 = select reg 4 
036c 44				db	01000100b	; wr4 = /16 N1 (115200 from 1.8432 MHZ clk) 
036d 03				db	00000011b	; wr0 = select reg 3 
036e c1				db	11000001b	; wr3 = RX enable, 8 bits/char 
036f 05				db	00000101b	; wr0 = select reg 5 
0370 68				db	01101000b	; wr5 = DTR=0, TX enable, 8 bits/char 
0371			.sio_init_len_wr:   equ $-.sio_init_wr 
0371			 
0371			;############################################################## 
0371			; Wait for the transmitter to become ready and then 
0371			; print the character in the C register. 
0371			; Clobbers: AF 
0371			;############################################################## 
0371			siob_tx_char: 
0371 cd 4c 03			call siob_tx_ready 
0374 28 fb			jr	 z,siob_tx_char 
0376 79				ld	 a,c 
0377 d3 31			out	 (sio_bd),a	; send the character 
0379 c9				ret 
037a			 
037a			con_tx_char: 
037a			sioa_tx_char: 
037a cd 47 03			call sioa_tx_ready 
037d 28 fb			jr	 z,sioa_tx_char 
037f 79				ld	 a,c 
0380 d3 30			out  (sio_ad),a	; send the character 
0382 c9				ret 
0383			 
0383			;############################################################## 
0383			; Wait for the receiver to become ready and then return the  
0383			; character in the A register. 
0383			; Clobbers: AF 
0383			;############################################################## 
0383			siob_rx_char: 
0383 cd 56 03			call	siob_rx_ready 
0386 28 fb			jr	z,siob_rx_char 
0388 3a 31 00			ld	a,(sio_bd) 
038b c9				ret 
038c			 
038c			con_rx_char: 
038c			sioa_rx_char: 
038c cd 51 03			call	sioa_rx_ready 
038f 28 fb			jr	z,sioa_rx_char 
0391 db 30			in	a,(sio_ad) 
0393 c9				ret
# End of file ../lib/sio.asm
0394			include	'../lib/hexdump.asm' 
0394			;**************************************************************************** 
0394			; 
0394			;	 Copyright (C) 2021 John Winans 
0394			; 
0394			;	 This library is free software; you can redistribute it and/or 
0394			;	 modify it under the terms of the GNU Lesser General Public 
0394			;	 License as published by the Free Software Foundation; either 
0394			;	 version 2.1 of the License, or (at your option) any later version. 
0394			; 
0394			;	 This library is distributed in the hope that it will be useful, 
0394			;	 but WITHOUT ANY WARRANTY; without even the implied warranty of 
0394			;	 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
0394			;	 Lesser General Public License for more details. 
0394			; 
0394			;	 You should have received a copy of the GNU Lesser General Public 
0394			;	 License along with this library; if not, write to the Free Software 
0394			;	 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 
0394			;	 USA 
0394			; 
0394			; https://github.com/johnwinans/2063-Z80-cpm 
0394			; 
0394			;**************************************************************************** 
0394			 
0394			;############################################################################# 
0394			; Dump BC bytes of memory from address in HL. 
0394			; if E is zero, no fancy formatting 
0394			; Does not clobber any registers 
0394			;############################################################################# 
0394			hexdump: 
0394 f5				push	af 
0395 d5				push	de 
0396 e5				push	hl 
0397 c5				push	bc 
0398 c3 b8 03			jp	    .hexdump0 
039b			 
039b			.hexdump_loop: 
039b 7b				ld	    a,e			; fancy format or continuous? 
039c b7				or	    a 
039d 28 0e			jr	    z,.hd_not8		; not fancy -> hd_not8 
039f			 
039f 7d				ld	    a,l 
03a0 e6 0f			and	    0x0f 
03a2 28 11			jr	    z,.hexdump0n 
03a4 fe 08			cp	    0x08			; put an extra space between positiioons 7 and 8 
03a6 20 05			jr	    nz,.hd_not8 
03a8 0e 20			ld	    c,' ' 
03aa cd 7a 03			call	con_tx_char 
03ad			.hd_not8: 
03ad 0e 20			ld	    c,' ' 
03af cd 7a 03			call	con_tx_char 
03b2 c3 ca 03			jp	    .hexdump1 
03b5			 
03b5			.hexdump0n: 
03b5 cd 24 04			call	puts_crlf 
03b8			.hexdump0: 
03b8 7c				ld	    a,h 
03b9 cd e9 03			call	hexdump_a 
03bc 7d				ld	    a,l 
03bd cd e9 03			call	hexdump_a 
03c0 0e 3a			ld	    c,':' 
03c2 cd 7a 03			call	con_tx_char 
03c5 0e 20			ld	    c,' ' 
03c7 cd 7a 03			call	con_tx_char 
03ca				 
03ca			.hexdump1: 
03ca 7e				ld	    a,(hl) 
03cb cd e9 03			call	hexdump_a 
03ce 23				inc	    hl 
03cf			 
03cf c1				pop	    bc 
03d0 0b				dec	    bc 
03d1 c5				push	bc 
03d2			 
03d2 78				ld	    a,b 
03d3 b1				or	    c 
03d4 20 c5			jr	    nz,.hexdump_loop 
03d6 cd 24 04			call	puts_crlf 
03d9			 
03d9 c1				pop	    bc 
03da e1				pop	    hl 
03db d1				pop	    de 
03dc f1				pop	    af 
03dd c9				ret 
03de			 
03de			;############################################################################# 
03de			; Print the value in HL in hex 
03de			; Clobbers C 
03de			;############################################################################# 
03de			hexdump_hl: 
03de f5				push 	af 
03df 7c				ld	    a,h 
03e0 cd e9 03			call	hexdump_a 
03e3 7d				ld	    a,l 
03e4 cd e9 03			call	hexdump_a 
03e7 f1				pop		af 
03e8 c9				ret 
03e9			 
03e9			;############################################################################# 
03e9			; Print the value in A in hex 
03e9			; Clobbers C 
03e9			;############################################################################# 
03e9			hexdump_a: 
03e9 f5				push	af 
03ea cb 3f			srl	a 
03ec cb 3f			srl	a 
03ee cb 3f			srl	a 
03f0 cb 3f			srl	a 
03f2 cd fe 03			call	.hexdump_nib 
03f5 f1				pop	af 
03f6 f5				push	af 
03f7 e6 0f			and	0x0f 
03f9 cd fe 03			call	.hexdump_nib 
03fc f1				pop	af 
03fd c9				ret 
03fe			 
03fe			.hexdump_nib: 
03fe c6 30			add	'0' 
0400 fe 3a			cp	'9'+1 
0402 fa 07 04			jp	m,.hexdump_num 
0405 c6 07			add	'A'-'9'-1 
0407			.hexdump_num: 
0407 4f				ld	c,a 
0408 c3 7a 03			jp	con_tx_char	   ; tail
# End of file ../lib/hexdump.asm
040b			include '../lib/puts.asm' 
040b			;**************************************************************************** 
040b			; 
040b			;    Copyright (C) 2021 John Winans 
040b			; 
040b			;    This library is free software; you can redistribute it and/or 
040b			;    modify it under the terms of the GNU Lesser General Public 
040b			;    License as published by the Free Software Foundation; either 
040b			;    version 2.1 of the License, or (at your option) any later version. 
040b			; 
040b			;    This library is distributed in the hope that it will be useful, 
040b			;    but WITHOUT ANY WARRANTY; without even the implied warranty of 
040b			;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
040b			;    Lesser General Public License for more details. 
040b			; 
040b			;    You should have received a copy of the GNU Lesser General Public 
040b			;    License along with this library; if not, write to the Free Software 
040b			;    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 
040b			;    USA 
040b			; 
040b			; https://github.com/johnwinans/2063-Z80-cpm 
040b			; 
040b			;**************************************************************************** 
040b			 
040b			;############################################################## 
040b			; Write the null-terminated string starting after the call 
040b			; instruction invoking this subroutine to the console. 
040b			; Clobbers AF, C 
040b			;############################################################## 
040b			iputs: 
040b e3			        ex      (sp),hl                 ; hl = @ of string to print 
040c cd 18 04			call	.puts_loop 
040f 23			        inc     hl                      ; point past the end of the string 
0410 e3			        ex      (sp),hl 
0411 c9			        ret 
0412			 
0412			;############################################################## 
0412			; Write the null-terminated staring starting at the address in  
0412			; HL to the console.   
0412			; Clobbers: AF, C 
0412			;############################################################## 
0412			puts: 
0412 e5				push	hl 
0413 cd 18 04			call	.puts_loop 
0416 e1				pop	hl 
0417 c9				ret 
0418			 
0418			.puts_loop: 
0418 7e			        ld      a,(hl)                  ; get the next byte to send 
0419 b7			        or      a 
041a 28 07		        jr      z,.puts_done            ; if A is zero, return 
041c 4f			        ld      c,a 
041d cd 7a 03		        call    con_tx_char 
0420 23			        inc     hl                      ; point to next byte to write 
0421 18 f5		        jr      .puts_loop 
0423			.puts_done: 
0423 c9			        ret 
0424			 
0424			;############################################################## 
0424			; Print a CRLF  
0424			; Clobbers AF, C 
0424			;############################################################## 
0424			puts_crlf: 
0424 cd 0b 04		        call    iputs 
0427 ..			        defb    '\r\n\0' 
042a c9			        ret 
042b			 
042b			;############################################################## 
042b			; Prints the (unsigned) value in HL as a decimal value to the 
042b			; console. If e is 1, leading zeros are not printed 
042b			; Clobbers nothing 
042b			;############################################################## 
042b			puts_decimal: 
042b f5			        push	af 
042c d5				push	de 
042d e5				push	hl 
042e c5				push	bc 
042f 01 f0 d8		        ld      bc, -10000 
0432 cd 53 04		        call    .puts_decimal_start 
0435 01 18 fc		        ld      bc, -1000 
0438 cd 53 04		        call    .puts_decimal_start 
043b 01 9c ff		        ld      bc, -100 
043e cd 53 04		        call    .puts_decimal_start 
0441 01 f6 ff		        ld      bc, -10 
0444 cd 53 04		        call    .puts_decimal_start 
0447 3e 30		        ld      a,'0' 
0449 85			        add     a, l 
044a 4f			        ld      c, a 
044b cd 7a 03		        call    con_tx_char 
044e c1			        pop	bc 
044f e1				pop	hl 
0450 d1				pop	de 
0451 f1				pop	af 
0452 c9			        ret 
0453			 
0453			.puts_decimal_start: 
0453 16 ff		        ld      d,-1                    ; use d as a counter 
0455			.puts_decimal_loop: 
0455 14			        inc     d                       ; increment d 
0456 09			        add     hl,bc                   ; hl = hl + bc (bc is negative). if result is < 0, carry is set 
0457 38 fc		        jr      c,.puts_decimal_loop    ; if carry is 1, hl was bigger than -bc, continue loop 
0459 ed 42		        sbc     hl,bc                   ; hl = hl-bc-c. (bc is negative) restores hl to what it was before the last loop 
045b 7a			        ld      a, d                    ; check if d is zero 
045c b7			        or      a                        
045d 20 04		        jr      nz,.puts_dec_print      ; if not zero, print it 
045f 7b			        ld      a, e                    ; if zero, check e 
0460 b7			        or      a 
0461 20 09		        jr      nz,.puts_dec_skip       ; if e is not zero, skip printing d 
0463			.puts_dec_print: 
0463 7a			        ld      a, d                    ; add ascii of '0' 
0464 c6 30		        add     '0' 
0466 4f			        ld      c, a                    ; store in c to print         
0467 1e 00		        ld      e, 0                    ; clear e, all following characters print now 
0469 cd 7a 03		        call    con_tx_char 
046c			.puts_dec_skip: 
046c c9			        ret
# End of file ../lib/puts.asm
046d			include	'../lib/spi.asm' 
046d			;**************************************************************************** 
046d			; 
046d			;   TeachZ80 SPI Driver 
046d			; 
046d			;   Based on the original code from John Winans, published under GNU LGPL: 
046d			;   https://github.com/Z80-Retro/2063-Z80-cpm/blob/main/lib/spi.asm 
046d			; 
046d			;	An SPI library suitable for tallking to SD cards.	 
046d			; 
046d			;   Author: 
046d			;   Christian Luethi 
046d			; 
046d			;**************************************************************************** 
046d			 
046d			;############################################################################ 
046d			; 
046d			; This library implements SPI mode 0 (SD cards operate on SPI mode 0.) 
046d			; Data changes on falling CLK edge & sampled on rising CLK edge: 
046d			;        __                                             ___ 
046d			; /SSEL    \______________________ ... ________________/      Host --> Device 
046d			;                 __    __    __   ... _    __    __ 
046d			; CLK    ________/  \__/  \__/  \__     \__/  \__/  \______   Host --> Device 
046d			;        _____ _____ _____ _____ _     _ _____ _____ ______ 
046d			; MOSI        \_____X_____X_____X_ ... _X_____X_____/         Host --> Device 
046d			;        _____ _____ _____ _____ _     _ _____ _____ ______ 
046d			; MISO        \_____X_____X_____X_ ... _X_____X_____/         Host <-- Device 
046d			; 
046d			;############################################################################ 
046d			 
046d			;############################################################################ 
046d			; Write 8 bits in C to the SPI port and discard the received data. 
046d			; It is assumed that the gpio_out_cache value matches the current state 
046d			; It also assumes, clock is 0 and mosi is 1 when entering 
046d			; This will leave: CLK=0, MOSI=1 
046d			; Clobbers: A 
046d			;############################################################################ 
046d			spi_write1:	macro bitpos 
046d				and		~gpio_out_sd_clk	; clear clock 
046d				and 	~gpio_out_sd_mosi	; clear mosi 
046d				bit		bitpos,c			; is the bit of C a 1? 
046d				jr		z,.write1_low			 
046d				or		gpio_out_sd_mosi	; set mosi again 
046d			.write1_low: ds 0				; for some reason, these labels disappear if there is no neumonic 
046d				out		(gpio_out),a		; clock falling edge + set data 
046d				or		gpio_out_sd_clk		; clock rising edge 
046d				out		(gpio_out),a		 
046d				endm 
046d			 
046d			spi_write8: 
046d 3a 46 03			ld		a,(gpio_out_cache)	; get current gpio_out value 
0470				spi_write1	7				; send bit 7 
0470 e6 fd			and		~gpio_out_sd_clk	; clear clock 
0472 e6 fe			and 	~gpio_out_sd_mosi	; clear mosi 
0474 cb 79			bit		7,c			; is the bit of C a 1? 
0476 28 02			jr		z,.write1_low			 
0478 f6 01			or		gpio_out_sd_mosi	; set mosi again 
047a 00...		.write1_low: ds 0				; for some reason, these labels disappear if there is no neumonic 
047a d3 10			out		(gpio_out),a		; clock falling edge + set data 
047c f6 02			or		gpio_out_sd_clk		; clock rising edge 
047e d3 10			out		(gpio_out),a		 
0480				endm 
# End of macro spi_write1
0480				spi_write1	6				; send bit 6 
0480 e6 fd			and		~gpio_out_sd_clk	; clear clock 
0482 e6 fe			and 	~gpio_out_sd_mosi	; clear mosi 
0484 cb 71			bit		6,c			; is the bit of C a 1? 
0486 28 02			jr		z,.write1_low			 
0488 f6 01			or		gpio_out_sd_mosi	; set mosi again 
048a 00...		.write1_low: ds 0				; for some reason, these labels disappear if there is no neumonic 
048a d3 10			out		(gpio_out),a		; clock falling edge + set data 
048c f6 02			or		gpio_out_sd_clk		; clock rising edge 
048e d3 10			out		(gpio_out),a		 
0490				endm 
# End of macro spi_write1
0490				spi_write1	5				; send bit 5 
0490 e6 fd			and		~gpio_out_sd_clk	; clear clock 
0492 e6 fe			and 	~gpio_out_sd_mosi	; clear mosi 
0494 cb 69			bit		5,c			; is the bit of C a 1? 
0496 28 02			jr		z,.write1_low			 
0498 f6 01			or		gpio_out_sd_mosi	; set mosi again 
049a 00...		.write1_low: ds 0				; for some reason, these labels disappear if there is no neumonic 
049a d3 10			out		(gpio_out),a		; clock falling edge + set data 
049c f6 02			or		gpio_out_sd_clk		; clock rising edge 
049e d3 10			out		(gpio_out),a		 
04a0				endm 
# End of macro spi_write1
04a0				spi_write1	4				; send bit 4 
04a0 e6 fd			and		~gpio_out_sd_clk	; clear clock 
04a2 e6 fe			and 	~gpio_out_sd_mosi	; clear mosi 
04a4 cb 61			bit		4,c			; is the bit of C a 1? 
04a6 28 02			jr		z,.write1_low			 
04a8 f6 01			or		gpio_out_sd_mosi	; set mosi again 
04aa 00...		.write1_low: ds 0				; for some reason, these labels disappear if there is no neumonic 
04aa d3 10			out		(gpio_out),a		; clock falling edge + set data 
04ac f6 02			or		gpio_out_sd_clk		; clock rising edge 
04ae d3 10			out		(gpio_out),a		 
04b0				endm 
# End of macro spi_write1
04b0				spi_write1	3				; send bit 3 
04b0 e6 fd			and		~gpio_out_sd_clk	; clear clock 
04b2 e6 fe			and 	~gpio_out_sd_mosi	; clear mosi 
04b4 cb 59			bit		3,c			; is the bit of C a 1? 
04b6 28 02			jr		z,.write1_low			 
04b8 f6 01			or		gpio_out_sd_mosi	; set mosi again 
04ba 00...		.write1_low: ds 0				; for some reason, these labels disappear if there is no neumonic 
04ba d3 10			out		(gpio_out),a		; clock falling edge + set data 
04bc f6 02			or		gpio_out_sd_clk		; clock rising edge 
04be d3 10			out		(gpio_out),a		 
04c0				endm 
# End of macro spi_write1
04c0				spi_write1	2				; send bit 2 
04c0 e6 fd			and		~gpio_out_sd_clk	; clear clock 
04c2 e6 fe			and 	~gpio_out_sd_mosi	; clear mosi 
04c4 cb 51			bit		2,c			; is the bit of C a 1? 
04c6 28 02			jr		z,.write1_low			 
04c8 f6 01			or		gpio_out_sd_mosi	; set mosi again 
04ca 00...		.write1_low: ds 0				; for some reason, these labels disappear if there is no neumonic 
04ca d3 10			out		(gpio_out),a		; clock falling edge + set data 
04cc f6 02			or		gpio_out_sd_clk		; clock rising edge 
04ce d3 10			out		(gpio_out),a		 
04d0				endm 
# End of macro spi_write1
04d0				spi_write1	1				; send bit 1 
04d0 e6 fd			and		~gpio_out_sd_clk	; clear clock 
04d2 e6 fe			and 	~gpio_out_sd_mosi	; clear mosi 
04d4 cb 49			bit		1,c			; is the bit of C a 1? 
04d6 28 02			jr		z,.write1_low			 
04d8 f6 01			or		gpio_out_sd_mosi	; set mosi again 
04da 00...		.write1_low: ds 0				; for some reason, these labels disappear if there is no neumonic 
04da d3 10			out		(gpio_out),a		; clock falling edge + set data 
04dc f6 02			or		gpio_out_sd_clk		; clock rising edge 
04de d3 10			out		(gpio_out),a		 
04e0				endm 
# End of macro spi_write1
04e0				spi_write1	0				; send bit 0 
04e0 e6 fd			and		~gpio_out_sd_clk	; clear clock 
04e2 e6 fe			and 	~gpio_out_sd_mosi	; clear mosi 
04e4 cb 41			bit		0,c			; is the bit of C a 1? 
04e6 28 02			jr		z,.write1_low			 
04e8 f6 01			or		gpio_out_sd_mosi	; set mosi again 
04ea 00...		.write1_low: ds 0				; for some reason, these labels disappear if there is no neumonic 
04ea d3 10			out		(gpio_out),a		; clock falling edge + set data 
04ec f6 02			or		gpio_out_sd_clk		; clock rising edge 
04ee d3 10			out		(gpio_out),a		 
04f0				endm 
# End of macro spi_write1
04f0 e6 fd			and		~gpio_out_sd_clk	; clear clock 
04f2 f6 01			or		gpio_out_sd_mosi	; set mosi 
04f4 d3 10			out		(gpio_out),a 
04f6 c9				ret 
04f7			 
04f7			;############################################################################ 
04f7			; Read 8 bits from the SPI & return it in A. 
04f7			; This will leave: CLK=0, MOSI=Unchanged (should be one) 
04f7			; Clobbers A, E 
04f7			;############################################################################ 
04f7			spi_read1:	macro 
04f7				or		gpio_out_sd_clk		; set clock 
04f7				out		(gpio_out),a		; clock rising edge 
04f7				push 	af					; push a, as we change it after 
04f7				in		a,(gpio_in)			; read MISO 
04f7				and 	gpio_in_sd_miso		;  
04f7				or		e					; accumulate the current MISO value 
04f7				ld		e,a					; NOTE: note this only works because gpio_in_sd_miso = 0x80 
04f7				rlc		e					; rotate the data buffer 
04f7				pop		af					; load the output chache again 
04f7				and		~gpio_out_sd_clk	; clear the clock bit 
04f7				out		(gpio_out),a		; clock falling edge edge 
04f7				endm 
04f7			 
04f7			spi_read8: 
04f7 1e 00			ld		e,0					; prepare to accumulate the bits into E 
04f9 3a 46 03			ld		a,(gpio_out_cache)	; get current gpio_out value 
04fc				spi_read1					; read bit 7 
04fc f6 02			or		gpio_out_sd_clk		; set clock 
04fe d3 10			out		(gpio_out),a		; clock rising edge 
0500 f5				push 	af					; push a, as we change it after 
0501 db 00			in		a,(gpio_in)			; read MISO 
0503 e6 80			and 	gpio_in_sd_miso		;  
0505 b3				or		e					; accumulate the current MISO value 
0506 5f				ld		e,a					; NOTE: note this only works because gpio_in_sd_miso = 0x80 
0507 cb 03			rlc		e					; rotate the data buffer 
0509 f1				pop		af					; load the output chache again 
050a e6 fd			and		~gpio_out_sd_clk	; clear the clock bit 
050c d3 10			out		(gpio_out),a		; clock falling edge edge 
050e				endm 
# End of macro spi_read1
050e				spi_read1					; read bit 6 
050e f6 02			or		gpio_out_sd_clk		; set clock 
0510 d3 10			out		(gpio_out),a		; clock rising edge 
0512 f5				push 	af					; push a, as we change it after 
0513 db 00			in		a,(gpio_in)			; read MISO 
0515 e6 80			and 	gpio_in_sd_miso		;  
0517 b3				or		e					; accumulate the current MISO value 
0518 5f				ld		e,a					; NOTE: note this only works because gpio_in_sd_miso = 0x80 
0519 cb 03			rlc		e					; rotate the data buffer 
051b f1				pop		af					; load the output chache again 
051c e6 fd			and		~gpio_out_sd_clk	; clear the clock bit 
051e d3 10			out		(gpio_out),a		; clock falling edge edge 
0520				endm 
# End of macro spi_read1
0520				spi_read1					; read bit 5 
0520 f6 02			or		gpio_out_sd_clk		; set clock 
0522 d3 10			out		(gpio_out),a		; clock rising edge 
0524 f5				push 	af					; push a, as we change it after 
0525 db 00			in		a,(gpio_in)			; read MISO 
0527 e6 80			and 	gpio_in_sd_miso		;  
0529 b3				or		e					; accumulate the current MISO value 
052a 5f				ld		e,a					; NOTE: note this only works because gpio_in_sd_miso = 0x80 
052b cb 03			rlc		e					; rotate the data buffer 
052d f1				pop		af					; load the output chache again 
052e e6 fd			and		~gpio_out_sd_clk	; clear the clock bit 
0530 d3 10			out		(gpio_out),a		; clock falling edge edge 
0532				endm 
# End of macro spi_read1
0532				spi_read1					; read bit 4 
0532 f6 02			or		gpio_out_sd_clk		; set clock 
0534 d3 10			out		(gpio_out),a		; clock rising edge 
0536 f5				push 	af					; push a, as we change it after 
0537 db 00			in		a,(gpio_in)			; read MISO 
0539 e6 80			and 	gpio_in_sd_miso		;  
053b b3				or		e					; accumulate the current MISO value 
053c 5f				ld		e,a					; NOTE: note this only works because gpio_in_sd_miso = 0x80 
053d cb 03			rlc		e					; rotate the data buffer 
053f f1				pop		af					; load the output chache again 
0540 e6 fd			and		~gpio_out_sd_clk	; clear the clock bit 
0542 d3 10			out		(gpio_out),a		; clock falling edge edge 
0544				endm 
# End of macro spi_read1
0544				spi_read1					; read bit 3 
0544 f6 02			or		gpio_out_sd_clk		; set clock 
0546 d3 10			out		(gpio_out),a		; clock rising edge 
0548 f5				push 	af					; push a, as we change it after 
0549 db 00			in		a,(gpio_in)			; read MISO 
054b e6 80			and 	gpio_in_sd_miso		;  
054d b3				or		e					; accumulate the current MISO value 
054e 5f				ld		e,a					; NOTE: note this only works because gpio_in_sd_miso = 0x80 
054f cb 03			rlc		e					; rotate the data buffer 
0551 f1				pop		af					; load the output chache again 
0552 e6 fd			and		~gpio_out_sd_clk	; clear the clock bit 
0554 d3 10			out		(gpio_out),a		; clock falling edge edge 
0556				endm 
# End of macro spi_read1
0556				spi_read1					; read bit 2 
0556 f6 02			or		gpio_out_sd_clk		; set clock 
0558 d3 10			out		(gpio_out),a		; clock rising edge 
055a f5				push 	af					; push a, as we change it after 
055b db 00			in		a,(gpio_in)			; read MISO 
055d e6 80			and 	gpio_in_sd_miso		;  
055f b3				or		e					; accumulate the current MISO value 
0560 5f				ld		e,a					; NOTE: note this only works because gpio_in_sd_miso = 0x80 
0561 cb 03			rlc		e					; rotate the data buffer 
0563 f1				pop		af					; load the output chache again 
0564 e6 fd			and		~gpio_out_sd_clk	; clear the clock bit 
0566 d3 10			out		(gpio_out),a		; clock falling edge edge 
0568				endm 
# End of macro spi_read1
0568				spi_read1					; read bit 1 
0568 f6 02			or		gpio_out_sd_clk		; set clock 
056a d3 10			out		(gpio_out),a		; clock rising edge 
056c f5				push 	af					; push a, as we change it after 
056d db 00			in		a,(gpio_in)			; read MISO 
056f e6 80			and 	gpio_in_sd_miso		;  
0571 b3				or		e					; accumulate the current MISO value 
0572 5f				ld		e,a					; NOTE: note this only works because gpio_in_sd_miso = 0x80 
0573 cb 03			rlc		e					; rotate the data buffer 
0575 f1				pop		af					; load the output chache again 
0576 e6 fd			and		~gpio_out_sd_clk	; clear the clock bit 
0578 d3 10			out		(gpio_out),a		; clock falling edge edge 
057a				endm 
# End of macro spi_read1
057a				spi_read1					; read bit 0 
057a f6 02			or		gpio_out_sd_clk		; set clock 
057c d3 10			out		(gpio_out),a		; clock rising edge 
057e f5				push 	af					; push a, as we change it after 
057f db 00			in		a,(gpio_in)			; read MISO 
0581 e6 80			and 	gpio_in_sd_miso		;  
0583 b3				or		e					; accumulate the current MISO value 
0584 5f				ld		e,a					; NOTE: note this only works because gpio_in_sd_miso = 0x80 
0585 cb 03			rlc		e					; rotate the data buffer 
0587 f1				pop		af					; load the output chache again 
0588 e6 fd			and		~gpio_out_sd_clk	; clear the clock bit 
058a d3 10			out		(gpio_out),a		; clock falling edge edge 
058c				endm 
# End of macro spi_read1
058c 7b				ld a,e						; final value in a 
058d c9				ret 
058e			 
058e			;############################################################## 
058e			; HL = @ of bytes to write  
058e			; B = byte count 
058e			; clobbers: A, BC, D, HL 
058e			;############################################################## 
058e			spi_write_str: 
058e 4e				ld		c,(hl)				; get next byte to send 
058f cd 6d 04			call	spi_write8			; send it 
0592 23				inc		hl					; point to the next byte 
0593 10 f9			djnz	spi_write_str		; count the byte & continue of not done 
0595 c9				ret 
0596			 
0596			;############################################################## 
0596			; Assert the select line (set it low) 
0596			; This will leave: SSEL=0, CLK=0, MOSI=1 
0596			; Clobbers A, C 
0596			;############################################################## 
0596			spi_ssel_true: 
0596 0e ff			ld		c,0xFF 
0598 cd 6d 04			call	spi_write8 
059b 3a 46 03			ld		a,(gpio_out_cache) 
059e e6 fb			and		~gpio_out_sd_ssel		; SSEL = 0 
05a0 32 46 03			ld		(gpio_out_cache),a		; save current state in the cache 
05a3 d3 10			out		(gpio_out),a 
05a5 cd 6d 04			call	spi_write8 
05a8 c9				ret 
05a9			 
05a9			;############################################################## 
05a9			; de-assert the select line (set it high) 
05a9			; This will leave: SSEL=1, CLK=0, MOSI=1 
05a9			; Clobbers A, C 
05a9			;############################################################## 
05a9			spi_ssel_false: 
05a9 0e ff			ld		c,0xFF 
05ab cd 6d 04			call	spi_write8 
05ae 3a 46 03			ld		a,(gpio_out_cache) 
05b1 e6 04			and		gpio_out_sd_ssel		; SSEL = 1 
05b3 32 46 03			ld		(gpio_out_cache),a		; save current state in the cache 
05b6 d3 10			out		(gpio_out),a 
05b8 cd 6d 04			call	spi_write8 
05bb c9				ret
# End of file ../lib/spi.asm
05bc			include	'../lib/sdcard.asm' 
05bc			;**************************************************************************** 
05bc			; 
05bc			;   TeachZ80 SD Card Driver 
05bc			; 
05bc			;   Based on the original code from John Winans, published under GNU LGPL: 
05bc			;   https://github.com/Z80-Retro/2063-Z80-cpm/blob/main/lib/sdcard.asm 
05bc			; 
05bc			;	An SD card library suitable for talking to SD cards in SPI mode 0.	 
05bc			; 
05bc			; 	References: 
05bc			; 	- SD Simplified Specifications, Physical Layer Simplified Specification,  
05bc			;   	Version 8.00:    https://www.sdcard.org/downloads/pls/ 
05bc			; 
05bc			; 	The details on operating an SD card in SPI mode can be found in  
05bc			; 	Section 7 of the SD specification, p242-264. 
05bc			; 
05bc			; 	To initialize an SDHC/SDXC card: 
05bc			; 	- send at least 74 CLKs 
05bc			; 	- send CMD0 & expect reply message = 0x01 (enter SPI mode) 
05bc			; 	- send CMD8 (establish that the host uses Version 2.0 SD SPI protocol) 
05bc			; 	- send ACMD41 (finish bringing the SD card on line) 
05bc			; 	- send CMD58 to verify the card is SDHC/SDXC mode (512-byte block size) 
05bc			; 
05bc			; 	At this point the card is on line and ready to read and write  
05bc			; 	memory blocks. 
05bc			; 
05bc			; 	- use CMD17 to read one 512-byte block 
05bc			; 	- use CMD24 to write one 512-byte block 
05bc			; 
05bc			;	Author: 
05bc			;	Christian Luethi 
05bc			; 
05bc			;############################################################################ 
05bc			 
05bc			;**************************************************************************** 
05bc			; Constants 
05bc			;**************************************************************************** 
05bc			.sd_debug: 		equ 1 
05bc 40 00 00 00 00 95	.sd_cmd0:		db	0|0x40,0,0,0,0,0x94|0x01 
05c2 48 00 00 01 aa 87	.sd_cmd8:		db	8|0x40,0,0,0x01,0xaa,0x86|0x01 
05c8 77 00 00 00 00 01	.sd_cmd55:		db	55|0x40,0,0,0,0,0x00|0x01 
05ce 69 40 00 00 00 01	.sd_acmd41:		db	41|0x40,0x40,0,0,0,0x00|0x01 
05d4 7a 00 00 00 00 01	.sd_cmd58:		db	58|0x40,0,0,0,0,0x00|0x01 
05da			 
05da			;############################################################################ 
05da			; SSEL = HI (deassert) 
05da			; wait at least 1 msec after power up 
05da			; send at least 74 (80) SCLK rising edges 
05da			; Clobbers A, B, C 
05da			;############################################################################ 
05da			.sd_wakeup: 
05da 06 0a			ld		b,10						; 10*8 = 80 bits to read 
05dc 0e ff			ld		c,0xFF						; set c=0xff, write will leave MOSI high 
05de			.sd_wakeup_loop: 
05de cd 6d 04			call	spi_write8					; write 8 bits (causes 8 clocks with MOSI high) 
05e1 10 fb			djnz	.sd_wakeup_loop				; if not yet done, do another byte 
05e3 c9				ret 
05e4			 
05e4			;############################################################################ 
05e4			; Set SSEL high or low 
05e4			; Generate 8 clocks before and after, according SD specification 
05e4			; Clobbers A, C 
05e4			;############################################################################ 
05e4			.sd_ssel_low: 
05e4 0e ff			ld		c, 0xFF						; set c=0xff, write will leave MOSI high 
05e6 cd 6d 04			call	spi_write8					; generate 8 clocks 
05e9 3a 46 03			ld		a,(gpio_out_cache)			; read output cache 
05ec e6 fb			and		~gpio_out_sd_ssel			; clear sd_sel bit 
05ee d3 10			out		(gpio_out_0),a				; set sd_sel line to the required state 
05f0 32 46 03			ld		(gpio_out_cache), a			; update the output cache with the new state 
05f3 cd 6d 04			call	spi_write8					; create another 8 clocks 
05f6 c9				ret		 
05f7			 
05f7			.sd_ssel_high: 
05f7 0e ff			ld		c, 0xFF						; set c=0xff, write will leave MOSI high 
05f9 cd 6d 04			call	spi_write8					; generate 8 clocks 
05fc 3a 46 03			ld		a,(gpio_out_cache)			; read output cache 
05ff f6 04			or		gpio_out_sd_ssel			; set sd_sel bit 
0601 d3 10			out		(gpio_out_0),a				; set sd_sel line to the required state 
0603 32 46 03			ld		(gpio_out_cache), a			; update the output cache with the new state 
0606 cd 6d 04			call	spi_write8					; create another 8 clocks 
0609 c9				ret		 
060a			 
060a			;############################################################################ 
060a			; Send the command pointed by IX and reads expected amount of reseponse bytes 
060a			; The response is stored in the .sd_scratch buffer. The amount of bytes sent 
060a			; in a command is fixed to 6. If e is set to one, the function also controls 
060a			; the ssel line. If e is set to one, ssel line needs to be controlled by  
060a			; the calling function (required for read and writes) 
060a			;	- IX: Address of buffer to send to card 
060a			;	- B : Amount of bytes to read 
060a			;	- E : 0 = Do not control SSEL, 1 = control SSEL 
060a			; 
060a			; When reading, the function tries up to 0x0F times to read a byte with  
060a			; bit 7 cleared according the SD specification. When received, or after,  
060a			; the maximum amount of retries, it continues to read the reamining amount 
060a			; of bytes and returns 
060a			; 
060a			; Clobbers A, IX, IY 
060a			;############################################################################ 
060a			.sd_command: 
060a d5				push 	de								; for later convenience 
060b c5				push 	bc								; required by the function 
060c cb 43			bit		0,e								; check if bit 0 in e is 0 
060e 28 03			jr		z,.sd_command_send				; if so, skip controlling ssel 
0610 cd e4 05			call	.sd_ssel_low					; set ssel low 
0613			.sd_command_send: 
0613 fd 21 52 07		ld		iy,.sd_scratch					; iy = scratch buffer 
0617 06 06			ld		b, 6							; we will send 6 bytes 
0619			.sd_command_send_loop: 
0619 dd 4e 00			ld 		c,(ix+0)						; load next character to send 
061c cd 6d 04			call	spi_write8;						; send the character 
061f dd 23			inc		ix								; ix point to next character 
0621 10 f6			djnz	.sd_command_send_loop			; repeat until b is 0							 
0623 06 0f			ld		b, 0x0f							; b now holds the max amount of read-tries before giving up 
0625			.sd_command_read_start:						 
0625 cd f7 04			call 	spi_read8						; read one byte 
0628 cb 7f			bit		7,a								; check if bit 7 is set 
062a 28 02			jr		z,.sd_command_read_remaining	; if not set, continue reading remaining bytes, else try again 
062c 10 f7			djnz	.sd_command_read_start			; repeat until b is 0 
062e			.sd_command_read_remaining:							 
062e fd 77 00			ld		(iy+0),a						; store the last byte received 
0631 c1				pop		bc								; peek original bc 
0632 c5				push 	bc	 
0633 05				dec		b								; decrement b 
0634 28 0c			jr		z,.sd_command_finish			; if here b is zero, we are done 
0636 fd 23			inc 	iy								; increment destination pointer 
0638			.sd_command_read_loop: 
0638 cd f7 04			call 	spi_read8						; read next byte 
063b fd 77 00			ld		(iy+0),a						; store it 
063e fd 23			inc 	iy	 
0640 10 f6			djnz	.sd_command_read_loop			; repeat until b is 0 
0642			.sd_command_finish: 
0642 c1				pop		bc								; restore  
0643 d1				pop 	de								; restore  
0644 cb 43			bit		0,e								; check if bit 0 in e is 0 
0646 28 03			jr		z,.sd_command_exit				; if so, skip controlling ssel 
0648 cd f7 05			call	.sd_ssel_high					; set ssel low 
064b			.sd_command_exit: 
064b c9				ret 
064c			 
064c			;############################################################################ 
064c			; Initialize the SD and make it ready to following block read and writes 
064c			; 
064c			; Performs the following: 
064c			;	- check if a card is installed in the slot 
064c			; 	- wake-up the SD card by sending 80 clocks with ssel set high 
064c			; 	- send CMD 0, check valid reposnse 
064c			;	- send CMD 8, check valid response 
064c			;	- loop sending CMD 55 followed by ACMD41, and wait until card becomes ready 
064c			;	- send CMD 58 and check card capacity (SD or XC) 
064c			; 
064c			; Returns the result of the operation in A: 
064c			; 	- A = 0 : Card successfully accessed 
064c			; 	- A = 1 : CMD 0 unexpected response 
064c			; 	- A = 2 : CMD 8 unesxpectd response 
064c			; 	- A = 3 : ACMD 41 timed out, card not ready 
064c			;	- A = 4 : CMD 58 invalid response ,card not ready 
064c			;	- A = 5 : CMD 58 unsupported card format (not SD, XC) 
064c			;	- A = 6 : No card in SD slot 
064c			; 
064c			; Clobbers everything 
064c			;############################################################################ 
064c			sd_initialize: 
064c			 
064c				; **** Check if there is a card in the slot ******************************	 
064c db 00			in      a,(gpio_in_0)            	; read input port       
064e e6 40		    and     gpio_in_0_sd_det			; check if sd_det line is low (card installed) 
0650 28 03		    jr      z,.sd_access_wakeup			; go to next command 
0652 3e 06			ld		a, 6						; return error 6 
0654 c9				ret 
0655			 
0655				; **** Wakeup the card by sending 80 clocks ******************************	 
0655			.sd_access_wakeup: 
0655 cd da 05			call	.sd_wakeup					; send 80 clocks 
0658			 
0658			.sd_access_cmd_0: 
0658				; **** SEND CMD 0  - (GO_IDLE) *******************************************	 
0658				; Read one byte, the expected result is 0x01	 
0658 06 01			ld		b,1							; 1 byte response expected 
065a 1e 01			ld 		e,1							; control ssel 
065c dd 21 bc 05		ld 		ix,.sd_cmd0					; send CMD 0 
0660 cd 0a 06			call 	.sd_command					; send 
0663 3a 52 07			ld		a,(.sd_scratch)				; check received byte 
0666 fe 01			cp		0x01						; must be 0x01 
0668 28 03			jr	    z,.sd_access_cmd_8			; jump to next command 
066a 3e 01			ld		a, 1						; return error 1 
066c c9				ret									 
066d			 
066d				; **** SEND CMD 8 (SEND_IF_COND) *****************************************	 
066d				; The response should be: 0x01 0x00 0x00 0x01 0xAA. 
066d				; for simplicity we just check the first byte for now 
066d			.sd_access_cmd_8: 
066d 06 05			ld		b,5							; 1 byte response expected 
066f dd 21 c2 05		ld 		ix,.sd_cmd8					; send CMD 8 
0673 cd 0a 06			call 	.sd_command					; send 
0676 3a 52 07			ld		a,(.sd_scratch)				; check received byte 
0679 fe 01			cp		0x01						; must be 0x01 
067b 28 05			jr	    z,.sd_access_acmd_41		; jump to next command 
067d 3e 02			ld		a, 2						; return error 2 
067f c9				ret	 
0680			 
0680				; **** SEND ACMD41 (SD_SEND_OP_COND) **************************************	 
0680				; this must be sent after a CMD 55 (APP_CMD), and can take up to one second 
0680				; The response od CMD 55 should be 0x01, ACMD41 should return 0x00 (ready!) 
0680				; if a try does is not successful, waste a bit of time 
0680 16 ff			ld		d,0xFF						; maximum tries for ACMD55, use d as a counter 
0682			.sd_access_acmd_41: 
0682 06 01			ld		b,1							; 1 byte response expected for CMD 55 
0684 dd 21 c8 05		ld 		ix,.sd_cmd55				; send CMD 55 
0688 cd 0a 06			call 	.sd_command					; send 
068b 3a 52 07			ld		a,(.sd_scratch)				; check received byte 
068e fe 01			cp		0x01						; must be 0x01 
0690 20 0e			jr		nz,.sd_access_acmd_41_delay	; response was not 0x01, delay before next try 
0692 dd 21 ce 05		ld 		ix,.sd_acmd41  				; response was 0x01, continue with ACMD41 
0696 cd 0a 06			call 	.sd_command					; send 
0699 3a 52 07			ld		a,(.sd_scratch)				; check received byte 
069c fe 00			cp		0x00						; must be 0x00 
069e 28 0e			jr	    z,.sd_access_cmd_58			; jump to next command if it is 
06a0			.sd_access_acmd_41_delay:			 
06a0 21 00 01			ld 		hl, 0x0100					; loop counter for delay 
06a3			.sd_access_acmd_41_delay_loop: 
06a3 2b				dec		hl							; decrement until hl is 0 
06a4 7c				ld		a,h 
06a5 b5				or		l 
06a6 20 fb			jr		nz,.sd_access_acmd_41_delay_loop 
06a8 15				dec		d							; decrement d, check if maximum amount of tries exceeded 
06a9 20 d7			jr		nz,.sd_access_acmd_41		; if the counter is not 0, start next try 
06ab 3e 03			ld		a, 3						; else, return error 3 
06ad c9				ret 
06ae			 
06ae				; **** SEND CMD 58 (READ_OCR) ********************************************	 
06ae				; Check if its SDHC or SDXC card  
06ae				; Only these cards are supported, they have 512 bytes blockside by default		 
06ae				; The first response byte expects a 0x00 (card ready) 
06ae				; The second response byte expects bit 6 set high 
06ae			.sd_access_cmd_58: 
06ae 06 05			ld		b,5							; 5 byte response expected 
06b0 dd 21 d4 05		ld 		ix,.sd_cmd58				; send CMD 8 
06b4 cd 0a 06			call 	.sd_command					; send 
06b7 dd 21 52 07		ld		ix,.sd_scratch				; access response buffer with an index register  
06bb dd 7e 00			ld		a,(ix+0)					; check the first recevived byte 
06be fe 00			cp		0x00						; check if byte 0 is 0 
06c0 28 03			jr		z,.sd_access_cmd_58_2		; if so, check send byte received 
06c2 3e 04			ld		a, 4						; else, return error 4 
06c4 c9				ret 
06c5			.sd_access_cmd_58_2: 
06c5 dd 21 52 07		ld		ix,.sd_scratch				; access the reponse buffer with an index register 
06c9 dd 7e 01			ld		a,(ix+1)					; check the second recevived byte 
06cc cb 77			bit		6,a							; check bit 6 
06ce 20 03			jr		nz,.sd_access_complete		; if it is not zero, everything is ok 
06d0 3e 05			ld 		a, 5						; else, return error 5 
06d2 c9				ret 
06d3			.sd_access_complete: 
06d3 3e 00			ld 		a, 0						; all complete with no error 
06d5 c9				ret 
06d6			 
06d6			 
06d6			;############################################################################ 
06d6			; Read one block of SD data into RAM 
06d6			; 
06d6			; Read one block given by the 32-bit (little endian) number at  
06d6			; the top of the stack into the buffer given by address in DE. 
06d6			; 
06d6			; - clear SSEL line 
06d6			; - send command 
06d6			; - read for CMD ACK 
06d6			; - wait for 'data token' 
06d6			; - read data block 
06d6			; - read data CRC 
06d6			; - set SSEL line 
06d6			; 
06d6			; Returns the result of the operation in A: 
06d6			; 	- A = 0 : Block sucessfully read 
06d6			; 	- A = 1 : Card not ready 
06d6			; 	- A = 2 : Timout happened when waiting for data token 
06d6			;	- A = 3	: Invalid data token received 
06d6			; 
06d6			; Clobbers AF, BC, IX, IY 
06d6			;############################################################################ 
06d6			sd_readBlock: 
06d6				; Stack orgqanization at this point:  sp +5 = block number 31-24 
06d6													; sp +4 = block number 23-16 
06d6													; sp +3 = block number 15-08 
06d6													; sp +2 = block number 07-00 
06d6													; sp +1 = return @ High 
06d6													; sp +0 = return @ Low 
06d6			 
06d6				; **** Generate CMD17 command buffer************************************** 
06d6 dd 21 52 07		ld		ix,.sd_scratch				; ix = buffer to sd command buffer 
06da fd 21 00 00		ld		iy,0	 
06de fd 39			add		iy,sp						; iy = address if current stackpointer 
06e0			 
06e0 dd 36 00 51		ld		(ix+0),17|0x40				; CMD 17 command byte 
06e4 fd 7e 05			ld		a,(iy+5)					; CMD 17 block number 31-24 
06e7 dd 77 01			ld		(ix+1),a					 
06ea fd 7e 04			ld		a,(iy+4)					; CMD 17 block number 23-16		 
06ed dd 77 02			ld		(ix+2),a 
06f0 fd 7e 03			ld		a,(iy+3)					; CMD 17 block number 15-08 
06f3 dd 77 03			ld		(ix+3),a 
06f6 fd 7e 02			ld		a,(iy+2)					; CMD 17 block number 07-00 
06f9 dd 77 04			ld		(ix+4),a 
06fc dd 36 05 01		ld		(ix+5),0x00|0x01			; the CRC byte 
0700			 
0700				; **** Send command to the card ****************************************** 
0700 d5				push	de							; backup de 
0701 cd e4 05			call	.sd_ssel_low				; SSEL line low 
0704 06 01			ld		b,1							; CMD 17 expects 1 byte reponse 
0706 1e 00			ld		e,0							; SSEL line controlled manually		 
0708 cd 0a 06			call	.sd_command					; send command to card 
070b 3a 52 07			ld		a,(.sd_scratch)				; check if card returned 0x00 -> ok 
070e b7				or		a 
070f 28 04			jr		z,.sd_read_wait_token		; if zero, start waiting for the token 
0711 06 01			ld		b,1							; else, return error 1 
0713 18 37			jr		.sd_read_exit		 
0715			 
0715				; **** Wait for Data token *********************************************** 
0715			.sd_read_wait_token: 
0715 01 00 10			ld		bc, 0x1000					; data token loop max tries 
0718			.sd_read_wait_token_loop: 
0718 cd f7 04			call	spi_read8					; read one byte from the card 
071b fe ff			cp		0xFF						; compare with 0xFF 
071d 20 09			jr		nz,.sd_check_token 			; if not 0xFF, check the token 
071f 0b				dec		bc							; decrement counter 
0720 78				ld		a,b 
0721 b1				or		c 
0722 20 f4			jr		nz,.sd_read_wait_token_loop ; if not zero, next try 
0724 06 02			ld		b,2							; if zero, timeout happened, return error 2 
0726 18 24			jr		.sd_read_exit 
0728			 
0728				; **** Check if received to ken is valid ********************************* 
0728			.sd_check_token: 
0728 fe fe			cp		0xFE						; 0xFE is the expected token when card is ready to send 
072a 28 04			jr		z,.sd_read_data 			; if 0xFE, start reading data 
072c 06 03			ld		b,3							; if not, return error 3 
072e 18 1c			jr		.sd_read_exit	 
0730			 
0730				; **** Read the data ***************************************************** 
0730			.sd_read_data: 
0730 dd e1			pop 	ix							; restore de from stack and store it in ix 
0732 dd e5			push	ix							; push it to the stack again, it will be removed when functions exits 
0734 01 00 02			ld		bc,512						; use bc as a counter, we read 512 bytes from the card 
0737			.sd_read_data_loop:	 
0737 cd f7 04			call	spi_read8					; read one byte from the card 
073a dd 77 00			ld		(ix+0),a					; store it 
073d dd 23			inc 	ix							; increment destination pointer 
073f 0b				dec		bc							; decrement counter 
0740 78				ld		a,b	 
0741 b1				or		c 
0742 20 f3			jr		nz,.sd_read_data_loop		; if counter is not zero, read next byte 
0744			 
0744				; **** Read CRC ********************************************************** 
0744 cd f7 04			call	spi_read8					; read first byte and ignore it 
0747 cd f7 04			call	spi_read8					; read second byte and ignore it 
074a 06 00			ld		b,0							; we are done, return 0 
074c			 
074c			.sd_read_exit: 
074c cd f7 05			call	.sd_ssel_high				; set ssel line again 
074f d1				pop 	de							; cleanup stack, restire de 
0750 78				ld		a,b							; copy return code 
0751 c9				ret	 
0752			 
0752			;############################################################################ 
0752			; A buffer for exchanging messages with the SD card. 
0752			;############################################################################ 
0752 00...		.sd_scratch: 	ds		6
# End of file ../lib/sdcard.asm
0758			 
0758			;############################################################################## 
0758			; This marks the end of the data copied from FLASH into RAM during boot 
0758			;############################################################################## 
0758			.end:		    equ	$
# End of file bootstrap.asm
0758
